!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a)
                    return a(o, !0);
                if (i)
                    return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND",
                f
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n || e)
            }, l, l.exports, e, t, n, r)
        }
        return n[o].exports
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++)
        s(r[o]);
    return s
}({
    1: [function(require, module, exports) {
        (function(global) {
            require("modernizr/modernizr"),
            global.URI = require("URI"),
            global.Cookies = require("js-cookie/src/js.cookie"),
            global.Logger = require("lite-log/logger"),
            global.jQuery = require("jquery"),
            global.$ = jQuery,
            require("jquery.validate"),
            require("slick"),
            require("picturefill"),
            require("lazysizes"),
            require("jquery-zoom"),
            require("jquery.scrollTo"),
            require("jquery.sticky-kit"),
            require("gmaps-marker-clusterer/src/markerclusterer"),
            require("rails"),
            require("jquery.payment"),
            require("jquery.URI"),
            require("bootstrap-datepicker"),
            require("what-input"),
            require("jquery-nice-select"),
            require("mailcheck"),
            global.noUiSlider = require("nouislider"),
            global.vex = require("vex"),
            global.jRespond = require("jrespond/jRespond"),
            global._ = require("lodash/dist/lodash")
        }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    , {
        URI: 24,
        "bootstrap-datepicker": 2,
        "gmaps-marker-clusterer/src/markerclusterer": 3,
        jquery: 10,
        "jquery-nice-select": 4,
        "jquery-zoom": 7,
        "jquery.URI": 25,
        "jquery.payment": 8,
        "jquery.scrollTo": 9,
        "jquery.sticky-kit": 21,
        "jquery.validate": 6,
        "jrespond/jRespond": 11,
        "js-cookie/src/js.cookie": 12,
        lazysizes: 13,
        "lite-log/logger": 14,
        "lodash/dist/lodash": 15,
        mailcheck: 16,
        "modernizr/modernizr": 17,
        nouislider: 18,
        picturefill: 19,
        rails: 5,
        slick: 20,
        vex: 27,
        "what-input": 28
    }],
    2: [function(require, module, exports) {
        !function(factory) {
            "function" == typeof define && define.amd ? define(["jquery"], factory) : factory("object" == typeof exports ? require("jquery") : jQuery)
        }(function($, undefined) {
            function UTCDate() {
                return new Date(Date.UTC.apply(Date, arguments))
            }
            function UTCToday() {
                var today = new Date;
                return UTCDate(today.getFullYear(), today.getMonth(), today.getDate())
            }
            function isUTCEquals(date1, date2) {
                return date1.getUTCFullYear() === date2.getUTCFullYear() && date1.getUTCMonth() === date2.getUTCMonth() && date1.getUTCDate() === date2.getUTCDate()
            }
            function alias(method, deprecationMsg) {
                return function() {
                    return deprecationMsg !== undefined && $.fn.datepicker.deprecated(deprecationMsg),
                    this[method].apply(this, arguments)
                }
            }
            function isValidDate(d) {
                return d && !isNaN(d.getTime())
            }
            function opts_from_el(el, prefix) {
                var data = $(el).data()
                  , out = {}
                  , replace = new RegExp("^" + prefix.toLowerCase() + "([A-Z])");
                prefix = new RegExp("^" + prefix.toLowerCase());
                for (var key in data)
                    prefix.test(key) && (out[key.replace(replace, function(_, a) {
                        return a.toLowerCase()
                    })] = data[key]);
                return out
            }
            function opts_from_locale(lang) {
                var out = {};
                if (dates[lang] || (lang = lang.split("-")[0],
                dates[lang])) {
                    var d = dates[lang];
                    return $.each(locale_opts, function(i, k) {
                        k in d && (out[k] = d[k])
                    }),
                    out
                }
            }
            var DateArray = function() {
                var extras = {
                    get: function(i) {
                        return this.slice(i)[0]
                    },
                    contains: function(d) {
                        for (var val = d && d.valueOf(), i = 0, l = this.length; i < l; i++)
                            if (0 <= this[i].valueOf() - val && this[i].valueOf() - val < 864e5)
                                return i;
                        return -1
                    },
                    remove: function(i) {
                        this.splice(i, 1)
                    },
                    replace: function(new_array) {
                        new_array && ($.isArray(new_array) || (new_array = [new_array]),
                        this.clear(),
                        this.push.apply(this, new_array))
                    },
                    clear: function() {
                        this.length = 0
                    },
                    copy: function() {
                        var a = new DateArray;
                        return a.replace(this),
                        a
                    }
                };
                return function() {
                    var a = [];
                    return a.push.apply(a, arguments),
                    $.extend(a, extras),
                    a
                }
            }()
              , Datepicker = function(element, options) {
                $.data(element, "datepicker", this),
                this._process_options(options),
                this.dates = new DateArray,
                this.viewDate = this.o.defaultViewDate,
                this.focusDate = null,
                this.element = $(element),
                this.isInput = this.element.is("input"),
                this.inputField = this.isInput ? this.element : this.element.find("input"),
                this.component = !!this.element.hasClass("date") && this.element.find(".add-on, .input-group-addon, .btn"),
                this.component && 0 === this.component.length && (this.component = !1),
                this.isInline = !this.component && this.element.is("div"),
                this.picker = $(DPGlobal.template),
                this._check_template(this.o.templates.leftArrow) && this.picker.find(".prev").html(this.o.templates.leftArrow),
                this._check_template(this.o.templates.rightArrow) && this.picker.find(".next").html(this.o.templates.rightArrow),
                this._buildEvents(),
                this._attachEvents(),
                this.isInline ? this.picker.addClass("datepicker-inline").appendTo(this.element) : this.picker.addClass("datepicker-dropdown dropdown-menu"),
                this.o.rtl && this.picker.addClass("datepicker-rtl"),
                this.o.calendarWeeks && this.picker.find(".datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan", function(i, val) {
                    return Number(val) + 1
                }),
                this._process_options({
                    startDate: this._o.startDate,
                    endDate: this._o.endDate,
                    daysOfWeekDisabled: this.o.daysOfWeekDisabled,
                    daysOfWeekHighlighted: this.o.daysOfWeekHighlighted,
                    datesDisabled: this.o.datesDisabled
                }),
                this._allow_update = !1,
                this.setViewMode(this.o.startView),
                this._allow_update = !0,
                this.fillDow(),
                this.fillMonths(),
                this.update(),
                this.isInline && this.show()
            };
            Datepicker.prototype = {
                constructor: Datepicker,
                _resolveViewName: function(view) {
                    return $.each(DPGlobal.viewModes, function(i, viewMode) {
                        if (view === i || -1 !== $.inArray(view, viewMode.names))
                            return view = i,
                            !1
                    }),
                    view
                },
                _resolveDaysOfWeek: function(daysOfWeek) {
                    return $.isArray(daysOfWeek) || (daysOfWeek = daysOfWeek.split(/[,\s]*/)),
                    $.map(daysOfWeek, Number)
                },
                _check_template: function(tmp) {
                    try {
                        return tmp !== undefined && "" !== tmp && ((tmp.match(/[<>]/g) || []).length <= 0 || $(tmp).length > 0)
                    } catch (ex) {
                        return !1
                    }
                },
                _process_options: function(opts) {
                    this._o = $.extend({}, this._o, opts);
                    var o = this.o = $.extend({}, this._o)
                      , lang = o.language;
                    dates[lang] || (lang = lang.split("-")[0],
                    dates[lang] || (lang = defaults.language)),
                    o.language = lang,
                    o.startView = this._resolveViewName(o.startView),
                    o.minViewMode = this._resolveViewName(o.minViewMode),
                    o.maxViewMode = this._resolveViewName(o.maxViewMode),
                    o.startView = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, o.startView)),
                    !0 !== o.multidate && (o.multidate = Number(o.multidate) || !1,
                    !1 !== o.multidate && (o.multidate = Math.max(0, o.multidate))),
                    o.multidateSeparator = String(o.multidateSeparator),
                    o.weekStart %= 7,
                    o.weekEnd = (o.weekStart + 6) % 7;
                    var format = DPGlobal.parseFormat(o.format);
                    o.startDate !== -1 / 0 && (o.startDate ? o.startDate instanceof Date ? o.startDate = this._local_to_utc(this._zero_time(o.startDate)) : o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear) : o.startDate = -1 / 0),
                    o.endDate !== 1 / 0 && (o.endDate ? o.endDate instanceof Date ? o.endDate = this._local_to_utc(this._zero_time(o.endDate)) : o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear) : o.endDate = 1 / 0),
                    o.daysOfWeekDisabled = this._resolveDaysOfWeek(o.daysOfWeekDisabled || []),
                    o.daysOfWeekHighlighted = this._resolveDaysOfWeek(o.daysOfWeekHighlighted || []),
                    o.datesDisabled = o.datesDisabled || [],
                    $.isArray(o.datesDisabled) || (o.datesDisabled = o.datesDisabled.split(",")),
                    o.datesDisabled = $.map(o.datesDisabled, function(d) {
                        return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear)
                    });
                    var plc = String(o.orientation).toLowerCase().split(/\s+/g)
                      , _plc = o.orientation.toLowerCase();
                    if (plc = $.grep(plc, function(word) {
                        return /^auto|left|right|top|bottom$/.test(word)
                    }),
                    o.orientation = {
                        x: "auto",
                        y: "auto"
                    },
                    _plc && "auto" !== _plc)
                        if (1 === plc.length)
                            switch (plc[0]) {
                            case "top":
                            case "bottom":
                                o.orientation.y = plc[0];
                                break;
                            case "left":
                            case "right":
                                o.orientation.x = plc[0]
                            }
                        else
                            _plc = $.grep(plc, function(word) {
                                return /^left|right$/.test(word)
                            }),
                            o.orientation.x = _plc[0] || "auto",
                            _plc = $.grep(plc, function(word) {
                                return /^top|bottom$/.test(word)
                            }),
                            o.orientation.y = _plc[0] || "auto";
                    else
                        ;if (o.defaultViewDate instanceof Date || "string" == typeof o.defaultViewDate)
                        o.defaultViewDate = DPGlobal.parseDate(o.defaultViewDate, format, o.language, o.assumeNearbyYear);
                    else if (o.defaultViewDate) {
                        var year = o.defaultViewDate.year || (new Date).getFullYear()
                          , month = o.defaultViewDate.month || 0
                          , day = o.defaultViewDate.day || 1;
                        o.defaultViewDate = UTCDate(year, month, day)
                    } else
                        o.defaultViewDate = UTCToday()
                },
                _events: [],
                _secondaryEvents: [],
                _applyEvents: function(evs) {
                    for (var el, ch, ev, i = 0; i < evs.length; i++)
                        el = evs[i][0],
                        2 === evs[i].length ? (ch = undefined,
                        ev = evs[i][1]) : 3 === evs[i].length && (ch = evs[i][1],
                        ev = evs[i][2]),
                        el.on(ev, ch)
                },
                _unapplyEvents: function(evs) {
                    for (var el, ev, ch, i = 0; i < evs.length; i++)
                        el = evs[i][0],
                        2 === evs[i].length ? (ch = undefined,
                        ev = evs[i][1]) : 3 === evs[i].length && (ch = evs[i][1],
                        ev = evs[i][2]),
                        el.off(ev, ch)
                },
                _buildEvents: function() {
                    var events = {
                        keyup: $.proxy(function(e) {
                            -1 === $.inArray(e.keyCode, [27, 37, 39, 38, 40, 32, 13, 9]) && this.update()
                        }, this),
                        keydown: $.proxy(this.keydown, this),
                        paste: $.proxy(this.paste, this)
                    };
                    !0 === this.o.showOnFocus && (events.focus = $.proxy(this.show, this)),
                    this.isInput ? this._events = [[this.element, events]] : this.component && this.inputField.length ? this._events = [[this.inputField, events], [this.component, {
                        click: $.proxy(this.show, this)
                    }]] : this._events = [[this.element, {
                        click: $.proxy(this.show, this),
                        keydown: $.proxy(this.keydown, this)
                    }]],
                    this._events.push([this.element, "*", {
                        blur: $.proxy(function(e) {
                            this._focused_from = e.target
                        }, this)
                    }], [this.element, {
                        blur: $.proxy(function(e) {
                            this._focused_from = e.target
                        }, this)
                    }]),
                    this.o.immediateUpdates && this._events.push([this.element, {
                        "changeYear changeMonth": $.proxy(function(e) {
                            this.update(e.date)
                        }, this)
                    }]),
                    this._secondaryEvents = [[this.picker, {
                        click: $.proxy(this.click, this)
                    }], [this.picker, ".prev, .next", {
                        click: $.proxy(this.navArrowsClick, this)
                    }], [this.picker, ".day:not(.disabled)", {
                        click: $.proxy(this.dayCellClick, this)
                    }], [$(window), {
                        resize: $.proxy(this.place, this)
                    }], [$(document), {
                        "mousedown touchstart": $.proxy(function(e) {
                            this.element.is(e.target) || this.element.find(e.target).length || this.picker.is(e.target) || this.picker.find(e.target).length || this.isInline || this.hide()
                        }, this)
                    }]]
                },
                _attachEvents: function() {
                    this._detachEvents(),
                    this._applyEvents(this._events)
                },
                _detachEvents: function() {
                    this._unapplyEvents(this._events)
                },
                _attachSecondaryEvents: function() {
                    this._detachSecondaryEvents(),
                    this._applyEvents(this._secondaryEvents)
                },
                _detachSecondaryEvents: function() {
                    this._unapplyEvents(this._secondaryEvents)
                },
                _trigger: function(event, altdate) {
                    var date = altdate || this.dates.get(-1)
                      , local_date = this._utc_to_local(date);
                    this.element.trigger({
                        type: event,
                        date: local_date,
                        viewMode: this.viewMode,
                        dates: $.map(this.dates, this._utc_to_local),
                        format: $.proxy(function(ix, format) {
                            0 === arguments.length ? (ix = this.dates.length - 1,
                            format = this.o.format) : "string" == typeof ix && (format = ix,
                            ix = this.dates.length - 1),
                            format = format || this.o.format;
                            var date = this.dates.get(ix);
                            return DPGlobal.formatDate(date, format, this.o.language)
                        }, this)
                    })
                },
                show: function() {
                    if (!(this.inputField.prop("disabled") || this.inputField.prop("readonly") && !1 === this.o.enableOnReadonly))
                        return this.isInline || this.picker.appendTo(this.o.container),
                        this.place(),
                        this.picker.show(),
                        this._attachSecondaryEvents(),
                        this._trigger("show"),
                        (window.navigator.msMaxTouchPoints || "ontouchstart"in document) && this.o.disableTouchKeyboard && $(this.element).blur(),
                        this
                },
                hide: function() {
                    return this.isInline || !this.picker.is(":visible") ? this : (this.focusDate = null,
                    this.picker.hide().detach(),
                    this._detachSecondaryEvents(),
                    this.setViewMode(this.o.startView),
                    this.o.forceParse && this.inputField.val() && this.setValue(),
                    this._trigger("hide"),
                    this)
                },
                destroy: function() {
                    return this.hide(),
                    this._detachEvents(),
                    this._detachSecondaryEvents(),
                    this.picker.remove(),
                    delete this.element.data().datepicker,
                    this.isInput || delete this.element.data().date,
                    this
                },
                paste: function(e) {
                    var dateString;
                    if (e.originalEvent.clipboardData && e.originalEvent.clipboardData.types && -1 !== $.inArray("text/plain", e.originalEvent.clipboardData.types))
                        dateString = e.originalEvent.clipboardData.getData("text/plain");
                    else {
                        if (!window.clipboardData)
                            return;
                        dateString = window.clipboardData.getData("Text")
                    }
                    this.setDate(dateString),
                    this.update(),
                    e.preventDefault()
                },
                _utc_to_local: function(utc) {
                    if (!utc)
                        return utc;
                    var local = new Date(utc.getTime() + 6e4 * utc.getTimezoneOffset());
                    return local.getTimezoneOffset() !== utc.getTimezoneOffset() && (local = new Date(utc.getTime() + 6e4 * local.getTimezoneOffset())),
                    local
                },
                _local_to_utc: function(local) {
                    return local && new Date(local.getTime() - 6e4 * local.getTimezoneOffset())
                },
                _zero_time: function(local) {
                    return local && new Date(local.getFullYear(),local.getMonth(),local.getDate())
                },
                _zero_utc_time: function(utc) {
                    return utc && UTCDate(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate())
                },
                getDates: function() {
                    return $.map(this.dates, this._utc_to_local)
                },
                getUTCDates: function() {
                    return $.map(this.dates, function(d) {
                        return new Date(d)
                    })
                },
                getDate: function() {
                    return this._utc_to_local(this.getUTCDate())
                },
                getUTCDate: function() {
                    var selected_date = this.dates.get(-1);
                    return selected_date !== undefined ? new Date(selected_date) : null
                },
                clearDates: function() {
                    this.inputField.val(""),
                    this.update(),
                    this._trigger("changeDate"),
                    this.o.autoclose && this.hide()
                },
                setDates: function() {
                    var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
                    return this.update.apply(this, args),
                    this._trigger("changeDate"),
                    this.setValue(),
                    this
                },
                setUTCDates: function() {
                    var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
                    return this.setDates.apply(this, $.map(args, this._utc_to_local)),
                    this
                },
                setDate: alias("setDates"),
                setUTCDate: alias("setUTCDates"),
                remove: alias("destroy", "Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead"),
                setValue: function() {
                    var formatted = this.getFormattedDate();
                    return this.inputField.val(formatted),
                    this
                },
                getFormattedDate: function(format) {
                    format === undefined && (format = this.o.format);
                    var lang = this.o.language;
                    return $.map(this.dates, function(d) {
                        return DPGlobal.formatDate(d, format, lang)
                    }).join(this.o.multidateSeparator)
                },
                getStartDate: function() {
                    return this.o.startDate
                },
                setStartDate: function(startDate) {
                    return this._process_options({
                        startDate: startDate
                    }),
                    this.update(),
                    this.updateNavArrows(),
                    this
                },
                getEndDate: function() {
                    return this.o.endDate
                },
                setEndDate: function(endDate) {
                    return this._process_options({
                        endDate: endDate
                    }),
                    this.update(),
                    this.updateNavArrows(),
                    this
                },
                setDaysOfWeekDisabled: function(daysOfWeekDisabled) {
                    return this._process_options({
                        daysOfWeekDisabled: daysOfWeekDisabled
                    }),
                    this.update(),
                    this
                },
                setDaysOfWeekHighlighted: function(daysOfWeekHighlighted) {
                    return this._process_options({
                        daysOfWeekHighlighted: daysOfWeekHighlighted
                    }),
                    this.update(),
                    this
                },
                setDatesDisabled: function(datesDisabled) {
                    return this._process_options({
                        datesDisabled: datesDisabled
                    }),
                    this.update(),
                    this
                },
                place: function() {
                    if (this.isInline)
                        return this;
                    var calendarWidth = this.picker.outerWidth()
                      , calendarHeight = this.picker.outerHeight()
                      , container = $(this.o.container)
                      , windowWidth = container.width()
                      , scrollTop = "body" === this.o.container ? $(document).scrollTop() : container.scrollTop()
                      , appendOffset = container.offset()
                      , parentsZindex = [0];
                    this.element.parents().each(function() {
                        var itemZIndex = $(this).css("z-index");
                        "auto" !== itemZIndex && 0 !== Number(itemZIndex) && parentsZindex.push(Number(itemZIndex))
                    });
                    var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset
                      , offset = this.component ? this.component.parent().offset() : this.element.offset()
                      , height = this.component ? this.component.outerHeight(!0) : this.element.outerHeight(!1)
                      , width = this.component ? this.component.outerWidth(!0) : this.element.outerWidth(!1)
                      , left = offset.left - appendOffset.left
                      , top = offset.top - appendOffset.top;
                    "body" !== this.o.container && (top += scrollTop),
                    this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"),
                    "auto" !== this.o.orientation.x ? (this.picker.addClass("datepicker-orient-" + this.o.orientation.x),
                    "right" === this.o.orientation.x && (left -= calendarWidth - width)) : offset.left < 0 ? (this.picker.addClass("datepicker-orient-left"),
                    left -= offset.left - 10) : left + calendarWidth > windowWidth ? (this.picker.addClass("datepicker-orient-right"),
                    left += width - calendarWidth) : this.o.rtl ? this.picker.addClass("datepicker-orient-right") : this.picker.addClass("datepicker-orient-left");
                    var yorient = this.o.orientation.y;
                    if ("auto" === yorient && (yorient = -scrollTop + top - calendarHeight < 0 ? "bottom" : "top"),
                    this.picker.addClass("datepicker-orient-" + yorient),
                    "top" === yorient ? top -= calendarHeight + parseInt(this.picker.css("padding-top")) : top += height,
                    this.o.rtl) {
                        var right = windowWidth - (left + width);
                        this.picker.css({
                            top: top,
                            right: right,
                            zIndex: zIndex
                        })
                    } else
                        this.picker.css({
                            top: top,
                            left: left,
                            zIndex: zIndex
                        });
                    return this
                },
                _allow_update: !0,
                update: function() {
                    if (!this._allow_update)
                        return this;
                    var oldDates = this.dates.copy()
                      , dates = []
                      , fromArgs = !1;
                    return arguments.length ? ($.each(arguments, $.proxy(function(i, date) {
                        date instanceof Date && (date = this._local_to_utc(date)),
                        dates.push(date)
                    }, this)),
                    fromArgs = !0) : (dates = this.isInput ? this.element.val() : this.element.data("date") || this.inputField.val(),
                    dates = dates && this.o.multidate ? dates.split(this.o.multidateSeparator) : [dates],
                    delete this.element.data().date),
                    dates = $.map(dates, $.proxy(function(date) {
                        return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear)
                    }, this)),
                    dates = $.grep(dates, $.proxy(function(date) {
                        return !this.dateWithinRange(date) || !date
                    }, this), !0),
                    this.dates.replace(dates),
                    this.o.updateViewDate && (this.dates.length ? this.viewDate = new Date(this.dates.get(-1)) : this.viewDate < this.o.startDate ? this.viewDate = new Date(this.o.startDate) : this.viewDate > this.o.endDate ? this.viewDate = new Date(this.o.endDate) : this.viewDate = this.o.defaultViewDate),
                    fromArgs ? (this.setValue(),
                    this.element.change()) : this.dates.length && String(oldDates) !== String(this.dates) && fromArgs && (this._trigger("changeDate"),
                    this.element.change()),
                    !this.dates.length && oldDates.length && (this._trigger("clearDate"),
                    this.element.change()),
                    this.fill(),
                    this
                },
                fillDow: function() {
                    if (this.o.showWeekDays) {
                        var dowCnt = this.o.weekStart
                          , html = "<tr>";
                        for (this.o.calendarWeeks && (html += '<th class="cw">&#160;</th>'); dowCnt < this.o.weekStart + 7; )
                            html += '<th class="dow',
                            -1 !== $.inArray(dowCnt, this.o.daysOfWeekDisabled) && (html += " disabled"),
                            html += '">' + dates[this.o.language].daysMin[dowCnt++ % 7] + "</th>";
                        html += "</tr>",
                        this.picker.find(".datepicker-days thead").append(html)
                    }
                },
                fillMonths: function() {
                    for (var localDate = this._utc_to_local(this.viewDate), html = "", i = 0; i < 12; i++)
                        html += '<span class="month' + (localDate && localDate.getMonth() === i ? " focused" : "") + '">' + dates[this.o.language].monthsShort[i] + "</span>";
                    this.picker.find(".datepicker-months td").html(html)
                },
                setRange: function(range) {
                    range && range.length ? this.range = $.map(range, function(d) {
                        return d.valueOf()
                    }) : delete this.range,
                    this.fill()
                },
                getClassNames: function(date) {
                    var cls = []
                      , year = this.viewDate.getUTCFullYear()
                      , month = this.viewDate.getUTCMonth()
                      , today = UTCToday();
                    return date.getUTCFullYear() < year || date.getUTCFullYear() === year && date.getUTCMonth() < month ? cls.push("old") : (date.getUTCFullYear() > year || date.getUTCFullYear() === year && date.getUTCMonth() > month) && cls.push("new"),
                    this.focusDate && date.valueOf() === this.focusDate.valueOf() && cls.push("focused"),
                    this.o.todayHighlight && isUTCEquals(date, today) && cls.push("today"),
                    -1 !== this.dates.contains(date) && cls.push("active"),
                    this.dateWithinRange(date) || cls.push("disabled"),
                    this.dateIsDisabled(date) && cls.push("disabled", "disabled-date"),
                    -1 !== $.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) && cls.push("highlighted"),
                    this.range && (date > this.range[0] && date < this.range[this.range.length - 1] && cls.push("range"),
                    -1 !== $.inArray(date.valueOf(), this.range) && cls.push("selected"),
                    date.valueOf() === this.range[0] && cls.push("range-start"),
                    date.valueOf() === this.range[this.range.length - 1] && cls.push("range-end")),
                    cls
                },
                _fill_yearsView: function(selector, cssClass, factor, year, startYear, endYear, beforeFn) {
                    for (var classes, tooltip, before, html = "", step = factor / 10, view = this.picker.find(selector), startVal = Math.floor(year / factor) * factor, endVal = startVal + 9 * step, focusedVal = Math.floor(this.viewDate.getFullYear() / step) * step, selected = $.map(this.dates, function(d) {
                        return Math.floor(d.getUTCFullYear() / step) * step
                    }), currVal = startVal - step; currVal <= endVal + step; currVal += step)
                        classes = [cssClass],
                        tooltip = null,
                        currVal === startVal - step ? classes.push("old") : currVal === endVal + step && classes.push("new"),
                        -1 !== $.inArray(currVal, selected) && classes.push("active"),
                        (currVal < startYear || currVal > endYear) && classes.push("disabled"),
                        currVal === focusedVal && classes.push("focused"),
                        beforeFn !== $.noop && ((before = beforeFn(new Date(currVal,0,1))) === undefined ? before = {} : "boolean" == typeof before ? before = {
                            enabled: before
                        } : "string" == typeof before && (before = {
                            classes: before
                        }),
                        !1 === before.enabled && classes.push("disabled"),
                        before.classes && (classes = classes.concat(before.classes.split(/\s+/))),
                        before.tooltip && (tooltip = before.tooltip)),
                        html += '<span class="' + classes.join(" ") + '"' + (tooltip ? ' title="' + tooltip + '"' : "") + ">" + currVal + "</span>";
                    view.find(".datepicker-switch").text(startVal + "-" + endVal),
                    view.find("td").html(html)
                },
                fill: function() {
                    var tooltip, before, d = new Date(this.viewDate), year = d.getUTCFullYear(), month = d.getUTCMonth(), startYear = this.o.startDate !== -1 / 0 ? this.o.startDate.getUTCFullYear() : -1 / 0, startMonth = this.o.startDate !== -1 / 0 ? this.o.startDate.getUTCMonth() : -1 / 0, endYear = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCFullYear() : 1 / 0, endMonth = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCMonth() : 1 / 0, todaytxt = dates[this.o.language].today || dates.en.today || "", cleartxt = dates[this.o.language].clear || dates.en.clear || "", titleFormat = dates[this.o.language].titleFormat || dates.en.titleFormat;
                    if (!isNaN(year) && !isNaN(month)) {
                        this.picker.find(".datepicker-days .datepicker-switch").text(DPGlobal.formatDate(d, titleFormat, this.o.language)),
                        this.picker.find("tfoot .today").text(todaytxt).css("display", !0 === this.o.todayBtn || "linked" === this.o.todayBtn ? "table-cell" : "none"),
                        this.picker.find("tfoot .clear").text(cleartxt).css("display", !0 === this.o.clearBtn ? "table-cell" : "none"),
                        this.picker.find("thead .datepicker-title").text(this.o.title).css("display", "string" == typeof this.o.title && "" !== this.o.title ? "table-cell" : "none"),
                        this.updateNavArrows(),
                        this.fillMonths();
                        var prevMonth = UTCDate(year, month, 0)
                          , day = prevMonth.getUTCDate();
                        prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);
                        var nextMonth = new Date(prevMonth);
                        prevMonth.getUTCFullYear() < 100 && nextMonth.setUTCFullYear(prevMonth.getUTCFullYear()),
                        nextMonth.setUTCDate(nextMonth.getUTCDate() + 42),
                        nextMonth = nextMonth.valueOf();
                        for (var weekDay, clsName, html = []; prevMonth.valueOf() < nextMonth; ) {
                            if ((weekDay = prevMonth.getUTCDay()) === this.o.weekStart && (html.push("<tr>"),
                            this.o.calendarWeeks)) {
                                var ws = new Date(+prevMonth + (this.o.weekStart - weekDay - 7) % 7 * 864e5)
                                  , th = new Date(Number(ws) + (11 - ws.getUTCDay()) % 7 * 864e5)
                                  , yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (11 - yth.getUTCDay()) % 7 * 864e5)
                                  , calWeek = (th - yth) / 864e5 / 7 + 1;
                                html.push('<td class="cw">' + calWeek + "</td>")
                            }
                            (clsName = this.getClassNames(prevMonth)).push("day");
                            var content = prevMonth.getUTCDate();
                            this.o.beforeShowDay !== $.noop && ((before = this.o.beforeShowDay(this._utc_to_local(prevMonth))) === undefined ? before = {} : "boolean" == typeof before ? before = {
                                enabled: before
                            } : "string" == typeof before && (before = {
                                classes: before
                            }),
                            !1 === before.enabled && clsName.push("disabled"),
                            before.classes && (clsName = clsName.concat(before.classes.split(/\s+/))),
                            before.tooltip && (tooltip = before.tooltip),
                            before.content && (content = before.content)),
                            clsName = $.isFunction($.uniqueSort) ? $.uniqueSort(clsName) : $.unique(clsName),
                            html.push('<td class="' + clsName.join(" ") + '"' + (tooltip ? ' title="' + tooltip + '"' : "") + ' data-date="' + prevMonth.getTime().toString() + '">' + content + "</td>"),
                            tooltip = null,
                            weekDay === this.o.weekEnd && html.push("</tr>"),
                            prevMonth.setUTCDate(prevMonth.getUTCDate() + 1)
                        }
                        this.picker.find(".datepicker-days tbody").html(html.join(""));
                        var monthsTitle = dates[this.o.language].monthsTitle || dates.en.monthsTitle || "Months"
                          , months = this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode < 2 ? monthsTitle : year).end().find("tbody span").removeClass("active");
                        if ($.each(this.dates, function(i, d) {
                            d.getUTCFullYear() === year && months.eq(d.getUTCMonth()).addClass("active")
                        }),
                        (year < startYear || year > endYear) && months.addClass("disabled"),
                        year === startYear && months.slice(0, startMonth).addClass("disabled"),
                        year === endYear && months.slice(endMonth + 1).addClass("disabled"),
                        this.o.beforeShowMonth !== $.noop) {
                            var that = this;
                            $.each(months, function(i, month) {
                                var moDate = new Date(year,i,1)
                                  , before = that.o.beforeShowMonth(moDate);
                                before === undefined ? before = {} : "boolean" == typeof before ? before = {
                                    enabled: before
                                } : "string" == typeof before && (before = {
                                    classes: before
                                }),
                                !1 !== before.enabled || $(month).hasClass("disabled") || $(month).addClass("disabled"),
                                before.classes && $(month).addClass(before.classes),
                                before.tooltip && $(month).prop("title", before.tooltip)
                            })
                        }
                        this._fill_yearsView(".datepicker-years", "year", 10, year, startYear, endYear, this.o.beforeShowYear),
                        this._fill_yearsView(".datepicker-decades", "decade", 100, year, startYear, endYear, this.o.beforeShowDecade),
                        this._fill_yearsView(".datepicker-centuries", "century", 1e3, year, startYear, endYear, this.o.beforeShowCentury)
                    }
                },
                updateNavArrows: function() {
                    if (this._allow_update) {
                        var prevIsDisabled, nextIsDisabled, d = new Date(this.viewDate), year = d.getUTCFullYear(), month = d.getUTCMonth(), startYear = this.o.startDate !== -1 / 0 ? this.o.startDate.getUTCFullYear() : -1 / 0, startMonth = this.o.startDate !== -1 / 0 ? this.o.startDate.getUTCMonth() : -1 / 0, endYear = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCFullYear() : 1 / 0, endMonth = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCMonth() : 1 / 0, factor = 1;
                        switch (this.viewMode) {
                        case 4:
                            factor *= 10;
                        case 3:
                            factor *= 10;
                        case 2:
                            factor *= 10;
                        case 1:
                            prevIsDisabled = Math.floor(year / factor) * factor < startYear,
                            nextIsDisabled = Math.floor(year / factor) * factor + factor > endYear;
                            break;
                        case 0:
                            prevIsDisabled = year <= startYear && month < startMonth,
                            nextIsDisabled = year >= endYear && month > endMonth
                        }
                        this.picker.find(".prev").toggleClass("disabled", prevIsDisabled),
                        this.picker.find(".next").toggleClass("disabled", nextIsDisabled)
                    }
                },
                click: function(e) {
                    e.preventDefault(),
                    e.stopPropagation();
                    var target, day, year, month;
                    (target = $(e.target)).hasClass("datepicker-switch") && this.viewMode !== this.o.maxViewMode && this.setViewMode(this.viewMode + 1),
                    target.hasClass("today") && !target.hasClass("day") && (this.setViewMode(0),
                    this._setDate(UTCToday(), "linked" === this.o.todayBtn ? null : "view")),
                    target.hasClass("clear") && this.clearDates(),
                    target.hasClass("disabled") || (target.hasClass("month") || target.hasClass("year") || target.hasClass("decade") || target.hasClass("century")) && (this.viewDate.setUTCDate(1),
                    day = 1,
                    1 === this.viewMode ? (month = target.parent().find("span").index(target),
                    year = this.viewDate.getUTCFullYear(),
                    this.viewDate.setUTCMonth(month)) : (month = 0,
                    year = Number(target.text()),
                    this.viewDate.setUTCFullYear(year)),
                    this._trigger(DPGlobal.viewModes[this.viewMode - 1].e, this.viewDate),
                    this.viewMode === this.o.minViewMode ? this._setDate(UTCDate(year, month, day)) : (this.setViewMode(this.viewMode - 1),
                    this.fill())),
                    this.picker.is(":visible") && this._focused_from && this._focused_from.focus(),
                    delete this._focused_from
                },
                dayCellClick: function(e) {
                    var timestamp = $(e.currentTarget).data("date")
                      , date = new Date(timestamp);
                    this.o.updateViewDate && (date.getUTCFullYear() !== this.viewDate.getUTCFullYear() && this._trigger("changeYear", this.viewDate),
                    date.getUTCMonth() !== this.viewDate.getUTCMonth() && this._trigger("changeMonth", this.viewDate)),
                    this._setDate(date)
                },
                navArrowsClick: function(e) {
                    var dir = $(e.currentTarget).hasClass("prev") ? -1 : 1;
                    0 !== this.viewMode && (dir *= 12 * DPGlobal.viewModes[this.viewMode].navStep),
                    this.viewDate = this.moveMonth(this.viewDate, dir),
                    this._trigger(DPGlobal.viewModes[this.viewMode].e, this.viewDate),
                    this.fill()
                },
                _toggle_multidate: function(date) {
                    var ix = this.dates.contains(date);
                    if (date || this.dates.clear(),
                    -1 !== ix ? (!0 === this.o.multidate || this.o.multidate > 1 || this.o.toggleActive) && this.dates.remove(ix) : !1 === this.o.multidate ? (this.dates.clear(),
                    this.dates.push(date)) : this.dates.push(date),
                    "number" == typeof this.o.multidate)
                        for (; this.dates.length > this.o.multidate; )
                            this.dates.remove(0)
                },
                _setDate: function(date, which) {
                    which && "date" !== which || this._toggle_multidate(date && new Date(date)),
                    (!which && this.o.updateViewDate || "view" === which) && (this.viewDate = date && new Date(date)),
                    this.fill(),
                    this.setValue(),
                    which && "view" === which || this._trigger("changeDate"),
                    this.inputField.trigger("change"),
                    !this.o.autoclose || which && "date" !== which || this.hide()
                },
                moveDay: function(date, dir) {
                    var newDate = new Date(date);
                    return newDate.setUTCDate(date.getUTCDate() + dir),
                    newDate
                },
                moveWeek: function(date, dir) {
                    return this.moveDay(date, 7 * dir)
                },
                moveMonth: function(date, dir) {
                    if (!isValidDate(date))
                        return this.o.defaultViewDate;
                    if (!dir)
                        return date;
                    var new_month, test, new_date = new Date(date.valueOf()), day = new_date.getUTCDate(), month = new_date.getUTCMonth(), mag = Math.abs(dir);
                    if (dir = dir > 0 ? 1 : -1,
                    1 === mag)
                        test = -1 === dir ? function() {
                            return new_date.getUTCMonth() === month
                        }
                        : function() {
                            return new_date.getUTCMonth() !== new_month
                        }
                        ,
                        new_month = month + dir,
                        new_date.setUTCMonth(new_month),
                        new_month = (new_month + 12) % 12;
                    else {
                        for (var i = 0; i < mag; i++)
                            new_date = this.moveMonth(new_date, dir);
                        new_month = new_date.getUTCMonth(),
                        new_date.setUTCDate(day),
                        test = function() {
                            return new_month !== new_date.getUTCMonth()
                        }
                    }
                    for (; test(); )
                        new_date.setUTCDate(--day),
                        new_date.setUTCMonth(new_month);
                    return new_date
                },
                moveYear: function(date, dir) {
                    return this.moveMonth(date, 12 * dir)
                },
                moveAvailableDate: function(date, dir, fn) {
                    do {
                        if (date = this[fn](date, dir),
                        !this.dateWithinRange(date))
                            return !1;
                        fn = "moveDay"
                    } while (this.dateIsDisabled(date));return date
                },
                weekOfDateIsDisabled: function(date) {
                    return -1 !== $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled)
                },
                dateIsDisabled: function(date) {
                    return this.weekOfDateIsDisabled(date) || $.grep(this.o.datesDisabled, function(d) {
                        return isUTCEquals(date, d)
                    }).length > 0
                },
                dateWithinRange: function(date) {
                    return date >= this.o.startDate && date <= this.o.endDate
                },
                keydown: function(e) {
                    if (this.picker.is(":visible")) {
                        var dir, newViewDate, dateChanged = !1, focusDate = this.focusDate || this.viewDate;
                        switch (e.keyCode) {
                        case 27:
                            this.focusDate ? (this.focusDate = null,
                            this.viewDate = this.dates.get(-1) || this.viewDate,
                            this.fill()) : this.hide(),
                            e.preventDefault(),
                            e.stopPropagation();
                            break;
                        case 37:
                        case 38:
                        case 39:
                        case 40:
                            if (!this.o.keyboardNavigation || 7 === this.o.daysOfWeekDisabled.length)
                                break;
                            dir = 37 === e.keyCode || 38 === e.keyCode ? -1 : 1,
                            0 === this.viewMode ? e.ctrlKey ? (newViewDate = this.moveAvailableDate(focusDate, dir, "moveYear")) && this._trigger("changeYear", this.viewDate) : e.shiftKey ? (newViewDate = this.moveAvailableDate(focusDate, dir, "moveMonth")) && this._trigger("changeMonth", this.viewDate) : 37 === e.keyCode || 39 === e.keyCode ? newViewDate = this.moveAvailableDate(focusDate, dir, "moveDay") : this.weekOfDateIsDisabled(focusDate) || (newViewDate = this.moveAvailableDate(focusDate, dir, "moveWeek")) : 1 === this.viewMode ? (38 !== e.keyCode && 40 !== e.keyCode || (dir *= 4),
                            newViewDate = this.moveAvailableDate(focusDate, dir, "moveMonth")) : 2 === this.viewMode && (38 !== e.keyCode && 40 !== e.keyCode || (dir *= 4),
                            newViewDate = this.moveAvailableDate(focusDate, dir, "moveYear")),
                            newViewDate && (this.focusDate = this.viewDate = newViewDate,
                            this.setValue(),
                            this.fill(),
                            e.preventDefault());
                            break;
                        case 13:
                            if (!this.o.forceParse)
                                break;
                            focusDate = this.focusDate || this.dates.get(-1) || this.viewDate,
                            this.o.keyboardNavigation && (this._toggle_multidate(focusDate),
                            dateChanged = !0),
                            this.focusDate = null,
                            this.viewDate = this.dates.get(-1) || this.viewDate,
                            this.setValue(),
                            this.fill(),
                            this.picker.is(":visible") && (e.preventDefault(),
                            e.stopPropagation(),
                            this.o.autoclose && this.hide());
                            break;
                        case 9:
                            this.focusDate = null,
                            this.viewDate = this.dates.get(-1) || this.viewDate,
                            this.fill(),
                            this.hide()
                        }
                        dateChanged && (this.dates.length ? this._trigger("changeDate") : this._trigger("clearDate"),
                        this.inputField.trigger("change"))
                    } else
                        40 !== e.keyCode && 27 !== e.keyCode || (this.show(),
                        e.stopPropagation())
                },
                setViewMode: function(viewMode) {
                    this.viewMode = viewMode,
                    this.picker.children("div").hide().filter(".datepicker-" + DPGlobal.viewModes[this.viewMode].clsName).show(),
                    this.updateNavArrows(),
                    this._trigger("changeViewMode", new Date(this.viewDate))
                }
            };
            var DateRangePicker = function(element, options) {
                $.data(element, "datepicker", this),
                this.element = $(element),
                this.inputs = $.map(options.inputs, function(i) {
                    return i.jquery ? i[0] : i
                }),
                delete options.inputs,
                this.keepEmptyValues = options.keepEmptyValues,
                delete options.keepEmptyValues,
                datepickerPlugin.call($(this.inputs), options).on("changeDate", $.proxy(this.dateUpdated, this)),
                this.pickers = $.map(this.inputs, function(i) {
                    return $.data(i, "datepicker")
                }),
                this.updateDates()
            };
            DateRangePicker.prototype = {
                updateDates: function() {
                    this.dates = $.map(this.pickers, function(i) {
                        return i.getUTCDate()
                    }),
                    this.updateRanges()
                },
                updateRanges: function() {
                    var range = $.map(this.dates, function(d) {
                        return d.valueOf()
                    });
                    $.each(this.pickers, function(i, p) {
                        p.setRange(range)
                    })
                },
                clearDates: function() {
                    $.each(this.pickers, function(i, p) {
                        p.clearDates()
                    })
                },
                dateUpdated: function(e) {
                    if (!this.updating) {
                        this.updating = !0;
                        var dp = $.data(e.target, "datepicker");
                        if (dp !== undefined) {
                            var new_date = dp.getUTCDate()
                              , keep_empty_values = this.keepEmptyValues
                              , i = $.inArray(e.target, this.inputs)
                              , j = i - 1
                              , k = i + 1
                              , l = this.inputs.length;
                            if (-1 !== i) {
                                if ($.each(this.pickers, function(i, p) {
                                    p.getUTCDate() || p !== dp && keep_empty_values || p.setUTCDate(new_date)
                                }),
                                new_date < this.dates[j])
                                    for (; j >= 0 && new_date < this.dates[j]; )
                                        this.pickers[j--].setUTCDate(new_date);
                                else if (new_date > this.dates[k])
                                    for (; k < l && new_date > this.dates[k]; )
                                        this.pickers[k++].setUTCDate(new_date);
                                this.updateDates(),
                                delete this.updating
                            }
                        }
                    }
                },
                destroy: function() {
                    $.map(this.pickers, function(p) {
                        p.destroy()
                    }),
                    $(this.inputs).off("changeDate", this.dateUpdated),
                    delete this.element.data().datepicker
                },
                remove: alias("destroy", "Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead")
            };
            var old = $.fn.datepicker
              , datepickerPlugin = function(option) {
                var args = Array.apply(null, arguments);
                args.shift();
                var internal_return;
                if (this.each(function() {
                    var $this = $(this)
                      , data = $this.data("datepicker")
                      , options = "object" == typeof option && option;
                    if (!data) {
                        var elopts = opts_from_el(this, "date")
                          , locopts = opts_from_locale($.extend({}, defaults, elopts, options).language)
                          , opts = $.extend({}, defaults, locopts, elopts, options);
                        $this.hasClass("input-daterange") || opts.inputs ? ($.extend(opts, {
                            inputs: opts.inputs || $this.find("input").toArray()
                        }),
                        data = new DateRangePicker(this,opts)) : data = new Datepicker(this,opts),
                        $this.data("datepicker", data)
                    }
                    "string" == typeof option && "function" == typeof data[option] && (internal_return = data[option].apply(data, args))
                }),
                internal_return === undefined || internal_return instanceof Datepicker || internal_return instanceof DateRangePicker)
                    return this;
                if (this.length > 1)
                    throw new Error("Using only allowed for the collection of a single element (" + option + " function)");
                return internal_return
            };
            $.fn.datepicker = datepickerPlugin;
            var defaults = $.fn.datepicker.defaults = {
                assumeNearbyYear: !1,
                autoclose: !1,
                beforeShowDay: $.noop,
                beforeShowMonth: $.noop,
                beforeShowYear: $.noop,
                beforeShowDecade: $.noop,
                beforeShowCentury: $.noop,
                calendarWeeks: !1,
                clearBtn: !1,
                toggleActive: !1,
                daysOfWeekDisabled: [],
                daysOfWeekHighlighted: [],
                datesDisabled: [],
                endDate: 1 / 0,
                forceParse: !0,
                format: "mm/dd/yyyy",
                keepEmptyValues: !1,
                keyboardNavigation: !0,
                language: "en",
                minViewMode: 0,
                maxViewMode: 4,
                multidate: !1,
                multidateSeparator: ",",
                orientation: "auto",
                rtl: !1,
                startDate: -1 / 0,
                startView: 0,
                todayBtn: !1,
                todayHighlight: !1,
                updateViewDate: !0,
                weekStart: 0,
                disableTouchKeyboard: !1,
                enableOnReadonly: !0,
                showOnFocus: !0,
                zIndexOffset: 10,
                container: "body",
                immediateUpdates: !1,
                title: "",
                templates: {
                    leftArrow: "&#x00AB;",
                    rightArrow: "&#x00BB;"
                },
                showWeekDays: !0
            }
              , locale_opts = $.fn.datepicker.locale_opts = ["format", "rtl", "weekStart"];
            $.fn.datepicker.Constructor = Datepicker;
            var dates = $.fn.datepicker.dates = {
                en: {
                    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    today: "Today",
                    clear: "Clear",
                    titleFormat: "MM yyyy"
                }
            }
              , DPGlobal = {
                viewModes: [{
                    names: ["days", "month"],
                    clsName: "days",
                    e: "changeMonth"
                }, {
                    names: ["months", "year"],
                    clsName: "months",
                    e: "changeYear",
                    navStep: 1
                }, {
                    names: ["years", "decade"],
                    clsName: "years",
                    e: "changeDecade",
                    navStep: 10
                }, {
                    names: ["decades", "century"],
                    clsName: "decades",
                    e: "changeCentury",
                    navStep: 100
                }, {
                    names: ["centuries", "millennium"],
                    clsName: "centuries",
                    e: "changeMillennium",
                    navStep: 1e3
                }],
                validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
                nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
                parseFormat: function(format) {
                    if ("function" == typeof format.toValue && "function" == typeof format.toDisplay)
                        return format;
                    var separators = format.replace(this.validParts, "\0").split("\0")
                      , parts = format.match(this.validParts);
                    if (!separators || !separators.length || !parts || 0 === parts.length)
                        throw new Error("Invalid date format.");
                    return {
                        separators: separators,
                        parts: parts
                    }
                },
                parseDate: function(date, format, language, assumeNearby) {
                    function applyNearbyYear(year, threshold) {
                        return !0 === threshold && (threshold = 10),
                        year < 100 && (year += 2e3) > (new Date).getFullYear() + threshold && (year -= 100),
                        year
                    }
                    function match_part() {
                        var m = this.slice(0, parts[i].length)
                          , p = parts[i].slice(0, m.length);
                        return m.toLowerCase() === p.toLowerCase()
                    }
                    if (!date)
                        return undefined;
                    if (date instanceof Date)
                        return date;
                    if ("string" == typeof format && (format = DPGlobal.parseFormat(format)),
                    format.toValue)
                        return format.toValue(date, format, language);
                    var parts, part, dir, i, fn, fn_map = {
                        d: "moveDay",
                        m: "moveMonth",
                        w: "moveWeek",
                        y: "moveYear"
                    }, dateAliases = {
                        yesterday: "-1d",
                        today: "+0d",
                        tomorrow: "+1d"
                    };
                    if (date in dateAliases && (date = dateAliases[date]),
                    /^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(date)) {
                        for (parts = date.match(/([\-+]\d+)([dmwy])/gi),
                        date = new Date,
                        i = 0; i < parts.length; i++)
                            part = parts[i].match(/([\-+]\d+)([dmwy])/i),
                            dir = Number(part[1]),
                            fn = fn_map[part[2].toLowerCase()],
                            date = Datepicker.prototype[fn](date, dir);
                        return Datepicker.prototype._zero_utc_time(date)
                    }
                    parts = date && date.match(this.nonpunctuation) || [];
                    var val, filtered, parsed = {}, setters_order = ["yyyy", "yy", "M", "MM", "m", "mm", "d", "dd"], setters_map = {
                        yyyy: function(d, v) {
                            return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v)
                        },
                        m: function(d, v) {
                            if (isNaN(d))
                                return d;
                            for (v -= 1; v < 0; )
                                v += 12;
                            for (v %= 12,
                            d.setUTCMonth(v); d.getUTCMonth() !== v; )
                                d.setUTCDate(d.getUTCDate() - 1);
                            return d
                        },
                        d: function(d, v) {
                            return d.setUTCDate(v)
                        }
                    };
                    setters_map.yy = setters_map.yyyy,
                    setters_map.M = setters_map.MM = setters_map.mm = setters_map.m,
                    setters_map.dd = setters_map.d,
                    date = UTCToday();
                    var fparts = format.parts.slice();
                    if (parts.length !== fparts.length && (fparts = $(fparts).filter(function(i, p) {
                        return -1 !== $.inArray(p, setters_order)
                    }).toArray()),
                    parts.length === fparts.length) {
                        var cnt;
                        for (i = 0,
                        cnt = fparts.length; i < cnt; i++) {
                            if (val = parseInt(parts[i], 10),
                            part = fparts[i],
                            isNaN(val))
                                switch (part) {
                                case "MM":
                                    filtered = $(dates[language].months).filter(match_part),
                                    val = $.inArray(filtered[0], dates[language].months) + 1;
                                    break;
                                case "M":
                                    filtered = $(dates[language].monthsShort).filter(match_part),
                                    val = $.inArray(filtered[0], dates[language].monthsShort) + 1
                                }
                            parsed[part] = val
                        }
                        var _date, s;
                        for (i = 0; i < setters_order.length; i++)
                            (s = setters_order[i])in parsed && !isNaN(parsed[s]) && (_date = new Date(date),
                            setters_map[s](_date, parsed[s]),
                            isNaN(_date) || (date = _date))
                    }
                    return date
                },
                formatDate: function(date, format, language) {
                    if (!date)
                        return "";
                    if ("string" == typeof format && (format = DPGlobal.parseFormat(format)),
                    format.toDisplay)
                        return format.toDisplay(date, format, language);
                    var val = {
                        d: date.getUTCDate(),
                        D: dates[language].daysShort[date.getUTCDay()],
                        DD: dates[language].days[date.getUTCDay()],
                        m: date.getUTCMonth() + 1,
                        M: dates[language].monthsShort[date.getUTCMonth()],
                        MM: dates[language].months[date.getUTCMonth()],
                        yy: date.getUTCFullYear().toString().substring(2),
                        yyyy: date.getUTCFullYear()
                    };
                    val.dd = (val.d < 10 ? "0" : "") + val.d,
                    val.mm = (val.m < 10 ? "0" : "") + val.m,
                    date = [];
                    for (var seps = $.extend([], format.separators), i = 0, cnt = format.parts.length; i <= cnt; i++)
                        seps.length && date.push(seps.shift()),
                        date.push(val[format.parts[i]]);
                    return date.join("")
                },
                headTemplate: '<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">' + defaults.templates.leftArrow + '</th><th colspan="5" class="datepicker-switch"></th><th class="next">' + defaults.templates.rightArrow + "</th></tr></thead>",
                contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
                footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
            };
            DPGlobal.template = '<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">' + DPGlobal.headTemplate + "<tbody></tbody>" + DPGlobal.footTemplate + '</table></div><div class="datepicker-months"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-years"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-decades"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-centuries"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + "</table></div></div>",
            $.fn.datepicker.DPGlobal = DPGlobal,
            $.fn.datepicker.noConflict = function() {
                return $.fn.datepicker = old,
                this
            }
            ,
            $.fn.datepicker.version = "1.8.0",
            $.fn.datepicker.deprecated = function(msg) {
                var console = window.console;
                console && console.warn && console.warn("DEPRECATED: " + msg)
            }
            ,
            $(document).on("focus.datepicker.data-api click.datepicker.data-api", '[data-provide="datepicker"]', function(e) {
                var $this = $(this);
                $this.data("datepicker") || (e.preventDefault(),
                datepickerPlugin.call($this, "show"))
            }),
            $(function() {
                datepickerPlugin.call($('[data-provide="datepicker-inline"]'))
            })
        })
    }
    , {
        jquery: 10
    }],
    3: [function(require, module, exports) {
        function MarkerClusterer(map, opt_markers, opt_options) {
            this.extend(MarkerClusterer, google.maps.OverlayView),
            this.map_ = map,
            this.markers_ = [],
            this.clusters_ = [],
            this.markersCluster_ = {},
            this.markersUniqueID = 1,
            this.sizes = [53, 56, 66, 78, 90],
            this.styles_ = [],
            this.cssClass_ = "",
            this.cssDefaultClass_ = "cluster",
            this.setIndex_ = 0,
            this.ready_ = !1;
            var options = opt_options || {};
            this.gridSize_ = void 0 !== options.gridSize ? options.gridSize : 60,
            this.minClusterSize_ = options.minimumClusterSize || 2,
            this.ignoreHiddenMarkers_ = options.ignoreHiddenMarkers || !1,
            this.maxZoom_ = options.maxZoom || null,
            this.styles_ = options.styles || [],
            this.cssClass_ = options.cssClass || null,
            this.imagePath_ = options.imagePath || this.MARKER_CLUSTER_IMAGE_PATH_,
            this.imageExtension_ = options.imageExtension || this.MARKER_CLUSTER_IMAGE_EXTENSION_,
            this.zoomOnClick_ = !0,
            void 0 != options.zoomOnClick && (this.zoomOnClick_ = options.zoomOnClick),
            this.averageCenter_ = !1,
            void 0 != options.averageCenter && (this.averageCenter_ = options.averageCenter),
            this.onMouseoverCluster_ = options.onMouseoverCluster,
            this.onMouseoutCluster_ = options.onMouseoutCluster,
            this.drawCluster_ = options.drawCluster,
            this.hideCluster_ = options.hideCluster,
            this.showCluster_ = options.showCluster,
            this.onAddCluster_ = options.onAddCluster,
            this.onRemoveCluster_ = options.onRemoveCluster,
            this.setupStyles_(),
            this.setMap(map),
            this.prevZoom_ = this.map_.getZoom();
            var that = this;
            google.maps.event.addListener(this.map_, "zoom_changed", function() {
                var zoom = that.map_.getZoom();
                that.prevZoom_ != zoom && (that.prevZoom_ = zoom,
                that.resetViewport())
            }),
            google.maps.event.addListener(this.map_, "idle", function() {
                that.redraw()
            }),
            opt_markers && opt_markers.length && this.addMarkers(opt_markers, !1)
        }
        function Cluster(markerClusterer) {
            this.markerClusterer_ = markerClusterer,
            this.map_ = markerClusterer.getMap(),
            this.gridSize_ = markerClusterer.getGridSize(),
            this.minClusterSize_ = markerClusterer.getMinClusterSize(),
            this.averageCenter_ = markerClusterer.isAverageCenter(),
            this.center_ = null,
            this.markers_ = [],
            this.bounds_ = null,
            this.clusterIcon_ = new ClusterIcon(this,markerClusterer.getStyles(),markerClusterer.getGridSize())
        }
        function ClusterIcon(cluster, styles, opt_padding) {
            cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView),
            this.styles_ = styles,
            this.padding_ = opt_padding || 0,
            this.cluster_ = cluster,
            this.center_ = null,
            this.map_ = cluster.getMap(),
            this.div_ = null,
            this.sums_ = null,
            this.visible_ = !1,
            this.setMap(this.map_)
        }
        function defaultClusterOnAdd(clusterIcon) {
            if (clusterIcon.div_ = document.createElement("DIV"),
            clusterIcon.visible_) {
                var pos = clusterIcon.getPosFromLatLng_(clusterIcon.center_);
                clusterIcon.div_.style.cssText = clusterIcon.createCss(pos),
                clusterIcon.div_.innerHTML = clusterIcon.sums_.text,
                clusterIcon.addClass()
            }
            clusterIcon.getPanes().overlayMouseTarget.appendChild(clusterIcon.div_);
            var isDragging = !1
              , isMouseDown = !1;
            google.maps.event.addDomListener(clusterIcon.div_, "click", function(event) {
                isDragging || clusterIcon.triggerClusterClick(event)
            }),
            google.maps.event.addDomListener(clusterIcon.div_, "mousedown", function() {
                isDragging = !1,
                isMouseDown = !0
            }),
            google.maps.event.addDomListener(clusterIcon.div_, "mouseup", function() {
                isDragging = !1,
                isMouseDown = !1
            }),
            google.maps.event.addDomListener(clusterIcon.div_, "mousemove", function() {
                isMouseDown && (isDragging = !0)
            }),
            google.maps.event.addDomListener(clusterIcon.div_, "mouseover", function(event) {
                clusterIcon.triggerClusterMouseover(event)
            }),
            google.maps.event.addDomListener(clusterIcon.div_, "mouseout", function(event) {
                clusterIcon.triggerClusterMouseout(event)
            })
        }
        function defaultClusterDraw(clusterIcon) {
            if (clusterIcon.visible_) {
                var pos = clusterIcon.getPosFromLatLng_(clusterIcon.center_);
                clusterIcon.div_.style.top = pos.y + "px",
                clusterIcon.div_.style.left = pos.x + "px"
            }
        }
        function defaultClusterHide(clusterIcon) {
            clusterIcon.div_ && (clusterIcon.div_.style.display = "none",
            clusterIcon.div_.className = ""),
            clusterIcon.visible_ = !1
        }
        function defaultClusterShow(clusterIcon) {
            if (clusterIcon.div_) {
                var pos = clusterIcon.getPosFromLatLng_(clusterIcon.center_);
                clusterIcon.div_.style.cssText = clusterIcon.createCss(pos),
                clusterIcon.div_.style.display = "",
                clusterIcon.addClass()
            }
            clusterIcon.visible_ = !0
        }
        function defaultClusterOnRemove(clusterIcon) {
            clusterIcon.div_ && clusterIcon.div_.parentNode && (clusterIcon.hide(),
            clusterIcon.div_.parentNode.removeChild(clusterIcon.div_),
            clusterIcon.div_ = null)
        }
        MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_PATH_ = "https://raw.githubusercontent.com/gmaps-marker-clusterer/gmaps-marker-clusterer/master/images/m",
        MarkerClusterer.prototype.MARKER_CLUSTER_IMAGE_EXTENSION_ = "png",
        MarkerClusterer.prototype.extend = function(obj1, obj2) {
            return function(object) {
                for (var property in object.prototype)
                    this.prototype[property] = object.prototype[property];
                return this
            }
            .apply(obj1, [obj2])
        }
        ,
        MarkerClusterer.prototype.onAdd = function() {
            this.setReady_(!0)
        }
        ,
        MarkerClusterer.prototype.draw = function() {}
        ,
        MarkerClusterer.prototype.setupStyles_ = function() {
            if (!this.styles_.length)
                for (var size, i = 0; size = this.sizes[i]; i++) {
                    var url = "";
                    url = "function" == typeof this.imagePath_ ? this.imagePath_(i, size) : this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                    this.styles_.push({
                        url: url,
                        height: size,
                        width: size
                    })
                }
        }
        ,
        MarkerClusterer.prototype.fitMapToMarkers = function() {
            for (var marker, markers = this.getMarkers(), bounds = new google.maps.LatLngBounds, i = 0; marker = markers[i]; i++)
                bounds.extend(marker.getPosition());
            this.map_.fitBounds(bounds)
        }
        ,
        MarkerClusterer.prototype.setStyles = function(styles) {
            this.styles_ = styles
        }
        ,
        MarkerClusterer.prototype.getStyles = function() {
            return this.styles_
        }
        ,
        MarkerClusterer.prototype.isZoomOnClick = function() {
            return this.zoomOnClick_
        }
        ,
        MarkerClusterer.prototype.isAverageCenter = function() {
            return this.averageCenter_
        }
        ,
        MarkerClusterer.prototype.getMarkers = function() {
            return this.markers_
        }
        ,
        MarkerClusterer.prototype.getTotalMarkers = function() {
            return this.markers_.length
        }
        ,
        MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
            this.maxZoom_ = maxZoom
        }
        ,
        MarkerClusterer.prototype.getMaxZoom = function() {
            return this.maxZoom_
        }
        ,
        MarkerClusterer.prototype.getMarkersCluster = function(marker) {
            return this.clusters_[this.markersCluster_[marker.uniqueID]]
        }
        ,
        MarkerClusterer.prototype.calculator_ = function(markers, numStyles) {
            for (var index = 0, count = markers.length, dv = count; 0 !== dv; )
                dv = parseInt(dv / 10, 10),
                index++;
            return index = Math.min(index, numStyles),
            {
                text: count,
                index: index
            }
        }
        ,
        MarkerClusterer.prototype.setCalculator = function(calculator) {
            this.calculator_ = calculator
        }
        ,
        MarkerClusterer.prototype.getCalculator = function() {
            return this.calculator_
        }
        ,
        MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
            for (var marker, i = 0; marker = markers[i]; i++)
                this.pushMarkerTo_(marker);
            opt_nodraw || this.redraw()
        }
        ,
        MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
            if (marker.isAdded = !1,
            marker.draggable) {
                var that = this;
                google.maps.event.addListener(marker, "dragend", function() {
                    marker.isAdded = !1,
                    that.repaint()
                })
            }
            marker.uniqueID = this.markersUniqueID,
            this.markersUniqueID++,
            this.markers_.push(marker)
        }
        ,
        MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
            this.pushMarkerTo_(marker),
            opt_nodraw || this.redraw()
        }
        ,
        MarkerClusterer.prototype.removeMarker_ = function(marker) {
            var index = -1;
            if (this.markers_.indexOf)
                index = this.markers_.indexOf(marker);
            else
                for (var m, i = 0; m = this.markers_[i]; i++)
                    if (m == marker) {
                        index = i;
                        break
                    }
            return -1 != index && (marker.setMap(null),
            this.markers_.splice(index, 1),
            delete this.markersCluster_[marker.uniqueID],
            !0)
        }
        ,
        MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
            var removed = this.removeMarker_(marker);
            return !(opt_nodraw || !removed) && (this.resetViewport(),
            this.redraw(),
            !0)
        }
        ,
        MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
            for (var removed = !1, i = markers.length; i >= 0; i--) {
                var marker = markers[i]
                  , r = this.removeMarker_(marker);
                removed = removed || r
            }
            if (!opt_nodraw && removed)
                return this.resetViewport(),
                this.redraw(),
                !0
        }
        ,
        MarkerClusterer.prototype.setReady_ = function(ready) {
            this.ready_ || (this.ready_ = ready,
            this.createClusters_())
        }
        ,
        MarkerClusterer.prototype.getTotalClusters = function() {
            return this.clusters_.length
        }
        ,
        MarkerClusterer.prototype.getClusters = function() {
            return this.clusters_
        }
        ,
        MarkerClusterer.prototype.getMap = function() {
            return this.map_
        }
        ,
        MarkerClusterer.prototype.setMap = function(map) {
            this.map_ = map
        }
        ,
        MarkerClusterer.prototype.getGridSize = function() {
            return this.gridSize_
        }
        ,
        MarkerClusterer.prototype.setGridSize = function(size) {
            this.gridSize_ = size
        }
        ,
        MarkerClusterer.prototype.getMinClusterSize = function() {
            return this.minClusterSize_
        }
        ,
        MarkerClusterer.prototype.setMinClusterSize = function(size) {
            this.minClusterSize_ = size
        }
        ,
        MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
            var projection = this.getProjection()
              , tr = new google.maps.LatLng(bounds.getNorthEast().lat(),bounds.getNorthEast().lng())
              , bl = new google.maps.LatLng(bounds.getSouthWest().lat(),bounds.getSouthWest().lng())
              , trPix = projection.fromLatLngToDivPixel(tr);
            trPix.x += this.gridSize_,
            trPix.y -= this.gridSize_;
            var blPix = projection.fromLatLngToDivPixel(bl);
            blPix.x -= this.gridSize_,
            blPix.y += this.gridSize_;
            var ne = projection.fromDivPixelToLatLng(trPix)
              , sw = projection.fromDivPixelToLatLng(blPix);
            return bounds.extend(ne),
            bounds.extend(sw),
            bounds
        }
        ,
        MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
            return bounds.contains(marker.getPosition())
        }
        ,
        MarkerClusterer.prototype.clearMarkers = function() {
            this.resetViewport(!0),
            this.markers_ = [],
            this.markersCluster_ = {},
            this.markersUniqueID = 1
        }
        ,
        MarkerClusterer.prototype.resetViewport = function(opt_hide) {
            for (var cluster, i = 0; cluster = this.clusters_[i]; i++)
                cluster.remove();
            for (var marker, i = 0; marker = this.markers_[i]; i++)
                marker.isAdded = !1,
                opt_hide && marker.setMap(null);
            this.clusters_ = [],
            this.markersCluster_ = {},
            this.markersUniqueID = 1
        }
        ,
        MarkerClusterer.prototype.repaint = function() {
            var oldClusters = this.clusters_.slice();
            this.clusters_.length = 0,
            this.resetViewport(),
            this.redraw(),
            window.setTimeout(function() {
                for (var cluster, i = 0; cluster = oldClusters[i]; i++)
                    cluster.remove()
            }, 0)
        }
        ,
        MarkerClusterer.prototype.redraw = function() {
            this.createClusters_()
        }
        ,
        MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
            if (!p1 || !p2)
                return 0;
            var dLat = (p2.lat() - p1.lat()) * Math.PI / 180
              , dLon = (p2.lng() - p1.lng()) * Math.PI / 180
              , a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return 6371 * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)))
        }
        ,
        MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
            for (var cluster, distance = 4e4, clusterToAddTo = null, clusterIndex = (marker.getPosition(),
            null), i = 0; cluster = this.clusters_[i]; i++) {
                var center = cluster.getCenter();
                if (center) {
                    var d = this.distanceBetweenPoints_(center, marker.getPosition());
                    d < distance && (distance = d,
                    clusterToAddTo = cluster,
                    clusterIndex = i)
                }
            }
            clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker) ? clusterToAddTo.addMarker(marker) : ((cluster = new Cluster(this)).addMarker(marker),
            this.clusters_.push(cluster),
            clusterIndex = this.clusters_.length - 1),
            marker.isAdded && (this.markersCluster_[marker.uniqueID] = clusterIndex)
        }
        ,
        MarkerClusterer.prototype.createClusters_ = function() {
            if (this.ready_)
                for (var marker, mapBounds = new google.maps.LatLngBounds(this.map_.getBounds().getSouthWest(),this.map_.getBounds().getNorthEast()), bounds = this.getExtendedBounds(mapBounds), i = 0; marker = this.markers_[i]; i++)
                    marker.isAdded || !this.isMarkerInBounds_(marker, bounds) || this.ignoreHiddenMarkers_ && !marker.getVisible() || this.addToClosestCluster_(marker)
        }
        ,
        Cluster.prototype.isMarkerAlreadyAdded = function(marker) {
            if (this.markers_.indexOf)
                return -1 != this.markers_.indexOf(marker);
            for (var m, i = 0; m = this.markers_[i]; i++)
                if (m == marker)
                    return !0;
            return !1
        }
        ,
        Cluster.prototype.addMarker = function(marker) {
            if (this.isMarkerAlreadyAdded(marker))
                return !1;
            if (this.center_) {
                if (this.averageCenter_) {
                    var l = this.markers_.length + 1
                      , lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l
                      , lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                    this.center_ = new google.maps.LatLng(lat,lng),
                    this.calculateBounds_()
                }
            } else
                this.center_ = marker.getPosition(),
                this.calculateBounds_();
            marker.isAdded = !0,
            this.markers_.push(marker);
            var len = this.markers_.length;
            if (len < this.minClusterSize_ && marker.getMap() != this.map_ && marker.setMap(this.map_),
            len == this.minClusterSize_)
                for (var i = 0; i < len; i++)
                    this.markers_[i].setMap(null);
            return len >= this.minClusterSize_ && marker.setMap(null),
            this.updateIcon(),
            !0
        }
        ,
        Cluster.prototype.getMarkerClusterer = function() {
            return this.markerClusterer_
        }
        ,
        Cluster.prototype.getBounds = function() {
            for (var marker, bounds = new google.maps.LatLngBounds(this.center_,this.center_), markers = this.getMarkers(), i = 0; marker = markers[i]; i++)
                bounds.extend(marker.getPosition());
            return bounds
        }
        ,
        Cluster.prototype.remove = function() {
            this.clusterIcon_.remove(),
            this.markers_.length = 0,
            delete this.markers_
        }
        ,
        Cluster.prototype.getSize = function() {
            return this.markers_.length
        }
        ,
        Cluster.prototype.getMarkers = function() {
            return this.markers_
        }
        ,
        Cluster.prototype.getCenter = function() {
            return this.center_
        }
        ,
        Cluster.prototype.calculateBounds_ = function() {
            var bounds = new google.maps.LatLngBounds(this.center_,this.center_);
            this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds)
        }
        ,
        Cluster.prototype.isMarkerInClusterBounds = function(marker) {
            return this.bounds_.contains(marker.getPosition())
        }
        ,
        Cluster.prototype.getMap = function() {
            return this.map_
        }
        ,
        Cluster.prototype.updateIcon = function() {
            var zoom = this.map_.getZoom()
              , mz = this.markerClusterer_.getMaxZoom();
            if (mz && zoom > mz)
                for (var marker, i = 0; marker = this.markers_[i]; i++)
                    marker.setMap(this.map_);
            else if (this.markers_.length < this.minClusterSize_)
                this.clusterIcon_.hide();
            else {
                var numStyles = this.markerClusterer_.getStyles().length
                  , sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                this.clusterIcon_.setCenter(this.center_),
                this.clusterIcon_.setSums(sums),
                this.clusterIcon_.show()
            }
        }
        ,
        ClusterIcon.prototype.triggerClusterClick = function(event) {
            var markerClusterer = this.cluster_.getMarkerClusterer();
            google.maps.event.trigger(markerClusterer, "clusterclick", this.cluster_, event),
            markerClusterer.isZoomOnClick() && this.map_.fitBounds(this.cluster_.getBounds())
        }
        ,
        ClusterIcon.prototype.triggerClusterMouseover = function(event) {
            var markerClusterer = this.cluster_.getMarkerClusterer();
            google.maps.event.trigger(markerClusterer, "clustermouseover", this.cluster_, event),
            "function" == typeof this.cluster_.markerClusterer_.onMouseoverCluster_ && this.cluster_.markerClusterer_.onMouseoverCluster_(this, event)
        }
        ,
        ClusterIcon.prototype.triggerClusterMouseout = function(event) {
            var markerClusterer = this.cluster_.getMarkerClusterer();
            google.maps.event.trigger(markerClusterer, "clustermouseout", this.cluster_, event),
            "function" == typeof this.cluster_.markerClusterer_.onMouseoutCluster_ && this.cluster_.markerClusterer_.onMouseoutCluster_(this, event)
        }
        ,
        ClusterIcon.prototype.onAdd = function() {
            "function" == typeof this.cluster_.markerClusterer_.onAddCluster_ ? this.cluster_.markerClusterer_.onAddCluster_(this) : defaultClusterOnAdd(this)
        }
        ,
        ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
            var pos = this.getProjection().fromLatLngToDivPixel(latlng);
            return "object" == typeof this.iconAnchor_ && 2 === this.iconAnchor_.length ? (pos.x -= this.iconAnchor_[0],
            pos.y -= this.iconAnchor_[1]) : (pos.x -= parseInt(this.width_ / 2, 10),
            pos.y -= parseInt(this.height_ / 2, 10)),
            pos
        }
        ,
        ClusterIcon.prototype.draw = function() {
            "function" == typeof this.cluster_.markerClusterer_.drawCluster_ ? this.cluster_.markerClusterer_.drawCluster_(this) : defaultClusterDraw(this)
        }
        ,
        ClusterIcon.prototype.hide = function() {
            "function" == typeof this.cluster_.markerClusterer_.hideCluster_ ? this.cluster_.markerClusterer_.hideCluster_(this) : defaultClusterHide(this)
        }
        ,
        ClusterIcon.prototype.show = function() {
            "function" == typeof this.cluster_.markerClusterer_.showCluster_ ? this.cluster_.markerClusterer_.showCluster_(this) : defaultClusterShow(this)
        }
        ,
        ClusterIcon.prototype.remove = function() {
            this.setMap(null)
        }
        ,
        ClusterIcon.prototype.onRemove = function() {
            "function" == typeof this.cluster_.markerClusterer_.onRemoveCluster_ ? this.cluster_.markerClusterer_.onRemoveCluster_(this) : defaultClusterOnRemove(this)
        }
        ,
        ClusterIcon.prototype.setSums = function(sums) {
            this.sums_ = sums,
            this.text_ = sums.text,
            this.index_ = sums.index,
            this.div_ && (this.div_.innerHTML = sums.text),
            this.useStyle()
        }
        ,
        ClusterIcon.prototype.useStyle = function() {
            var index = Math.max(0, this.sums_.index - 1);
            index = Math.min(this.styles_.length - 1, index);
            var style = this.styles_[index];
            this.url_ = style.url,
            this.height_ = style.height,
            this.width_ = style.width,
            this.textColor_ = style.textColor,
            this.anchor_ = style.anchor,
            this.textSize_ = style.textSize,
            this.backgroundPosition_ = style.backgroundPosition,
            this.iconAnchor_ = style.iconAnchor,
            this.setIndex_ = index
        }
        ,
        ClusterIcon.prototype.setCenter = function(center) {
            this.center_ = center
        }
        ,
        ClusterIcon.prototype.createCss = function(pos) {
            var style = [];
            if (this.cluster_.getMarkerClusterer().cssClass_)
                style.push("top:" + pos.y + "px; left:" + pos.x + "px;");
            else {
                style.push("background-image:url(" + this.url_ + ");");
                var backgroundPosition = this.backgroundPosition_ ? this.backgroundPosition_ : "0 0";
                style.push("background-position:" + backgroundPosition + ";"),
                "object" == typeof this.anchor_ ? ("number" == typeof this.anchor_[0] && this.anchor_[0] > 0 && this.anchor_[0] < this.height_ ? style.push("height:" + (this.height_ - this.anchor_[0]) + "px; padding-top:" + this.anchor_[0] + "px;") : "number" == typeof this.anchor_[0] && this.anchor_[0] < 0 && -this.anchor_[0] < this.height_ ? style.push("height:" + this.height_ + "px; line-height:" + (this.height_ + this.anchor_[0]) + "px;") : style.push("height:" + this.height_ + "px; line-height:" + this.height_ + "px;"),
                "number" == typeof this.anchor_[1] && this.anchor_[1] > 0 && this.anchor_[1] < this.width_ ? style.push("width:" + (this.width_ - this.anchor_[1]) + "px; padding-left:" + this.anchor_[1] + "px;") : style.push("width:" + this.width_ + "px; text-align:center;")) : style.push("height:" + this.height_ + "px; line-height:" + this.height_ + "px; width:" + this.width_ + "px; text-align:center;");
                var txtColor = this.textColor_ ? this.textColor_ : "black"
                  , txtSize = this.textSize_ ? this.textSize_ : 11;
                style.push("cursor:pointer; top:" + pos.y + "px; left:" + pos.x + "px; color:" + txtColor + "; position:absolute; font-size:" + txtSize + "px; font-family:Arial,sans-serif; font-weight:bold")
            }
            return style.join("")
        }
        ,
        ClusterIcon.prototype.addClass = function() {
            var markerClusterer = this.cluster_.getMarkerClusterer();
            markerClusterer.cssClass_ ? this.div_.className = markerClusterer.cssClass_ + " " + markerClusterer.cssDefaultClass_ + this.setIndex_ : this.div_.className = markerClusterer.cssDefaultClass_ + this.setIndex_
        }
        ,
        window.MarkerClusterer = MarkerClusterer,
        MarkerClusterer.prototype.addMarker = MarkerClusterer.prototype.addMarker,
        MarkerClusterer.prototype.addMarkers = MarkerClusterer.prototype.addMarkers,
        MarkerClusterer.prototype.clearMarkers = MarkerClusterer.prototype.clearMarkers,
        MarkerClusterer.prototype.fitMapToMarkers = MarkerClusterer.prototype.fitMapToMarkers,
        MarkerClusterer.prototype.getCalculator = MarkerClusterer.prototype.getCalculator,
        MarkerClusterer.prototype.getGridSize = MarkerClusterer.prototype.getGridSize,
        MarkerClusterer.prototype.getExtendedBounds = MarkerClusterer.prototype.getExtendedBounds,
        MarkerClusterer.prototype.getMap = MarkerClusterer.prototype.getMap,
        MarkerClusterer.prototype.getMarkers = MarkerClusterer.prototype.getMarkers,
        MarkerClusterer.prototype.getMaxZoom = MarkerClusterer.prototype.getMaxZoom,
        MarkerClusterer.prototype.getMarkersCluster = MarkerClusterer.prototype.getMarkersCluster,
        MarkerClusterer.prototype.getStyles = MarkerClusterer.prototype.getStyles,
        MarkerClusterer.prototype.getTotalClusters = MarkerClusterer.prototype.getTotalClusters,
        MarkerClusterer.prototype.getTotalMarkers = MarkerClusterer.prototype.getTotalMarkers,
        MarkerClusterer.prototype.redraw = MarkerClusterer.prototype.redraw,
        MarkerClusterer.prototype.removeMarker = MarkerClusterer.prototype.removeMarker,
        MarkerClusterer.prototype.removeMarkers = MarkerClusterer.prototype.removeMarkers,
        MarkerClusterer.prototype.resetViewport = MarkerClusterer.prototype.resetViewport,
        MarkerClusterer.prototype.repaint = MarkerClusterer.prototype.repaint,
        MarkerClusterer.prototype.setCalculator = MarkerClusterer.prototype.setCalculator,
        MarkerClusterer.prototype.setGridSize = MarkerClusterer.prototype.setGridSize,
        MarkerClusterer.prototype.setMaxZoom = MarkerClusterer.prototype.setMaxZoom,
        MarkerClusterer.prototype.onAdd = MarkerClusterer.prototype.onAdd,
        MarkerClusterer.prototype.draw = MarkerClusterer.prototype.draw,
        Cluster.prototype.getCenter = Cluster.prototype.getCenter,
        Cluster.prototype.getSize = Cluster.prototype.getSize,
        Cluster.prototype.getMarkers = Cluster.prototype.getMarkers,
        ClusterIcon.prototype.onAdd = ClusterIcon.prototype.onAdd,
        ClusterIcon.prototype.draw = ClusterIcon.prototype.draw,
        ClusterIcon.prototype.onRemove = ClusterIcon.prototype.onRemove
    }
    , {}],
    4: [function(require, module, exports) {
        !function(e) {
            e.fn.niceSelect = function(t) {
                function s(t) {
                    t.after(e("<div></div>").addClass("nice-select").addClass(t.attr("class") || "").addClass(t.attr("disabled") ? "disabled" : "").attr("tabindex", t.attr("disabled") ? null : "0").html('<span class="current"></span><ul class="list"></ul>'));
                    var s = t.next()
                      , n = t.find("option")
                      , i = t.find("option:selected");
                    s.find(".current").html(i.data("display") || i.text()),
                    n.each(function(t) {
                        var n = e(this)
                          , i = n.data("display");
                        s.find("ul").append(e("<li></li>").attr("data-value", n.val()).attr("data-display", i || null).addClass("option" + (n.is(":selected") ? " selected" : "") + (n.is(":disabled") ? " disabled" : "")).html(n.text()))
                    })
                }
                if ("string" == typeof t)
                    return "update" == t ? this.each(function() {
                        var t = e(this)
                          , n = e(this).next(".nice-select")
                          , i = n.hasClass("open");
                        n.length && (n.remove(),
                        s(t),
                        i && t.next().trigger("click"))
                    }) : "destroy" == t ? (this.each(function() {
                        var t = e(this)
                          , s = e(this).next(".nice-select");
                        s.length && (s.remove(),
                        t.css("display", ""))
                    }),
                    0 == e(".nice-select").length && e(document).off(".nice_select")) : console.log('Method "' + t + '" does not exist.'),
                    this;
                this.hide(),
                this.each(function() {
                    var t = e(this);
                    t.next().hasClass("nice-select") || s(t)
                }),
                e(document).off(".nice_select"),
                e(document).on("click.nice_select", ".nice-select", function(t) {
                    var s = e(this);
                    e(".nice-select").not(s).removeClass("open"),
                    s.toggleClass("open"),
                    s.hasClass("open") ? (s.find(".option"),
                    s.find(".focus").removeClass("focus"),
                    s.find(".selected").addClass("focus")) : s.focus()
                }),
                e(document).on("click.nice_select", function(t) {
                    0 === e(t.target).closest(".nice-select").length && e(".nice-select").removeClass("open").find(".option")
                }),
                e(document).on("click.nice_select", ".nice-select .option:not(.disabled)", function(t) {
                    var s = e(this)
                      , n = s.closest(".nice-select");
                    n.find(".selected").removeClass("selected"),
                    s.addClass("selected");
                    var i = s.data("display") || s.text();
                    n.find(".current").text(i),
                    n.prev("select").val(s.data("value")).trigger("change")
                }),
                e(document).on("keydown.nice_select", ".nice-select", function(t) {
                    var s = e(this)
                      , n = e(s.find(".focus") || s.find(".list .option.selected"));
                    if (32 == t.keyCode || 13 == t.keyCode)
                        return s.hasClass("open") ? n.trigger("click") : s.trigger("click"),
                        !1;
                    if (40 == t.keyCode) {
                        if (s.hasClass("open")) {
                            var i = n.nextAll(".option:not(.disabled)").first();
                            i.length > 0 && (s.find(".focus").removeClass("focus"),
                            i.addClass("focus"))
                        } else
                            s.trigger("click");
                        return !1
                    }
                    if (38 == t.keyCode) {
                        if (s.hasClass("open")) {
                            var l = n.prevAll(".option:not(.disabled)").first();
                            l.length > 0 && (s.find(".focus").removeClass("focus"),
                            l.addClass("focus"))
                        } else
                            s.trigger("click");
                        return !1
                    }
                    if (27 == t.keyCode)
                        s.hasClass("open") && s.trigger("click");
                    else if (9 == t.keyCode && s.hasClass("open"))
                        return !1
                });
                var n = document.createElement("a").style;
                return n.cssText = "pointer-events:auto",
                "auto" !== n.pointerEvents && e("html").addClass("no-csspointerevents"),
                this
            }
        }(jQuery)
    }
    , {}],
    5: [function(require, module, exports) {
        !function($, undefined) {
            "use strict";
            void 0 !== $.rails && $.error("jquery-ujs has already been loaded!");
            var rails, $document = $(document);
            $.rails = rails = {
                linkClickSelector: "a[data-confirm], a[data-method], a[data-remote]:not([disabled]), a[data-disable-with], a[data-disable]",
                buttonClickSelector: "button[data-remote]:not([form]):not(form button), button[data-confirm]:not([form]):not(form button)",
                inputChangeSelector: "select[data-remote], input[data-remote], textarea[data-remote]",
                formSubmitSelector: "form",
                formInputClickSelector: "form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])",
                disableSelector: "input[data-disable-with]:enabled, button[data-disable-with]:enabled, textarea[data-disable-with]:enabled, input[data-disable]:enabled, button[data-disable]:enabled, textarea[data-disable]:enabled",
                enableSelector: "input[data-disable-with]:disabled, button[data-disable-with]:disabled, textarea[data-disable-with]:disabled, input[data-disable]:disabled, button[data-disable]:disabled, textarea[data-disable]:disabled",
                requiredInputSelector: "input[name][required]:not([disabled]), textarea[name][required]:not([disabled])",
                fileInputSelector: "input[name][type=file]:not([disabled])",
                linkDisableSelector: "a[data-disable-with], a[data-disable]",
                buttonDisableSelector: "button[data-remote][data-disable-with], button[data-remote][data-disable]",
                csrfToken: function() {
                    return $("meta[name=csrf-token]").attr("content")
                },
                csrfParam: function() {
                    return $("meta[name=csrf-param]").attr("content")
                },
                CSRFProtection: function(xhr) {
                    var token = rails.csrfToken();
                    token && xhr.setRequestHeader("X-CSRF-Token", token)
                },
                refreshCSRFTokens: function() {
                    $('form input[name="' + rails.csrfParam() + '"]').val(rails.csrfToken())
                },
                fire: function(obj, name, data) {
                    var event = $.Event(name);
                    return obj.trigger(event, data),
                    !1 !== event.result
                },
                confirm: function(message) {
                    return confirm(message)
                },
                ajax: function(options) {
                    return $.ajax(options)
                },
                href: function(element) {
                    return element[0].href
                },
                isRemote: function(element) {
                    return void 0 !== element.data("remote") && !1 !== element.data("remote")
                },
                handleRemote: function(element) {
                    var method, url, data, withCredentials, dataType, options;
                    if (rails.fire(element, "ajax:before")) {
                        if (withCredentials = element.data("with-credentials") || null,
                        dataType = element.data("type") || $.ajaxSettings && $.ajaxSettings.dataType,
                        element.is("form")) {
                            method = element.data("ujs:submit-button-formmethod") || element.attr("method"),
                            url = element.data("ujs:submit-button-formaction") || element.attr("action"),
                            data = $(element[0]).serializeArray();
                            var button = element.data("ujs:submit-button");
                            button && (data.push(button),
                            element.data("ujs:submit-button", null)),
                            element.data("ujs:submit-button-formmethod", null),
                            element.data("ujs:submit-button-formaction", null)
                        } else
                            element.is(rails.inputChangeSelector) ? (method = element.data("method"),
                            url = element.data("url"),
                            data = element.serialize(),
                            element.data("params") && (data = data + "&" + element.data("params"))) : element.is(rails.buttonClickSelector) ? (method = element.data("method") || "get",
                            url = element.data("url"),
                            data = element.serialize(),
                            element.data("params") && (data = data + "&" + element.data("params"))) : (method = element.data("method"),
                            url = rails.href(element),
                            data = element.data("params") || null);
                        return options = {
                            type: method || "GET",
                            data: data,
                            dataType: dataType,
                            beforeSend: function(xhr, settings) {
                                if (void 0 === settings.dataType && xhr.setRequestHeader("accept", "*/*;q=0.5, " + settings.accepts.script),
                                !rails.fire(element, "ajax:beforeSend", [xhr, settings]))
                                    return !1;
                                element.trigger("ajax:send", xhr)
                            },
                            success: function(data, status, xhr) {
                                element.trigger("ajax:success", [data, status, xhr])
                            },
                            complete: function(xhr, status) {
                                element.trigger("ajax:complete", [xhr, status])
                            },
                            error: function(xhr, status, error) {
                                element.trigger("ajax:error", [xhr, status, error])
                            },
                            crossDomain: rails.isCrossDomain(url)
                        },
                        withCredentials && (options.xhrFields = {
                            withCredentials: withCredentials
                        }),
                        url && (options.url = url),
                        rails.ajax(options)
                    }
                    return !1
                },
                isCrossDomain: function(url) {
                    var originAnchor = document.createElement("a");
                    originAnchor.href = location.href;
                    var urlAnchor = document.createElement("a");
                    try {
                        return urlAnchor.href = url,
                        urlAnchor.href = urlAnchor.href,
                        !((!urlAnchor.protocol || ":" === urlAnchor.protocol) && !urlAnchor.host || originAnchor.protocol + "//" + originAnchor.host == urlAnchor.protocol + "//" + urlAnchor.host)
                    } catch (e) {
                        return !0
                    }
                },
                handleMethod: function(link) {
                    var href = rails.href(link)
                      , method = link.data("method")
                      , target = link.attr("target")
                      , csrfToken = rails.csrfToken()
                      , csrfParam = rails.csrfParam()
                      , form = $('<form method="post" action="' + href + '"></form>')
                      , metadataInput = '<input name="_method" value="' + method + '" type="hidden" />';
                    void 0 === csrfParam || void 0 === csrfToken || rails.isCrossDomain(href) || (metadataInput += '<input name="' + csrfParam + '" value="' + csrfToken + '" type="hidden" />'),
                    target && form.attr("target", target),
                    form.hide().append(metadataInput).appendTo("body"),
                    form.submit()
                },
                formElements: function(form, selector) {
                    return form.is("form") ? $(form[0].elements).filter(selector) : form.find(selector)
                },
                disableFormElements: function(form) {
                    rails.formElements(form, rails.disableSelector).each(function() {
                        rails.disableFormElement($(this))
                    })
                },
                disableFormElement: function(element) {
                    var method, replacement;
                    method = element.is("button") ? "html" : "val",
                    void 0 !== (replacement = element.data("disable-with")) && (element.data("ujs:enable-with", element[method]()),
                    element[method](replacement)),
                    element.prop("disabled", !0),
                    element.data("ujs:disabled", !0)
                },
                enableFormElements: function(form) {
                    rails.formElements(form, rails.enableSelector).each(function() {
                        rails.enableFormElement($(this))
                    })
                },
                enableFormElement: function(element) {
                    var method = element.is("button") ? "html" : "val";
                    void 0 !== element.data("ujs:enable-with") && (element[method](element.data("ujs:enable-with")),
                    element.removeData("ujs:enable-with")),
                    element.prop("disabled", !1),
                    element.removeData("ujs:disabled")
                },
                allowAction: function(element) {
                    var callback, message = element.data("confirm"), answer = !1;
                    if (!message)
                        return !0;
                    if (rails.fire(element, "confirm")) {
                        try {
                            answer = rails.confirm(message)
                        } catch (e) {
                            (console.error || console.log).call(console, e.stack || e)
                        }
                        callback = rails.fire(element, "confirm:complete", [answer])
                    }
                    return answer && callback
                },
                blankInputs: function(form, specifiedSelector, nonBlank) {
                    var input, valueToCheck, radiosForNameWithNoneSelected, radioName, foundInputs = $(), selector = specifiedSelector || "input,textarea", checkedRadioButtonNames = {};
                    return form.find(selector).each(function() {
                        (input = $(this)).is("input[type=radio]") ? (radioName = input.attr("name"),
                        checkedRadioButtonNames[radioName] || (0 === form.find('input[type=radio]:checked[name="' + radioName + '"]').length && (radiosForNameWithNoneSelected = form.find('input[type=radio][name="' + radioName + '"]'),
                        foundInputs = foundInputs.add(radiosForNameWithNoneSelected)),
                        checkedRadioButtonNames[radioName] = radioName)) : (valueToCheck = input.is("input[type=checkbox],input[type=radio]") ? input.is(":checked") : !!input.val()) === nonBlank && (foundInputs = foundInputs.add(input))
                    }),
                    !!foundInputs.length && foundInputs
                },
                nonBlankInputs: function(form, specifiedSelector) {
                    return rails.blankInputs(form, specifiedSelector, !0)
                },
                stopEverything: function(e) {
                    return $(e.target).trigger("ujs:everythingStopped"),
                    e.stopImmediatePropagation(),
                    !1
                },
                disableElement: function(element) {
                    var replacement = element.data("disable-with");
                    void 0 !== replacement && (element.data("ujs:enable-with", element.html()),
                    element.html(replacement)),
                    element.bind("click.railsDisable", function(e) {
                        return rails.stopEverything(e)
                    }),
                    element.data("ujs:disabled", !0)
                },
                enableElement: function(element) {
                    void 0 !== element.data("ujs:enable-with") && (element.html(element.data("ujs:enable-with")),
                    element.removeData("ujs:enable-with")),
                    element.unbind("click.railsDisable"),
                    element.removeData("ujs:disabled")
                }
            },
            rails.fire($document, "rails:attachBindings") && ($.ajaxPrefilter(function(options, originalOptions, xhr) {
                options.crossDomain || rails.CSRFProtection(xhr)
            }),
            $(window).on("pageshow.rails", function() {
                $($.rails.enableSelector).each(function() {
                    var element = $(this);
                    element.data("ujs:disabled") && $.rails.enableFormElement(element)
                }),
                $($.rails.linkDisableSelector).each(function() {
                    var element = $(this);
                    element.data("ujs:disabled") && $.rails.enableElement(element)
                })
            }),
            $document.on("ajax:complete", rails.linkDisableSelector, function() {
                rails.enableElement($(this))
            }),
            $document.on("ajax:complete", rails.buttonDisableSelector, function() {
                rails.enableFormElement($(this))
            }),
            $document.on("click.rails", rails.linkClickSelector, function(e) {
                var link = $(this)
                  , method = link.data("method")
                  , data = link.data("params")
                  , metaClick = e.metaKey || e.ctrlKey;
                if (!rails.allowAction(link))
                    return rails.stopEverything(e);
                if (!metaClick && link.is(rails.linkDisableSelector) && rails.disableElement(link),
                rails.isRemote(link)) {
                    if (metaClick && (!method || "GET" === method) && !data)
                        return !0;
                    var handleRemote = rails.handleRemote(link);
                    return !1 === handleRemote ? rails.enableElement(link) : handleRemote.fail(function() {
                        rails.enableElement(link)
                    }),
                    !1
                }
                return method ? (rails.handleMethod(link),
                !1) : void 0
            }),
            $document.on("click.rails", rails.buttonClickSelector, function(e) {
                var button = $(this);
                if (!rails.allowAction(button) || !rails.isRemote(button))
                    return rails.stopEverything(e);
                button.is(rails.buttonDisableSelector) && rails.disableFormElement(button);
                var handleRemote = rails.handleRemote(button);
                return !1 === handleRemote ? rails.enableFormElement(button) : handleRemote.fail(function() {
                    rails.enableFormElement(button)
                }),
                !1
            }),
            $document.on("change.rails", rails.inputChangeSelector, function(e) {
                var link = $(this);
                return rails.allowAction(link) && rails.isRemote(link) ? (rails.handleRemote(link),
                !1) : rails.stopEverything(e)
            }),
            $document.on("submit.rails", rails.formSubmitSelector, function(e) {
                var blankRequiredInputs, nonBlankFileInputs, form = $(this), remote = rails.isRemote(form);
                if (!rails.allowAction(form))
                    return rails.stopEverything(e);
                if (void 0 === form.attr("novalidate"))
                    if (void 0 === form.data("ujs:formnovalidate-button")) {
                        if ((blankRequiredInputs = rails.blankInputs(form, rails.requiredInputSelector, !1)) && rails.fire(form, "ajax:aborted:required", [blankRequiredInputs]))
                            return rails.stopEverything(e)
                    } else
                        form.data("ujs:formnovalidate-button", void 0);
                if (remote) {
                    if (nonBlankFileInputs = rails.nonBlankInputs(form, rails.fileInputSelector)) {
                        setTimeout(function() {
                            rails.disableFormElements(form)
                        }, 13);
                        var aborted = rails.fire(form, "ajax:aborted:file", [nonBlankFileInputs]);
                        return aborted || setTimeout(function() {
                            rails.enableFormElements(form)
                        }, 13),
                        aborted
                    }
                    return rails.handleRemote(form),
                    !1
                }
                setTimeout(function() {
                    rails.disableFormElements(form)
                }, 13)
            }),
            $document.on("click.rails", rails.formInputClickSelector, function(event) {
                var button = $(this);
                if (!rails.allowAction(button))
                    return rails.stopEverything(event);
                var name = button.attr("name")
                  , data = name ? {
                    name: name,
                    value: button.val()
                } : null
                  , form = button.closest("form");
                0 === form.length && (form = $("#" + button.attr("form"))),
                form.data("ujs:submit-button", data),
                form.data("ujs:formnovalidate-button", button.attr("formnovalidate")),
                form.data("ujs:submit-button-formaction", button.attr("formaction")),
                form.data("ujs:submit-button-formmethod", button.attr("formmethod"))
            }),
            $document.on("ajax:send.rails", rails.formSubmitSelector, function(event) {
                this === event.target && rails.disableFormElements($(this))
            }),
            $document.on("ajax:complete.rails", rails.formSubmitSelector, function(event) {
                this === event.target && rails.enableFormElements($(this))
            }),
            $(function() {
                rails.refreshCSRFTokens()
            }))
        }(jQuery)
    }
    , {}],
    6: [function(require, module, exports) {
        !function(factory) {
            "function" == typeof define && define.amd ? define(["jquery"], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery)
        }(function($) {
            $.extend($.fn, {
                validate: function(options) {
                    if (this.length) {
                        var validator = $.data(this[0], "validator");
                        return validator || (this.attr("novalidate", "novalidate"),
                        validator = new $.validator(options,this[0]),
                        $.data(this[0], "validator", validator),
                        validator.settings.onsubmit && (this.on("click.validate", ":submit", function(event) {
                            validator.submitButton = event.currentTarget,
                            $(this).hasClass("cancel") && (validator.cancelSubmit = !0),
                            void 0 !== $(this).attr("formnovalidate") && (validator.cancelSubmit = !0)
                        }),
                        this.on("submit.validate", function(event) {
                            function handle() {
                                var hidden, result;
                                return validator.submitButton && (validator.settings.submitHandler || validator.formSubmitted) && (hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm)),
                                !validator.settings.submitHandler || (result = validator.settings.submitHandler.call(validator, validator.currentForm, event),
                                hidden && hidden.remove(),
                                void 0 !== result && result)
                            }
                            return validator.settings.debug && event.preventDefault(),
                            validator.cancelSubmit ? (validator.cancelSubmit = !1,
                            handle()) : validator.form() ? validator.pendingRequest ? (validator.formSubmitted = !0,
                            !1) : handle() : (validator.focusInvalid(),
                            !1)
                        })),
                        validator)
                    }
                    options && options.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")
                },
                valid: function() {
                    var valid, validator, errorList;
                    return $(this[0]).is("form") ? valid = this.validate().form() : (errorList = [],
                    valid = !0,
                    validator = $(this[0].form).validate(),
                    this.each(function() {
                        (valid = validator.element(this) && valid) || (errorList = errorList.concat(validator.errorList))
                    }),
                    validator.errorList = errorList),
                    valid
                },
                rules: function(command, argument) {
                    var settings, staticRules, existingRules, data, param, filtered, element = this[0];
                    if (null != element && (!element.form && element.hasAttribute("contenteditable") && (element.form = this.closest("form")[0],
                    element.name = this.attr("name")),
                    null != element.form)) {
                        if (command)
                            switch (settings = $.data(element.form, "validator").settings,
                            staticRules = settings.rules,
                            existingRules = $.validator.staticRules(element),
                            command) {
                            case "add":
                                $.extend(existingRules, $.validator.normalizeRule(argument)),
                                delete existingRules.messages,
                                staticRules[element.name] = existingRules,
                                argument.messages && (settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages));
                                break;
                            case "remove":
                                return argument ? (filtered = {},
                                $.each(argument.split(/\s/), function(index, method) {
                                    filtered[method] = existingRules[method],
                                    delete existingRules[method]
                                }),
                                filtered) : (delete staticRules[element.name],
                                existingRules)
                            }
                        return (data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element)).required && (param = data.required,
                        delete data.required,
                        data = $.extend({
                            required: param
                        }, data)),
                        data.remote && (param = data.remote,
                        delete data.remote,
                        data = $.extend(data, {
                            remote: param
                        })),
                        data
                    }
                }
            }),
            $.extend($.expr.pseudos || $.expr[":"], {
                blank: function(a) {
                    return !$.trim("" + $(a).val())
                },
                filled: function(a) {
                    var val = $(a).val();
                    return null !== val && !!$.trim("" + val)
                },
                unchecked: function(a) {
                    return !$(a).prop("checked")
                }
            }),
            $.validator = function(options, form) {
                this.settings = $.extend(!0, {}, $.validator.defaults, options),
                this.currentForm = form,
                this.init()
            }
            ,
            $.validator.format = function(source, params) {
                return 1 === arguments.length ? function() {
                    var args = $.makeArray(arguments);
                    return args.unshift(source),
                    $.validator.format.apply(this, args)
                }
                : void 0 === params ? source : (arguments.length > 2 && params.constructor !== Array && (params = $.makeArray(arguments).slice(1)),
                params.constructor !== Array && (params = [params]),
                $.each(params, function(i, n) {
                    source = source.replace(new RegExp("\\{" + i + "\\}","g"), function() {
                        return n
                    })
                }),
                source)
            }
            ,
            $.extend($.validator, {
                defaults: {
                    messages: {},
                    groups: {},
                    rules: {},
                    errorClass: "error",
                    pendingClass: "pending",
                    validClass: "valid",
                    errorElement: "label",
                    focusCleanup: !1,
                    focusInvalid: !0,
                    errorContainer: $([]),
                    errorLabelContainer: $([]),
                    onsubmit: !0,
                    ignore: ":hidden",
                    ignoreTitle: !1,
                    onfocusin: function(element) {
                        this.lastActive = element,
                        this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass),
                        this.hideThese(this.errorsFor(element)))
                    },
                    onfocusout: function(element) {
                        this.checkable(element) || !(element.name in this.submitted) && this.optional(element) || this.element(element)
                    },
                    onkeyup: function(element, event) {
                        var excludedKeys = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
                        9 === event.which && "" === this.elementValue(element) || -1 !== $.inArray(event.keyCode, excludedKeys) || (element.name in this.submitted || element.name in this.invalid) && this.element(element)
                    },
                    onclick: function(element) {
                        element.name in this.submitted ? this.element(element) : element.parentNode.name in this.submitted && this.element(element.parentNode)
                    },
                    highlight: function(element, errorClass, validClass) {
                        "radio" === element.type ? this.findByName(element.name).addClass(errorClass).removeClass(validClass) : $(element).addClass(errorClass).removeClass(validClass)
                    },
                    unhighlight: function(element, errorClass, validClass) {
                        "radio" === element.type ? this.findByName(element.name).removeClass(errorClass).addClass(validClass) : $(element).removeClass(errorClass).addClass(validClass)
                    }
                },
                setDefaults: function(settings) {
                    $.extend($.validator.defaults, settings)
                },
                messages: {
                    required: "This field is required.",
                    remote: "Please fix this field.",
                    email: "Please enter a valid email address.",
                    url: "Please enter a valid URL.",
                    date: "Please enter a valid date.",
                    dateISO: "Please enter a valid date (ISO).",
                    number: "Please enter a valid number.",
                    digits: "Please enter only digits.",
                    equalTo: "Please enter the same value again.",
                    maxlength: $.validator.format("Please enter no more than {0} characters."),
                    minlength: $.validator.format("Please enter at least {0} characters."),
                    rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
                    range: $.validator.format("Please enter a value between {0} and {1}."),
                    max: $.validator.format("Please enter a value less than or equal to {0}."),
                    min: $.validator.format("Please enter a value greater than or equal to {0}."),
                    step: $.validator.format("Please enter a multiple of {0}.")
                },
                autoCreateRanges: !1,
                prototype: {
                    init: function() {
                        function delegate(event) {
                            !this.form && this.hasAttribute("contenteditable") && (this.form = $(this).closest("form")[0],
                            this.name = $(this).attr("name"));
                            var validator = $.data(this.form, "validator")
                              , eventType = "on" + event.type.replace(/^validate/, "")
                              , settings = validator.settings;
                            settings[eventType] && !$(this).is(settings.ignore) && settings[eventType].call(validator, this, event)
                        }
                        this.labelContainer = $(this.settings.errorLabelContainer),
                        this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm),
                        this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer),
                        this.submitted = {},
                        this.valueCache = {},
                        this.pendingRequest = 0,
                        this.pending = {},
                        this.invalid = {},
                        this.reset();
                        var rules, groups = this.groups = {};
                        $.each(this.settings.groups, function(key, value) {
                            "string" == typeof value && (value = value.split(/\s/)),
                            $.each(value, function(index, name) {
                                groups[name] = key
                            })
                        }),
                        rules = this.settings.rules,
                        $.each(rules, function(key, value) {
                            rules[key] = $.validator.normalizeRule(value)
                        }),
                        $(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate).on("click.validate", "select, option, [type='radio'], [type='checkbox']", delegate),
                        this.settings.invalidHandler && $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler)
                    },
                    form: function() {
                        return this.checkForm(),
                        $.extend(this.submitted, this.errorMap),
                        this.invalid = $.extend({}, this.errorMap),
                        this.valid() || $(this.currentForm).triggerHandler("invalid-form", [this]),
                        this.showErrors(),
                        this.valid()
                    },
                    checkForm: function() {
                        this.prepareForm();
                        for (var i = 0, elements = this.currentElements = this.elements(); elements[i]; i++)
                            this.check(elements[i]);
                        return this.valid()
                    },
                    element: function(element) {
                        var rs, group, cleanElement = this.clean(element), checkElement = this.validationTargetFor(cleanElement), v = this, result = !0;
                        return void 0 === checkElement ? delete this.invalid[cleanElement.name] : (this.prepareElement(checkElement),
                        this.currentElements = $(checkElement),
                        (group = this.groups[checkElement.name]) && $.each(this.groups, function(name, testgroup) {
                            testgroup === group && name !== checkElement.name && (cleanElement = v.validationTargetFor(v.clean(v.findByName(name)))) && cleanElement.name in v.invalid && (v.currentElements.push(cleanElement),
                            result = v.check(cleanElement) && result)
                        }),
                        rs = !1 !== this.check(checkElement),
                        result = result && rs,
                        this.invalid[checkElement.name] = !rs,
                        this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)),
                        this.showErrors(),
                        $(element).attr("aria-invalid", !rs)),
                        result
                    },
                    showErrors: function(errors) {
                        if (errors) {
                            var validator = this;
                            $.extend(this.errorMap, errors),
                            this.errorList = $.map(this.errorMap, function(message, name) {
                                return {
                                    message: message,
                                    element: validator.findByName(name)[0]
                                }
                            }),
                            this.successList = $.grep(this.successList, function(element) {
                                return !(element.name in errors)
                            })
                        }
                        this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
                    },
                    resetForm: function() {
                        $.fn.resetForm && $(this.currentForm).resetForm(),
                        this.invalid = {},
                        this.submitted = {},
                        this.prepareForm(),
                        this.hideErrors();
                        var elements = this.elements().removeData("previousValue").removeAttr("aria-invalid");
                        this.resetElements(elements)
                    },
                    resetElements: function(elements) {
                        var i;
                        if (this.settings.unhighlight)
                            for (i = 0; elements[i]; i++)
                                this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, ""),
                                this.findByName(elements[i].name).removeClass(this.settings.validClass);
                        else
                            elements.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)
                    },
                    numberOfInvalids: function() {
                        return this.objectLength(this.invalid)
                    },
                    objectLength: function(obj) {
                        var i, count = 0;
                        for (i in obj)
                            void 0 !== obj[i] && null !== obj[i] && !1 !== obj[i] && count++;
                        return count
                    },
                    hideErrors: function() {
                        this.hideThese(this.toHide)
                    },
                    hideThese: function(errors) {
                        errors.not(this.containers).text(""),
                        this.addWrapper(errors).hide()
                    },
                    valid: function() {
                        return 0 === this.size()
                    },
                    size: function() {
                        return this.errorList.length
                    },
                    focusInvalid: function() {
                        if (this.settings.focusInvalid)
                            try {
                                $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin")
                            } catch (e) {}
                    },
                    findLastActive: function() {
                        var lastActive = this.lastActive;
                        return lastActive && 1 === $.grep(this.errorList, function(n) {
                            return n.element.name === lastActive.name
                        }).length && lastActive
                    },
                    elements: function() {
                        var validator = this
                          , rulesCache = {};
                        return $(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter(function() {
                            var name = this.name || $(this).attr("name");
                            return !name && validator.settings.debug && window.console && console.error("%o has no name assigned", this),
                            this.hasAttribute("contenteditable") && (this.form = $(this).closest("form")[0],
                            this.name = name),
                            !(name in rulesCache || !validator.objectLength($(this).rules())) && (rulesCache[name] = !0,
                            !0)
                        })
                    },
                    clean: function(selector) {
                        return $(selector)[0]
                    },
                    errors: function() {
                        var errorClass = this.settings.errorClass.split(" ").join(".");
                        return $(this.settings.errorElement + "." + errorClass, this.errorContext)
                    },
                    resetInternals: function() {
                        this.successList = [],
                        this.errorList = [],
                        this.errorMap = {},
                        this.toShow = $([]),
                        this.toHide = $([])
                    },
                    reset: function() {
                        this.resetInternals(),
                        this.currentElements = $([])
                    },
                    prepareForm: function() {
                        this.reset(),
                        this.toHide = this.errors().add(this.containers)
                    },
                    prepareElement: function(element) {
                        this.reset(),
                        this.toHide = this.errorsFor(element)
                    },
                    elementValue: function(element) {
                        var val, idx, $element = $(element), type = element.type;
                        return "radio" === type || "checkbox" === type ? this.findByName(element.name).filter(":checked").val() : "number" === type && void 0 !== element.validity ? element.validity.badInput ? "NaN" : $element.val() : (val = element.hasAttribute("contenteditable") ? $element.text() : $element.val(),
                        "file" === type ? "C:\\fakepath\\" === val.substr(0, 12) ? val.substr(12) : (idx = val.lastIndexOf("/")) >= 0 ? val.substr(idx + 1) : (idx = val.lastIndexOf("\\")) >= 0 ? val.substr(idx + 1) : val : "string" == typeof val ? val.replace(/\r/g, "") : val)
                    },
                    check: function(element) {
                        element = this.validationTargetFor(this.clean(element));
                        var result, method, rule, normalizer, rules = $(element).rules(), rulesCount = $.map(rules, function(n, i) {
                            return i
                        }).length, dependencyMismatch = !1, val = this.elementValue(element);
                        if ("function" == typeof rules.normalizer ? normalizer = rules.normalizer : "function" == typeof this.settings.normalizer && (normalizer = this.settings.normalizer),
                        normalizer) {
                            if ("string" != typeof (val = normalizer.call(element, val)))
                                throw new TypeError("The normalizer should return a string value.");
                            delete rules.normalizer
                        }
                        for (method in rules) {
                            rule = {
                                method: method,
                                parameters: rules[method]
                            };
                            try {
                                if ("dependency-mismatch" === (result = $.validator.methods[method].call(this, val, element, rule.parameters)) && 1 === rulesCount) {
                                    dependencyMismatch = !0;
                                    continue
                                }
                                if (dependencyMismatch = !1,
                                "pending" === result)
                                    return void (this.toHide = this.toHide.not(this.errorsFor(element)));
                                if (!result)
                                    return this.formatAndAdd(element, rule),
                                    !1
                            } catch (e) {
                                throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e),
                                e instanceof TypeError && (e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method."),
                                e
                            }
                        }
                        if (!dependencyMismatch)
                            return this.objectLength(rules) && this.successList.push(element),
                            !0
                    },
                    customDataMessage: function(element, method) {
                        return $(element).data("msg" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data("msg")
                    },
                    customMessage: function(name, method) {
                        var m = this.settings.messages[name];
                        return m && (m.constructor === String ? m : m[method])
                    },
                    findDefined: function() {
                        for (var i = 0; i < arguments.length; i++)
                            if (void 0 !== arguments[i])
                                return arguments[i]
                    },
                    defaultMessage: function(element, rule) {
                        "string" == typeof rule && (rule = {
                            method: rule
                        });
                        var message = this.findDefined(this.customMessage(element.name, rule.method), this.customDataMessage(element, rule.method), !this.settings.ignoreTitle && element.title || void 0, $.validator.messages[rule.method], "<strong>Warning: No message defined for " + element.name + "</strong>")
                          , theregex = /\$?\{(\d+)\}/g;
                        return "function" == typeof message ? message = message.call(this, rule.parameters, element) : theregex.test(message) && (message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters)),
                        message
                    },
                    formatAndAdd: function(element, rule) {
                        var message = this.defaultMessage(element, rule);
                        this.errorList.push({
                            message: message,
                            element: element,
                            method: rule.method
                        }),
                        this.errorMap[element.name] = message,
                        this.submitted[element.name] = message
                    },
                    addWrapper: function(toToggle) {
                        return this.settings.wrapper && (toToggle = toToggle.add(toToggle.parent(this.settings.wrapper))),
                        toToggle
                    },
                    defaultShowErrors: function() {
                        var i, elements, error;
                        for (i = 0; this.errorList[i]; i++)
                            error = this.errorList[i],
                            this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass),
                            this.showLabel(error.element, error.message);
                        if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)),
                        this.settings.success)
                            for (i = 0; this.successList[i]; i++)
                                this.showLabel(this.successList[i]);
                        if (this.settings.unhighlight)
                            for (i = 0,
                            elements = this.validElements(); elements[i]; i++)
                                this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                        this.toHide = this.toHide.not(this.toShow),
                        this.hideErrors(),
                        this.addWrapper(this.toShow).show()
                    },
                    validElements: function() {
                        return this.currentElements.not(this.invalidElements())
                    },
                    invalidElements: function() {
                        return $(this.errorList).map(function() {
                            return this.element
                        })
                    },
                    showLabel: function(element, message) {
                        var place, group, errorID, v, error = this.errorsFor(element), elementID = this.idOrName(element), describedBy = $(element).attr("aria-describedby");
                        error.length ? (error.removeClass(this.settings.validClass).addClass(this.settings.errorClass),
                        error.html(message)) : (place = error = $("<" + this.settings.errorElement + ">").attr("id", elementID + "-error").addClass(this.settings.errorClass).html(message || ""),
                        this.settings.wrapper && (place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()),
                        this.labelContainer.length ? this.labelContainer.append(place) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, place, $(element)) : place.insertAfter(element),
                        error.is("label") ? error.attr("for", elementID) : 0 === error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length && (errorID = error.attr("id"),
                        describedBy ? describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b")) || (describedBy += " " + errorID) : describedBy = errorID,
                        $(element).attr("aria-describedby", describedBy),
                        (group = this.groups[element.name]) && (v = this,
                        $.each(v.groups, function(name, testgroup) {
                            testgroup === group && $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm).attr("aria-describedby", error.attr("id"))
                        })))),
                        !message && this.settings.success && (error.text(""),
                        "string" == typeof this.settings.success ? error.addClass(this.settings.success) : this.settings.success(error, element)),
                        this.toShow = this.toShow.add(error)
                    },
                    errorsFor: function(element) {
                        var name = this.escapeCssMeta(this.idOrName(element))
                          , describer = $(element).attr("aria-describedby")
                          , selector = "label[for='" + name + "'], label[for='" + name + "'] *";
                        return describer && (selector = selector + ", #" + this.escapeCssMeta(describer).replace(/\s+/g, ", #")),
                        this.errors().filter(selector)
                    },
                    escapeCssMeta: function(string) {
                        return string.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1")
                    },
                    idOrName: function(element) {
                        return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name)
                    },
                    validationTargetFor: function(element) {
                        return this.checkable(element) && (element = this.findByName(element.name)),
                        $(element).not(this.settings.ignore)[0]
                    },
                    checkable: function(element) {
                        return /radio|checkbox/i.test(element.type)
                    },
                    findByName: function(name) {
                        return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']")
                    },
                    getLength: function(value, element) {
                        switch (element.nodeName.toLowerCase()) {
                        case "select":
                            return $("option:selected", element).length;
                        case "input":
                            if (this.checkable(element))
                                return this.findByName(element.name).filter(":checked").length
                        }
                        return value.length
                    },
                    depend: function(param, element) {
                        return !this.dependTypes[typeof param] || this.dependTypes[typeof param](param, element)
                    },
                    dependTypes: {
                        boolean: function(param) {
                            return param
                        },
                        string: function(param, element) {
                            return !!$(param, element.form).length
                        },
                        function: function(param, element) {
                            return param(element)
                        }
                    },
                    optional: function(element) {
                        var val = this.elementValue(element);
                        return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch"
                    },
                    startRequest: function(element) {
                        this.pending[element.name] || (this.pendingRequest++,
                        $(element).addClass(this.settings.pendingClass),
                        this.pending[element.name] = !0)
                    },
                    stopRequest: function(element, valid) {
                        --this.pendingRequest < 0 && (this.pendingRequest = 0),
                        delete this.pending[element.name],
                        $(element).removeClass(this.settings.pendingClass),
                        valid && 0 === this.pendingRequest && this.formSubmitted && this.form() ? ($(this.currentForm).submit(),
                        this.submitButton && $("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove(),
                        this.formSubmitted = !1) : !valid && 0 === this.pendingRequest && this.formSubmitted && ($(this.currentForm).triggerHandler("invalid-form", [this]),
                        this.formSubmitted = !1)
                    },
                    previousValue: function(element, method) {
                        return method = "string" == typeof method && method || "remote",
                        $.data(element, "previousValue") || $.data(element, "previousValue", {
                            old: null,
                            valid: !0,
                            message: this.defaultMessage(element, {
                                method: method
                            })
                        })
                    },
                    destroy: function() {
                        this.resetForm(),
                        $(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur")
                    }
                },
                classRuleSettings: {
                    required: {
                        required: !0
                    },
                    email: {
                        email: !0
                    },
                    url: {
                        url: !0
                    },
                    date: {
                        date: !0
                    },
                    dateISO: {
                        dateISO: !0
                    },
                    number: {
                        number: !0
                    },
                    digits: {
                        digits: !0
                    },
                    creditcard: {
                        creditcard: !0
                    }
                },
                addClassRules: function(className, rules) {
                    className.constructor === String ? this.classRuleSettings[className] = rules : $.extend(this.classRuleSettings, className)
                },
                classRules: function(element) {
                    var rules = {}
                      , classes = $(element).attr("class");
                    return classes && $.each(classes.split(" "), function() {
                        this in $.validator.classRuleSettings && $.extend(rules, $.validator.classRuleSettings[this])
                    }),
                    rules
                },
                normalizeAttributeRule: function(rules, type, method, value) {
                    /min|max|step/.test(method) && (null === type || /number|range|text/.test(type)) && (value = Number(value),
                    isNaN(value) && (value = void 0)),
                    value || 0 === value ? rules[method] = value : type === method && "range" !== type && (rules[method] = !0)
                },
                attributeRules: function(element) {
                    var method, value, rules = {}, $element = $(element), type = element.getAttribute("type");
                    for (method in $.validator.methods)
                        "required" === method ? ("" === (value = element.getAttribute(method)) && (value = !0),
                        value = !!value) : value = $element.attr(method),
                        this.normalizeAttributeRule(rules, type, method, value);
                    return rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) && delete rules.maxlength,
                    rules
                },
                dataRules: function(element) {
                    var method, value, rules = {}, $element = $(element), type = element.getAttribute("type");
                    for (method in $.validator.methods)
                        value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()),
                        this.normalizeAttributeRule(rules, type, method, value);
                    return rules
                },
                staticRules: function(element) {
                    var rules = {}
                      , validator = $.data(element.form, "validator");
                    return validator.settings.rules && (rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {}),
                    rules
                },
                normalizeRules: function(rules, element) {
                    return $.each(rules, function(prop, val) {
                        if (!1 !== val) {
                            if (val.param || val.depends) {
                                var keepRule = !0;
                                switch (typeof val.depends) {
                                case "string":
                                    keepRule = !!$(val.depends, element.form).length;
                                    break;
                                case "function":
                                    keepRule = val.depends.call(element, element)
                                }
                                keepRule ? rules[prop] = void 0 === val.param || val.param : ($.data(element.form, "validator").resetElements($(element)),
                                delete rules[prop])
                            }
                        } else
                            delete rules[prop]
                    }),
                    $.each(rules, function(rule, parameter) {
                        rules[rule] = $.isFunction(parameter) && "normalizer" !== rule ? parameter(element) : parameter
                    }),
                    $.each(["minlength", "maxlength"], function() {
                        rules[this] && (rules[this] = Number(rules[this]))
                    }),
                    $.each(["rangelength", "range"], function() {
                        var parts;
                        rules[this] && ($.isArray(rules[this]) ? rules[this] = [Number(rules[this][0]), Number(rules[this][1])] : "string" == typeof rules[this] && (parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/),
                        rules[this] = [Number(parts[0]), Number(parts[1])]))
                    }),
                    $.validator.autoCreateRanges && (null != rules.min && null != rules.max && (rules.range = [rules.min, rules.max],
                    delete rules.min,
                    delete rules.max),
                    null != rules.minlength && null != rules.maxlength && (rules.rangelength = [rules.minlength, rules.maxlength],
                    delete rules.minlength,
                    delete rules.maxlength)),
                    rules
                },
                normalizeRule: function(data) {
                    if ("string" == typeof data) {
                        var transformed = {};
                        $.each(data.split(/\s/), function() {
                            transformed[this] = !0
                        }),
                        data = transformed
                    }
                    return data
                },
                addMethod: function(name, method, message) {
                    $.validator.methods[name] = method,
                    $.validator.messages[name] = void 0 !== message ? message : $.validator.messages[name],
                    method.length < 3 && $.validator.addClassRules(name, $.validator.normalizeRule(name))
                },
                methods: {
                    required: function(value, element, param) {
                        if (!this.depend(param, element))
                            return "dependency-mismatch";
                        if ("select" === element.nodeName.toLowerCase()) {
                            var val = $(element).val();
                            return val && val.length > 0
                        }
                        return this.checkable(element) ? this.getLength(value, element) > 0 : value.length > 0
                    },
                    email: function(value, element) {
                        return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value)
                    },
                    url: function(value, element) {
                        return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(value)
                    },
                    date: function(value, element) {
                        return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString())
                    },
                    dateISO: function(value, element) {
                        return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value)
                    },
                    number: function(value, element) {
                        return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value)
                    },
                    digits: function(value, element) {
                        return this.optional(element) || /^\d+$/.test(value)
                    },
                    minlength: function(value, element, param) {
                        var length = $.isArray(value) ? value.length : this.getLength(value, element);
                        return this.optional(element) || length >= param
                    },
                    maxlength: function(value, element, param) {
                        var length = $.isArray(value) ? value.length : this.getLength(value, element);
                        return this.optional(element) || length <= param
                    },
                    rangelength: function(value, element, param) {
                        var length = $.isArray(value) ? value.length : this.getLength(value, element);
                        return this.optional(element) || length >= param[0] && length <= param[1]
                    },
                    min: function(value, element, param) {
                        return this.optional(element) || value >= param
                    },
                    max: function(value, element, param) {
                        return this.optional(element) || value <= param
                    },
                    range: function(value, element, param) {
                        return this.optional(element) || value >= param[0] && value <= param[1]
                    },
                    step: function(value, element, param) {
                        var decimals, type = $(element).attr("type"), errorMessage = "Step attribute on input type " + type + " is not supported.", supportedTypes = ["text", "number", "range"], re = new RegExp("\\b" + type + "\\b"), decimalPlaces = function(num) {
                            var match = ("" + num).match(/(?:\.(\d+))?$/);
                            return match && match[1] ? match[1].length : 0
                        }, toInt = function(num) {
                            return Math.round(num * Math.pow(10, decimals))
                        }, valid = !0;
                        if (type && !re.test(supportedTypes.join()))
                            throw new Error(errorMessage);
                        return decimals = decimalPlaces(param),
                        (decimalPlaces(value) > decimals || toInt(value) % toInt(param) != 0) && (valid = !1),
                        this.optional(element) || valid
                    },
                    equalTo: function(value, element, param) {
                        var target = $(param);
                        return this.settings.onfocusout && target.not(".validate-equalTo-blur").length && target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function() {
                            $(element).valid()
                        }),
                        value === target.val()
                    },
                    remote: function(value, element, param, method) {
                        if (this.optional(element))
                            return "dependency-mismatch";
                        method = "string" == typeof method && method || "remote";
                        var validator, data, optionDataString, previous = this.previousValue(element, method);
                        return this.settings.messages[element.name] || (this.settings.messages[element.name] = {}),
                        previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method],
                        this.settings.messages[element.name][method] = previous.message,
                        param = "string" == typeof param && {
                            url: param
                        } || param,
                        optionDataString = $.param($.extend({
                            data: value
                        }, param.data)),
                        previous.old === optionDataString ? previous.valid : (previous.old = optionDataString,
                        validator = this,
                        this.startRequest(element),
                        data = {},
                        data[element.name] = value,
                        $.ajax($.extend(!0, {
                            mode: "abort",
                            port: "validate" + element.name,
                            dataType: "json",
                            data: data,
                            context: validator.currentForm,
                            success: function(response) {
                                var errors, message, submitted, valid = !0 === response || "true" === response;
                                validator.settings.messages[element.name][method] = previous.originalMessage,
                                valid ? (submitted = validator.formSubmitted,
                                validator.resetInternals(),
                                validator.toHide = validator.errorsFor(element),
                                validator.formSubmitted = submitted,
                                validator.successList.push(element),
                                validator.invalid[element.name] = !1,
                                validator.showErrors()) : (errors = {},
                                message = response || validator.defaultMessage(element, {
                                    method: method,
                                    parameters: value
                                }),
                                errors[element.name] = previous.message = message,
                                validator.invalid[element.name] = !0,
                                validator.showErrors(errors)),
                                previous.valid = valid,
                                validator.stopRequest(element, valid)
                            }
                        }, param)),
                        "pending")
                    }
                }
            });
            var ajax, pendingRequests = {};
            return $.ajaxPrefilter ? $.ajaxPrefilter(function(settings, _, xhr) {
                var port = settings.port;
                "abort" === settings.mode && (pendingRequests[port] && pendingRequests[port].abort(),
                pendingRequests[port] = xhr)
            }) : (ajax = $.ajax,
            $.ajax = function(settings) {
                var mode = ("mode"in settings ? settings : $.ajaxSettings).mode
                  , port = ("port"in settings ? settings : $.ajaxSettings).port;
                return "abort" === mode ? (pendingRequests[port] && pendingRequests[port].abort(),
                pendingRequests[port] = ajax.apply(this, arguments),
                pendingRequests[port]) : ajax.apply(this, arguments)
            }
            ),
            $
        })
    }
    , {
        jquery: 10
    }],
    7: [function(require, module, exports) {
        !function($) {
            var defaults = {
                url: !1,
                callback: !1,
                target: !1,
                duration: 120,
                on: "mouseover",
                touch: !0,
                onZoomIn: !1,
                onZoomOut: !1,
                magnify: 1
            };
            $.zoom = function(target, source, img, magnify) {
                var targetHeight, targetWidth, sourceHeight, sourceWidth, xRatio, yRatio, offset, $target = $(target), position = $target.css("position"), $source = $(source);
                return target.style.position = /(absolute|fixed)/.test(position) ? position : "relative",
                target.style.overflow = "hidden",
                img.style.width = img.style.height = "",
                $(img).addClass("zoomImg").css({
                    position: "absolute",
                    top: 0,
                    left: 0,
                    opacity: 0,
                    width: img.width * magnify,
                    height: img.height * magnify,
                    border: "none",
                    maxWidth: "none",
                    maxHeight: "none"
                }).appendTo(target),
                {
                    init: function() {
                        targetWidth = $target.outerWidth(),
                        targetHeight = $target.outerHeight(),
                        source === target ? (sourceWidth = targetWidth,
                        sourceHeight = targetHeight) : (sourceWidth = $source.outerWidth(),
                        sourceHeight = $source.outerHeight()),
                        xRatio = (img.width - targetWidth) / sourceWidth,
                        yRatio = (img.height - targetHeight) / sourceHeight,
                        offset = $source.offset()
                    },
                    move: function(e) {
                        var left = e.pageX - offset.left
                          , top = e.pageY - offset.top;
                        top = Math.max(Math.min(top, sourceHeight), 0),
                        left = Math.max(Math.min(left, sourceWidth), 0),
                        img.style.left = left * -xRatio + "px",
                        img.style.top = top * -yRatio + "px"
                    }
                }
            }
            ,
            $.fn.zoom = function(options) {
                return this.each(function() {
                    var settings = $.extend({}, defaults, options || {})
                      , target = settings.target && $(settings.target)[0] || this
                      , source = this
                      , $source = $(source)
                      , img = document.createElement("img")
                      , $img = $(img)
                      , mousemove = "mousemove.zoom"
                      , clicked = !1
                      , touched = !1;
                    if (!settings.url) {
                        var srcElement = source.querySelector("img");
                        if (srcElement && (settings.url = srcElement.getAttribute("data-src") || srcElement.currentSrc || srcElement.src),
                        !settings.url)
                            return
                    }
                    $source.one("zoom.destroy", function(position, overflow) {
                        $source.off(".zoom"),
                        target.style.position = position,
                        target.style.overflow = overflow,
                        img.onload = null,
                        $img.remove()
                    }
                    .bind(this, target.style.position, target.style.overflow)),
                    img.onload = function() {
                        function start(e) {
                            zoom.init(),
                            zoom.move(e),
                            $img.stop().fadeTo($.support.opacity ? settings.duration : 0, 1, !!$.isFunction(settings.onZoomIn) && settings.onZoomIn.call(img))
                        }
                        function stop() {
                            $img.stop().fadeTo(settings.duration, 0, !!$.isFunction(settings.onZoomOut) && settings.onZoomOut.call(img))
                        }
                        var zoom = $.zoom(target, source, img, settings.magnify);
                        "grab" === settings.on ? $source.on("mousedown.zoom", function(e) {
                            1 === e.which && ($(document).one("mouseup.zoom", function() {
                                stop(),
                                $(document).off(mousemove, zoom.move)
                            }),
                            start(e),
                            $(document).on(mousemove, zoom.move),
                            e.preventDefault())
                        }) : "click" === settings.on ? $source.on("click.zoom", function(e) {
                            return clicked ? void 0 : (clicked = !0,
                            start(e),
                            $(document).on(mousemove, zoom.move),
                            $(document).one("click.zoom", function() {
                                stop(),
                                clicked = !1,
                                $(document).off(mousemove, zoom.move)
                            }),
                            !1)
                        }) : "toggle" === settings.on ? $source.on("click.zoom", function(e) {
                            clicked ? stop() : start(e),
                            clicked = !clicked
                        }) : "mouseover" === settings.on && (zoom.init(),
                        $source.on("mouseenter.zoom", start).on("mouseleave.zoom", stop).on(mousemove, zoom.move)),
                        settings.touch && $source.on("touchstart.zoom", function(e) {
                            e.preventDefault(),
                            touched ? (touched = !1,
                            stop()) : (touched = !0,
                            start(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]))
                        }).on("touchmove.zoom", function(e) {
                            e.preventDefault(),
                            zoom.move(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0])
                        }).on("touchend.zoom", function(e) {
                            e.preventDefault(),
                            touched && (touched = !1,
                            stop())
                        }),
                        $.isFunction(settings.callback) && settings.callback.call(img)
                    }
                    ,
                    img.setAttribute("role", "presentation"),
                    img.alt = "",
                    img.src = settings.url
                })
            }
            ,
            $.fn.zoom.defaults = defaults
        }(window.jQuery)
    }
    , {}],
    8: [function(require, module, exports) {
        (function() {
            var $, cardFromNumber, cardFromType, cards, defaultFormat, formatBackCardNumber, formatBackExpiry, formatCardNumber, formatExpiry, formatForwardExpiry, formatForwardSlashAndSpace, hasTextSelected, luhnCheck, reFormatCVC, reFormatCardNumber, reFormatExpiry, reFormatNumeric, replaceFullWidthChars, restrictCVC, restrictCardNumber, restrictExpiry, restrictNumeric, safeVal, setCardType, __slice = [].slice, __indexOf = [].indexOf || function(item) {
                for (var i = 0, l = this.length; i < l; i++)
                    if (i in this && this[i] === item)
                        return i;
                return -1
            }
            ;
            ($ = window.jQuery || window.Zepto || window.$).payment = {},
            $.payment.fn = {},
            $.fn.payment = function() {
                var args, method;
                return method = arguments[0],
                args = 2 <= arguments.length ? __slice.call(arguments, 1) : [],
                $.payment.fn[method].apply(this, args)
            }
            ,
            defaultFormat = /(\d{1,4})/g,
            $.payment.cards = cards = [{
                type: "maestro",
                patterns: [5018, 502, 503, 506, 56, 58, 639, 6220, 67],
                format: defaultFormat,
                length: [12, 13, 14, 15, 16, 17, 18, 19],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "forbrugsforeningen",
                patterns: [600],
                format: defaultFormat,
                length: [16],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "dankort",
                patterns: [5019],
                format: defaultFormat,
                length: [16],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "visa",
                patterns: [4],
                format: defaultFormat,
                length: [13, 16],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "mastercard",
                patterns: [51, 52, 53, 54, 55, 22, 23, 24, 25, 26, 27],
                format: defaultFormat,
                length: [16],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "amex",
                patterns: [34, 37],
                format: /(\d{1,4})(\d{1,6})?(\d{1,5})?/,
                length: [15],
                cvcLength: [3, 4],
                luhn: !0
            }, {
                type: "dinersclub",
                patterns: [30, 36, 38, 39],
                format: /(\d{1,4})(\d{1,6})?(\d{1,4})?/,
                length: [14],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "discover",
                patterns: [60, 64, 65, 622],
                format: defaultFormat,
                length: [16],
                cvcLength: [3],
                luhn: !0
            }, {
                type: "unionpay",
                patterns: [62, 88],
                format: defaultFormat,
                length: [16, 17, 18, 19],
                cvcLength: [3],
                luhn: !1
            }, {
                type: "jcb",
                patterns: [35],
                format: defaultFormat,
                length: [16],
                cvcLength: [3],
                luhn: !0
            }],
            cardFromNumber = function(num) {
                var card, p, pattern, _i, _j, _len, _len1, _ref;
                for (num = (num + "").replace(/\D/g, ""),
                _i = 0,
                _len = cards.length; _i < _len; _i++)
                    for (_j = 0,
                    _len1 = (_ref = (card = cards[_i]).patterns).length; _j < _len1; _j++)
                        if (pattern = _ref[_j],
                        p = pattern + "",
                        num.substr(0, p.length) === p)
                            return card
            }
            ,
            cardFromType = function(type) {
                var card, _i, _len;
                for (_i = 0,
                _len = cards.length; _i < _len; _i++)
                    if ((card = cards[_i]).type === type)
                        return card
            }
            ,
            luhnCheck = function(num) {
                var digit, digits, odd, sum, _i, _len;
                for (odd = !0,
                sum = 0,
                _i = 0,
                _len = (digits = (num + "").split("").reverse()).length; _i < _len; _i++)
                    digit = digits[_i],
                    digit = parseInt(digit, 10),
                    (odd = !odd) && (digit *= 2),
                    digit > 9 && (digit -= 9),
                    sum += digit;
                return sum % 10 == 0
            }
            ,
            hasTextSelected = function($target) {
                var _ref;
                return null != $target.prop("selectionStart") && $target.prop("selectionStart") !== $target.prop("selectionEnd") || !(null == ("undefined" != typeof document && null !== document && null != (_ref = document.selection) ? _ref.createRange : void 0) || !document.selection.createRange().text)
            }
            ,
            safeVal = function(value, $target) {
                var currPair, cursor, digit, last, prevPair;
                try {
                    cursor = $target.prop("selectionStart")
                } catch (_error) {
                    _error,
                    cursor = null
                }
                if (last = $target.val(),
                $target.val(value),
                null !== cursor && $target.is(":focus"))
                    return cursor === last.length && (cursor = value.length),
                    last !== value && (prevPair = last.slice(cursor - 1, +cursor + 1 || 9e9),
                    currPair = value.slice(cursor - 1, +cursor + 1 || 9e9),
                    digit = value[cursor],
                    /\d/.test(digit) && prevPair === digit + " " && currPair === " " + digit && (cursor += 1)),
                    $target.prop("selectionStart", cursor),
                    $target.prop("selectionEnd", cursor)
            }
            ,
            replaceFullWidthChars = function(str) {
                var chars, chr, idx, value, _i, _len;
                for (null == str && (str = ""),
                "",
                "0123456789",
                value = "",
                _i = 0,
                _len = (chars = str.split("")).length; _i < _len; _i++)
                    chr = chars[_i],
                    (idx = "".indexOf(chr)) > -1 && (chr = "0123456789"[idx]),
                    value += chr;
                return value
            }
            ,
            reFormatNumeric = function(e) {
                var $target;
                return $target = $(e.currentTarget),
                setTimeout(function() {
                    var value;
                    return value = $target.val(),
                    value = replaceFullWidthChars(value),
                    value = value.replace(/\D/g, ""),
                    safeVal(value, $target)
                })
            }
            ,
            reFormatCardNumber = function(e) {
                var $target;
                return $target = $(e.currentTarget),
                setTimeout(function() {
                    var value;
                    return value = $target.val(),
                    value = replaceFullWidthChars(value),
                    value = $.payment.formatCardNumber(value),
                    safeVal(value, $target)
                })
            }
            ,
            formatCardNumber = function(e) {
                var $target, card, digit, length, re, upperLength, value;
                if (digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit) && ($target = $(e.currentTarget),
                value = $target.val(),
                card = cardFromNumber(value + digit),
                length = (value.replace(/\D/g, "") + digit).length,
                upperLength = 16,
                card && (upperLength = card.length[card.length.length - 1]),
                !(length >= upperLength || null != $target.prop("selectionStart") && $target.prop("selectionStart") !== value.length)))
                    return (re = card && "amex" === card.type ? /^(\d{4}|\d{4}\s\d{6})$/ : /(?:^|\s)(\d{4})$/).test(value) ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val(value + " " + digit)
                    })) : re.test(value + digit) ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val(value + digit + " ")
                    })) : void 0
            }
            ,
            formatBackCardNumber = function(e) {
                var $target, value;
                if ($target = $(e.currentTarget),
                value = $target.val(),
                8 === e.which && (null == $target.prop("selectionStart") || $target.prop("selectionStart") === value.length))
                    return /\d\s$/.test(value) ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val(value.replace(/\d\s$/, ""))
                    })) : /\s\d?$/.test(value) ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val(value.replace(/\d$/, ""))
                    })) : void 0
            }
            ,
            reFormatExpiry = function(e) {
                var $target;
                return $target = $(e.currentTarget),
                setTimeout(function() {
                    var value;
                    return value = $target.val(),
                    value = replaceFullWidthChars(value),
                    value = $.payment.formatExpiry(value),
                    safeVal(value, $target)
                })
            }
            ,
            formatExpiry = function(e) {
                var $target, digit, val;
                if (digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit))
                    return $target = $(e.currentTarget),
                    val = $target.val() + digit,
                    /^\d$/.test(val) && "0" !== val && "1" !== val ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val("0" + val + " / ")
                    })) : /^\d\d$/.test(val) ? (e.preventDefault(),
                    setTimeout(function() {
                        var m1, m2;
                        return m1 = parseInt(val[0], 10),
                        (m2 = parseInt(val[1], 10)) > 2 && 0 !== m1 ? $target.val("0" + m1 + " / " + m2) : $target.val(val + " / ")
                    })) : void 0
            }
            ,
            formatForwardExpiry = function(e) {
                var $target, digit, val;
                if (digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit))
                    return $target = $(e.currentTarget),
                    val = $target.val(),
                    /^\d\d$/.test(val) ? $target.val(val + " / ") : void 0
            }
            ,
            formatForwardSlashAndSpace = function(e) {
                var $target, val, which;
                if ("/" === (which = String.fromCharCode(e.which)) || " " === which)
                    return $target = $(e.currentTarget),
                    val = $target.val(),
                    /^\d$/.test(val) && "0" !== val ? $target.val("0" + val + " / ") : void 0
            }
            ,
            formatBackExpiry = function(e) {
                var $target, value;
                if ($target = $(e.currentTarget),
                value = $target.val(),
                8 === e.which && (null == $target.prop("selectionStart") || $target.prop("selectionStart") === value.length))
                    return /\d\s\/\s$/.test(value) ? (e.preventDefault(),
                    setTimeout(function() {
                        return $target.val(value.replace(/\d\s\/\s$/, ""))
                    })) : void 0
            }
            ,
            reFormatCVC = function(e) {
                var $target;
                return $target = $(e.currentTarget),
                setTimeout(function() {
                    var value;
                    return value = $target.val(),
                    value = replaceFullWidthChars(value),
                    value = value.replace(/\D/g, "").slice(0, 4),
                    safeVal(value, $target)
                })
            }
            ,
            restrictNumeric = function(e) {
                var input;
                return !(!e.metaKey && !e.ctrlKey) || 32 !== e.which && (0 === e.which || (e.which < 33 || (input = String.fromCharCode(e.which),
                !!/[\d\s]/.test(input))))
            }
            ,
            restrictCardNumber = function(e) {
                var $target, card, digit, value;
                if ($target = $(e.currentTarget),
                digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit) && !hasTextSelected($target))
                    return value = ($target.val() + digit).replace(/\D/g, ""),
                    (card = cardFromNumber(value)) ? value.length <= card.length[card.length.length - 1] : value.length <= 16
            }
            ,
            restrictExpiry = function(e) {
                var $target, digit, value;
                if ($target = $(e.currentTarget),
                digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit) && !hasTextSelected($target))
                    return value = $target.val() + digit,
                    !((value = value.replace(/\D/g, "")).length > 6) && void 0
            }
            ,
            restrictCVC = function(e) {
                var $target, digit;
                if ($target = $(e.currentTarget),
                digit = String.fromCharCode(e.which),
                /^\d+$/.test(digit) && !hasTextSelected($target))
                    return ($target.val() + digit).length <= 4
            }
            ,
            setCardType = function(e) {
                var $target, allTypes, card, cardType, val;
                if ($target = $(e.currentTarget),
                val = $target.val(),
                cardType = $.payment.cardType(val) || "unknown",
                !$target.hasClass(cardType))
                    return allTypes = function() {
                        var _i, _len, _results;
                        for (_results = [],
                        _i = 0,
                        _len = cards.length; _i < _len; _i++)
                            card = cards[_i],
                            _results.push(card.type);
                        return _results
                    }(),
                    $target.removeClass("unknown"),
                    $target.removeClass(allTypes.join(" ")),
                    $target.addClass(cardType),
                    $target.toggleClass("identified", "unknown" !== cardType),
                    $target.trigger("payment.cardType", cardType)
            }
            ,
            $.payment.fn.formatCardCVC = function() {
                return this.on("keypress", restrictNumeric),
                this.on("keypress", restrictCVC),
                this.on("paste", reFormatCVC),
                this.on("change", reFormatCVC),
                this.on("input", reFormatCVC),
                this
            }
            ,
            $.payment.fn.formatCardExpiry = function() {
                return this.on("keypress", restrictNumeric),
                this.on("keypress", restrictExpiry),
                this.on("keypress", formatExpiry),
                this.on("keypress", formatForwardSlashAndSpace),
                this.on("keypress", formatForwardExpiry),
                this.on("keydown", formatBackExpiry),
                this.on("change", reFormatExpiry),
                this.on("input", reFormatExpiry),
                this
            }
            ,
            $.payment.fn.formatCardNumber = function() {
                return this.on("keypress", restrictNumeric),
                this.on("keypress", restrictCardNumber),
                this.on("keypress", formatCardNumber),
                this.on("keydown", formatBackCardNumber),
                this.on("keyup", setCardType),
                this.on("paste", reFormatCardNumber),
                this.on("change", reFormatCardNumber),
                this.on("input", reFormatCardNumber),
                this.on("input", setCardType),
                this
            }
            ,
            $.payment.fn.restrictNumeric = function() {
                return this.on("keypress", restrictNumeric),
                this.on("paste", reFormatNumeric),
                this.on("change", reFormatNumeric),
                this.on("input", reFormatNumeric),
                this
            }
            ,
            $.payment.fn.cardExpiryVal = function() {
                return $.payment.cardExpiryVal($(this).val())
            }
            ,
            $.payment.cardExpiryVal = function(value) {
                var month, year, _ref;
                return _ref = value.split(/[\s\/]+/, 2),
                month = _ref[0],
                2 === (null != (year = _ref[1]) ? year.length : void 0) && /^\d+$/.test(year) && (year = (new Date).getFullYear().toString().slice(0, 2) + year),
                month = parseInt(month, 10),
                year = parseInt(year, 10),
                {
                    month: month,
                    year: year
                }
            }
            ,
            $.payment.validateCardNumber = function(num) {
                var card, _ref;
                return num = (num + "").replace(/\s+|-/g, ""),
                !!/^\d+$/.test(num) && (!!(card = cardFromNumber(num)) && (_ref = num.length,
                __indexOf.call(card.length, _ref) >= 0 && (!1 === card.luhn || luhnCheck(num))))
            }
            ,
            $.payment.validateCardExpiry = function(month, year) {
                var currentTime, expiry, _ref;
                return "object" == typeof month && "month"in month && (month = (_ref = month).month,
                year = _ref.year),
                !(!month || !year) && (month = $.trim(month),
                year = $.trim(year),
                !!/^\d+$/.test(month) && (!!/^\d+$/.test(year) && (1 <= month && month <= 12 && (2 === year.length && (year = year < 70 ? "20" + year : "19" + year),
                4 === year.length && (expiry = new Date(year,month),
                currentTime = new Date,
                expiry.setMonth(expiry.getMonth() - 1),
                expiry.setMonth(expiry.getMonth() + 1, 1),
                expiry > currentTime)))))
            }
            ,
            $.payment.validateCardCVC = function(cvc, type) {
                var card, _ref;
                return cvc = $.trim(cvc),
                !!/^\d+$/.test(cvc) && (null != (card = cardFromType(type)) ? (_ref = cvc.length,
                __indexOf.call(card.cvcLength, _ref) >= 0) : cvc.length >= 3 && cvc.length <= 4)
            }
            ,
            $.payment.cardType = function(num) {
                var _ref;
                return num ? (null != (_ref = cardFromNumber(num)) ? _ref.type : void 0) || null : null
            }
            ,
            $.payment.formatCardNumber = function(num) {
                var card, groups, upperLength, _ref;
                return num = num.replace(/\D/g, ""),
                (card = cardFromNumber(num)) ? (upperLength = card.length[card.length.length - 1],
                num = num.slice(0, upperLength),
                card.format.global ? null != (_ref = num.match(card.format)) ? _ref.join(" ") : void 0 : null != (groups = card.format.exec(num)) ? (groups.shift(),
                (groups = $.grep(groups, function(n) {
                    return n
                })).join(" ")) : void 0) : num
            }
            ,
            $.payment.formatExpiry = function(expiry) {
                var mon, parts, sep, year;
                return (parts = expiry.match(/^\D*(\d{1,2})(\D+)?(\d{1,4})?/)) ? (mon = parts[1] || "",
                sep = parts[2] || "",
                (year = parts[3] || "").length > 0 ? sep = " / " : " /" === sep ? (mon = mon.substring(0, 1),
                sep = "") : 2 === mon.length || sep.length > 0 ? sep = " / " : 1 === mon.length && "0" !== mon && "1" !== mon && (mon = "0" + mon,
                sep = " / "),
                mon + sep + year) : ""
            }
        }
        ).call(this)
    }
    , {}],
    9: [function(require, module, exports) {
        !function(factory) {
            "use strict";
            "function" == typeof define && define.amd ? define(["jquery"], factory) : void 0 !== module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery)
        }(function($) {
            "use strict";
            function isWin(elem) {
                return !elem.nodeName || -1 !== $.inArray(elem.nodeName.toLowerCase(), ["iframe", "#document", "html", "body"])
            }
            function both(val) {
                return $.isFunction(val) || $.isPlainObject(val) ? val : {
                    top: val,
                    left: val
                }
            }
            var $scrollTo = $.scrollTo = function(target, duration, settings) {
                return $(window).scrollTo(target, duration, settings)
            }
            ;
            return $scrollTo.defaults = {
                axis: "xy",
                duration: 0,
                limit: !0
            },
            $.fn.scrollTo = function(target, duration, settings) {
                "object" == typeof duration && (settings = duration,
                duration = 0),
                "function" == typeof settings && (settings = {
                    onAfter: settings
                }),
                "max" === target && (target = 9e9),
                settings = $.extend({}, $scrollTo.defaults, settings),
                duration = duration || settings.duration;
                var queue = settings.queue && settings.axis.length > 1;
                return queue && (duration /= 2),
                settings.offset = both(settings.offset),
                settings.over = both(settings.over),
                this.each(function() {
                    function animate(callback) {
                        var opts = $.extend({}, settings, {
                            queue: !0,
                            duration: duration,
                            complete: callback && function() {
                                callback.call(elem, targ, settings)
                            }
                        });
                        $elem.animate(attr, opts)
                    }
                    if (null !== target) {
                        var toff, win = isWin(this), elem = win ? this.contentWindow || window : this, $elem = $(elem), targ = target, attr = {};
                        switch (typeof targ) {
                        case "number":
                        case "string":
                            if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
                                targ = both(targ);
                                break
                            }
                            targ = win ? $(targ) : $(targ, elem);
                        case "object":
                            if (0 === targ.length)
                                return;
                            (targ.is || targ.style) && (toff = (targ = $(targ)).offset())
                        }
                        var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;
                        $.each(settings.axis.split(""), function(i, axis) {
                            var Pos = "x" === axis ? "Left" : "Top"
                              , pos = Pos.toLowerCase()
                              , key = "scroll" + Pos
                              , prev = $elem[key]()
                              , max = $scrollTo.max(elem, axis);
                            if (toff)
                                attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]),
                                settings.margin && (attr[key] -= parseInt(targ.css("margin" + Pos), 10) || 0,
                                attr[key] -= parseInt(targ.css("border" + Pos + "Width"), 10) || 0),
                                attr[key] += offset[pos] || 0,
                                settings.over[pos] && (attr[key] += targ["x" === axis ? "width" : "height"]() * settings.over[pos]);
                            else {
                                var val = targ[pos];
                                attr[key] = val.slice && "%" === val.slice(-1) ? parseFloat(val) / 100 * max : val
                            }
                            settings.limit && /^\d+$/.test(attr[key]) && (attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max)),
                            !i && settings.axis.length > 1 && (prev === attr[key] ? attr = {} : queue && (animate(settings.onAfterFirst),
                            attr = {}))
                        }),
                        animate(settings.onAfter)
                    }
                })
            }
            ,
            $scrollTo.max = function(elem, axis) {
                var Dim = "x" === axis ? "Width" : "Height"
                  , scroll = "scroll" + Dim;
                if (!isWin(elem))
                    return elem[scroll] - $(elem)[Dim.toLowerCase()]();
                var size = "client" + Dim
                  , doc = elem.ownerDocument || elem.document
                  , html = doc.documentElement
                  , body = doc.body;
                return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size])
            }
            ,
            $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
                get: function(t) {
                    return $(t.elem)[t.prop]()
                },
                set: function(t) {
                    var curr = this.get(t);
                    if (t.options.interrupt && t._last && t._last !== curr)
                        return $(t.elem).stop();
                    var next = Math.round(t.now);
                    curr !== next && ($(t.elem)[t.prop](next),
                    t._last = this.get(t))
                }
            },
            $scrollTo
        })
    }
    , {
        jquery: 10
    }],
    10: [function(require, module, exports) {
        !function(global, factory) {
            "use strict";
            "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
                if (!w.document)
                    throw new Error("jQuery requires a window with a document");
                return factory(w)
            }
            : factory(global)
        }("undefined" != typeof window ? window : this, function(window, noGlobal) {
            "use strict";
            function DOMEval(code, doc, node) {
                var i, script = (doc = doc || document).createElement("script");
                if (script.text = code,
                node)
                    for (i in preservedScriptAttributes)
                        node[i] && (script[i] = node[i]);
                doc.head.appendChild(script).parentNode.removeChild(script)
            }
            function toType(obj) {
                return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
            }
            function isArrayLike(obj) {
                var length = !!obj && "length"in obj && obj.length
                  , type = toType(obj);
                return !isFunction(obj) && !isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj)
            }
            function nodeName(elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
            }
            function winnow(elements, qualifier, not) {
                return isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
                    return !!qualifier.call(elem, i, elem) !== not
                }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
                    return elem === qualifier !== not
                }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
                    return indexOf.call(qualifier, elem) > -1 !== not
                }) : jQuery.filter(qualifier, elements, not)
            }
            function sibling(cur, dir) {
                for (; (cur = cur[dir]) && 1 !== cur.nodeType; )
                    ;
                return cur
            }
            function createOptions(options) {
                var object = {};
                return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                    object[flag] = !0
                }),
                object
            }
            function Identity(v) {
                return v
            }
            function Thrower(ex) {
                throw ex
            }
            function adoptValue(value, resolve, reject, noValue) {
                var method;
                try {
                    value && isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [value].slice(noValue))
                } catch (value) {
                    reject.apply(void 0, [value])
                }
            }
            function completed() {
                document.removeEventListener("DOMContentLoaded", completed),
                window.removeEventListener("load", completed),
                jQuery.ready()
            }
            function fcamelCase(all, letter) {
                return letter.toUpperCase()
            }
            function camelCase(string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
            }
            function Data() {
                this.expando = jQuery.expando + Data.uid++
            }
            function getData(data) {
                return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data)
            }
            function dataAttr(elem, key, data) {
                var name;
                if (void 0 === data && 1 === elem.nodeType)
                    if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(),
                    "string" == typeof (data = elem.getAttribute(name))) {
                        try {
                            data = getData(data)
                        } catch (e) {}
                        dataUser.set(elem, key, data)
                    } else
                        data = void 0;
                return data
            }
            function adjustCSS(elem, prop, valueParts, tween) {
                var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
                    return tween.cur()
                }
                : function() {
                    return jQuery.css(elem, prop, "")
                }
                , initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
                if (initialInUnit && initialInUnit[3] !== unit) {
                    for (initial /= 2,
                    unit = unit || initialInUnit[3],
                    initialInUnit = +initial || 1; maxIterations--; )
                        jQuery.style(elem, prop, initialInUnit + unit),
                        (1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0 && (maxIterations = 0),
                        initialInUnit /= scale;
                    initialInUnit *= 2,
                    jQuery.style(elem, prop, initialInUnit + unit),
                    valueParts = valueParts || []
                }
                return valueParts && (initialInUnit = +initialInUnit || +initial || 0,
                adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2],
                tween && (tween.unit = unit,
                tween.start = initialInUnit,
                tween.end = adjusted)),
                adjusted
            }
            function getDefaultDisplay(elem) {
                var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
                return display || (temp = doc.body.appendChild(doc.createElement(nodeName)),
                display = jQuery.css(temp, "display"),
                temp.parentNode.removeChild(temp),
                "none" === display && (display = "block"),
                defaultDisplayMap[nodeName] = display,
                display)
            }
            function showHide(elements, show) {
                for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++)
                    (elem = elements[index]).style && (display = elem.style.display,
                    show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null,
                    values[index] || (elem.style.display = "")),
                    "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none",
                    dataPriv.set(elem, "display", display)));
                for (index = 0; index < length; index++)
                    null != values[index] && (elements[index].style.display = values[index]);
                return elements
            }
            function getAll(context, tag) {
                var ret;
                return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [],
                void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([context], ret) : ret
            }
            function setGlobalEval(elems, refElements) {
                for (var i = 0, l = elems.length; i < l; i++)
                    dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
            }
            function buildFragment(elems, context, scripts, selection, ignored) {
                for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++)
                    if ((elem = elems[i]) || 0 === elem)
                        if ("object" === toType(elem))
                            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                        else if (rhtml.test(elem)) {
                            for (tmp = tmp || fragment.appendChild(context.createElement("div")),
                            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                            wrap = wrapMap[tag] || wrapMap._default,
                            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2],
                            j = wrap[0]; j--; )
                                tmp = tmp.lastChild;
                            jQuery.merge(nodes, tmp.childNodes),
                            (tmp = fragment.firstChild).textContent = ""
                        } else
                            nodes.push(context.createTextNode(elem));
                for (fragment.textContent = "",
                i = 0; elem = nodes[i++]; )
                    if (selection && jQuery.inArray(elem, selection) > -1)
                        ignored && ignored.push(elem);
                    else if (contains = jQuery.contains(elem.ownerDocument, elem),
                    tmp = getAll(fragment.appendChild(elem), "script"),
                    contains && setGlobalEval(tmp),
                    scripts)
                        for (j = 0; elem = tmp[j++]; )
                            rscriptType.test(elem.type || "") && scripts.push(elem);
                return fragment
            }
            function returnTrue() {
                return !0
            }
            function returnFalse() {
                return !1
            }
            function safeActiveElement() {
                try {
                    return document.activeElement
                } catch (err) {}
            }
            function on(elem, types, selector, data, fn, one) {
                var origFn, type;
                if ("object" == typeof types) {
                    "string" != typeof selector && (data = data || selector,
                    selector = void 0);
                    for (type in types)
                        on(elem, type, selector, data, types[type], one);
                    return elem
                }
                if (null == data && null == fn ? (fn = selector,
                data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data,
                data = void 0) : (fn = data,
                data = selector,
                selector = void 0)),
                !1 === fn)
                    fn = returnFalse;
                else if (!fn)
                    return elem;
                return 1 === one && (origFn = fn,
                (fn = function(event) {
                    return jQuery().off(event),
                    origFn.apply(this, arguments)
                }
                ).guid = origFn.guid || (origFn.guid = jQuery.guid++)),
                elem.each(function() {
                    jQuery.event.add(this, types, fn, data, selector)
                })
            }
            function manipulationTarget(elem, content) {
                return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? jQuery(elem).children("tbody")[0] || elem : elem
            }
            function disableScript(elem) {
                return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type,
                elem
            }
            function restoreScript(elem) {
                return "true/" === (elem.type || "").slice(0, 5) ? elem.type = elem.type.slice(5) : elem.removeAttribute("type"),
                elem
            }
            function cloneCopyEvent(src, dest) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
                if (1 === dest.nodeType) {
                    if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src),
                    pdataCur = dataPriv.set(dest, pdataOld),
                    events = pdataOld.events)) {
                        delete pdataCur.handle,
                        pdataCur.events = {};
                        for (type in events)
                            for (i = 0,
                            l = events[type].length; i < l; i++)
                                jQuery.event.add(dest, type, events[type][i])
                    }
                    dataUser.hasData(src) && (udataOld = dataUser.access(src),
                    udataCur = jQuery.extend({}, udataOld),
                    dataUser.set(dest, udataCur))
                }
            }
            function fixInput(src, dest) {
                var nodeName = dest.nodeName.toLowerCase();
                "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue)
            }
            function domManip(collection, args, callback, ignored) {
                args = concat.apply([], args);
                var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
                if (valueIsFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value))
                    return collection.each(function(index) {
                        var self = collection.eq(index);
                        valueIsFunction && (args[0] = value.call(this, index, self.html())),
                        domManip(self, args, callback, ignored)
                    });
                if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored),
                first = fragment.firstChild,
                1 === fragment.childNodes.length && (fragment = first),
                first || ignored)) {
                    for (hasScripts = (scripts = jQuery.map(getAll(fragment, "script"), disableScript)).length; i < l; i++)
                        node = fragment,
                        i !== iNoClone && (node = jQuery.clone(node, !0, !0),
                        hasScripts && jQuery.merge(scripts, getAll(node, "script"))),
                        callback.call(collection[i], node, i);
                    if (hasScripts)
                        for (doc = scripts[scripts.length - 1].ownerDocument,
                        jQuery.map(scripts, restoreScript),
                        i = 0; i < hasScripts; i++)
                            node = scripts[i],
                            rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src && "module" !== (node.type || "").toLowerCase() ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc, node))
                }
                return collection
            }
            function remove(elem, selector, keepData) {
                for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++)
                    keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)),
                    node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")),
                    node.parentNode.removeChild(node));
                return elem
            }
            function curCSS(elem, name, computed) {
                var width, minWidth, maxWidth, ret, style = elem.style;
                return (computed = computed || getStyles(elem)) && ("" !== (ret = computed.getPropertyValue(name) || computed[name]) || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)),
                !support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name) && (width = style.width,
                minWidth = style.minWidth,
                maxWidth = style.maxWidth,
                style.minWidth = style.maxWidth = style.width = ret,
                ret = computed.width,
                style.width = width,
                style.minWidth = minWidth,
                style.maxWidth = maxWidth)),
                void 0 !== ret ? ret + "" : ret
            }
            function addGetHookIf(conditionFn, hookFn) {
                return {
                    get: function() {
                        if (!conditionFn())
                            return (this.get = hookFn).apply(this, arguments);
                        delete this.get
                    }
                }
            }
            function vendorPropName(name) {
                if (name in emptyStyle)
                    return name;
                for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; )
                    if ((name = cssPrefixes[i] + capName)in emptyStyle)
                        return name
            }
            function finalPropName(name) {
                var ret = jQuery.cssProps[name];
                return ret || (ret = jQuery.cssProps[name] = vendorPropName(name) || name),
                ret
            }
            function setPositiveNumber(elem, value, subtract) {
                var matches = rcssNum.exec(value);
                return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
            }
            function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
                var i = "width" === dimension ? 1 : 0
                  , extra = 0
                  , delta = 0;
                if (box === (isBorderBox ? "border" : "content"))
                    return 0;
                for (; i < 4; i += 2)
                    "margin" === box && (delta += jQuery.css(elem, box + cssExpand[i], !0, styles)),
                    isBorderBox ? ("content" === box && (delta -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)),
                    "margin" !== box && (delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (delta += jQuery.css(elem, "padding" + cssExpand[i], !0, styles),
                    "padding" !== box ? delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles) : extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles));
                return !isBorderBox && computedVal >= 0 && (delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5))),
                delta
            }
            function getWidthOrHeight(elem, dimension, extra) {
                var styles = getStyles(elem)
                  , val = curCSS(elem, dimension, styles)
                  , isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles)
                  , valueIsBorderBox = isBorderBox;
                if (rnumnonpx.test(val)) {
                    if (!extra)
                        return val;
                    val = "auto"
                }
                return valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]),
                ("auto" === val || !parseFloat(val) && "inline" === jQuery.css(elem, "display", !1, styles)) && (val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)],
                valueIsBorderBox = !0),
                (val = parseFloat(val) || 0) + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px"
            }
            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem,options,prop,end,easing)
            }
            function schedule() {
                inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval),
                jQuery.fx.tick())
            }
            function createFxNow() {
                return window.setTimeout(function() {
                    fxNow = void 0
                }),
                fxNow = Date.now()
            }
            function genFx(type, includeWidth) {
                var which, i = 0, attrs = {
                    height: type
                };
                for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth)
                    attrs["margin" + (which = cssExpand[i])] = attrs["padding" + which] = type;
                return includeWidth && (attrs.opacity = attrs.width = type),
                attrs
            }
            function createTween(value, prop, animation) {
                for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++)
                    if (tween = collection[index].call(animation, prop, value))
                        return tween
            }
            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;
                for (index in props)
                    if (name = camelCase(index),
                    easing = specialEasing[name],
                    value = props[index],
                    Array.isArray(value) && (easing = value[1],
                    value = props[index] = value[0]),
                    index !== name && (props[name] = value,
                    delete props[index]),
                    (hooks = jQuery.cssHooks[name]) && "expand"in hooks) {
                        value = hooks.expand(value),
                        delete props[name];
                        for (index in value)
                            index in props || (props[index] = value[index],
                            specialEasing[index] = easing)
                    } else
                        specialEasing[name] = easing
            }
            function Animation(elem, properties, options) {
                var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
                    delete tick.elem
                }), tick = function() {
                    if (stopped)
                        return !1;
                    for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), percent = 1 - (remaining / animation.duration || 0), index = 0, length = animation.tweens.length; index < length; index++)
                        animation.tweens[index].run(percent);
                    return deferred.notifyWith(elem, [animation, percent, remaining]),
                    percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [animation, 1, 0]),
                    deferred.resolveWith(elem, [animation]),
                    !1)
                }, animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(!0, {
                        specialEasing: {},
                        easing: jQuery.easing._default
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function(prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        return animation.tweens.push(tween),
                        tween
                    },
                    stop: function(gotoEnd) {
                        var index = 0
                          , length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped)
                            return this;
                        for (stopped = !0; index < length; index++)
                            animation.tweens[index].run(1);
                        return gotoEnd ? (deferred.notifyWith(elem, [animation, 1, 0]),
                        deferred.resolveWith(elem, [animation, gotoEnd])) : deferred.rejectWith(elem, [animation, gotoEnd]),
                        this
                    }
                }), props = animation.props;
                for (propFilter(props, animation.opts.specialEasing); index < length; index++)
                    if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts))
                        return isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result)),
                        result;
                return jQuery.map(props, createTween, animation),
                isFunction(animation.opts.start) && animation.opts.start.call(elem, animation),
                animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always),
                jQuery.fx.timer(jQuery.extend(tick, {
                    elem: elem,
                    anim: animation,
                    queue: animation.opts.queue
                })),
                animation
            }
            function stripAndCollapse(value) {
                return (value.match(rnothtmlwhite) || []).join(" ")
            }
            function getClass(elem) {
                return elem.getAttribute && elem.getAttribute("class") || ""
            }
            function classesToArray(value) {
                return Array.isArray(value) ? value : "string" == typeof value ? value.match(rnothtmlwhite) || [] : []
            }
            function buildParams(prefix, obj, traditional, add) {
                var name;
                if (Array.isArray(obj))
                    jQuery.each(obj, function(i, v) {
                        traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add)
                    });
                else if (traditional || "object" !== toType(obj))
                    add(prefix, obj);
                else
                    for (name in obj)
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
            }
            function addToPrefiltersOrTransports(structure) {
                return function(dataTypeExpression, func) {
                    "string" != typeof dataTypeExpression && (func = dataTypeExpression,
                    dataTypeExpression = "*");
                    var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
                    if (isFunction(func))
                        for (; dataType = dataTypes[i++]; )
                            "+" === dataType[0] ? (dataType = dataType.slice(1) || "*",
                            (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
                }
            }
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
                function inspect(dataType) {
                    var selected;
                    return inspected[dataType] = !0,
                    jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport),
                        inspect(dataTypeOrTransport),
                        !1)
                    }),
                    selected
                }
                var inspected = {}
                  , seekingTransport = structure === transports;
                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
            }
            function ajaxExtend(target, src) {
                var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
                for (key in src)
                    void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
                return deep && jQuery.extend(!0, target, deep),
                target
            }
            function ajaxHandleResponses(s, jqXHR, responses) {
                for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; )
                    dataTypes.shift(),
                    void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
                if (ct)
                    for (type in contents)
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break
                        }
                if (dataTypes[0]in responses)
                    finalDataType = dataTypes[0];
                else {
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break
                        }
                        firstDataType || (firstDataType = type)
                    }
                    finalDataType = finalDataType || firstDataType
                }
                if (finalDataType)
                    return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType),
                    responses[finalDataType]
            }
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
                if (dataTypes[1])
                    for (conv in s.converters)
                        converters[conv.toLowerCase()] = s.converters[conv];
                for (current = dataTypes.shift(); current; )
                    if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response),
                    !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)),
                    prev = current,
                    current = dataTypes.shift())
                        if ("*" === current)
                            current = prev;
                        else if ("*" !== prev && prev !== current) {
                            if (!(conv = converters[prev + " " + current] || converters["* " + current]))
                                for (conv2 in converters)
                                    if ((tmp = conv2.split(" "))[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                                        !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0],
                                        dataTypes.unshift(tmp[1]));
                                        break
                                    }
                            if (!0 !== conv)
                                if (conv && s.throws)
                                    response = conv(response);
                                else
                                    try {
                                        response = conv(response)
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        }
                                    }
                        }
                return {
                    state: "success",
                    data: response
                }
            }
            var arr = []
              , document = window.document
              , getProto = Object.getPrototypeOf
              , slice = arr.slice
              , concat = arr.concat
              , push = arr.push
              , indexOf = arr.indexOf
              , class2type = {}
              , toString = class2type.toString
              , hasOwn = class2type.hasOwnProperty
              , fnToString = hasOwn.toString
              , ObjectFunctionString = fnToString.call(Object)
              , support = {}
              , isFunction = function(obj) {
                return "function" == typeof obj && "number" != typeof obj.nodeType
            }
              , isWindow = function(obj) {
                return null != obj && obj === obj.window
            }
              , preservedScriptAttributes = {
                type: !0,
                src: !0,
                noModule: !0
            }
              , jQuery = function(selector, context) {
                return new jQuery.fn.init(selector,context)
            }
              , rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
            jQuery.fn = jQuery.prototype = {
                jquery: "3.3.1",
                constructor: jQuery,
                length: 0,
                toArray: function() {
                    return slice.call(this)
                },
                get: function(num) {
                    return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num]
                },
                pushStack: function(elems) {
                    var ret = jQuery.merge(this.constructor(), elems);
                    return ret.prevObject = this,
                    ret
                },
                each: function(callback) {
                    return jQuery.each(this, callback)
                },
                map: function(callback) {
                    return this.pushStack(jQuery.map(this, function(elem, i) {
                        return callback.call(elem, i, elem)
                    }))
                },
                slice: function() {
                    return this.pushStack(slice.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                eq: function(i) {
                    var len = this.length
                      , j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: push,
                sort: arr.sort,
                splice: arr.splice
            },
            jQuery.extend = jQuery.fn.extend = function() {
                var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
                for ("boolean" == typeof target && (deep = target,
                target = arguments[i] || {},
                i++),
                "object" == typeof target || isFunction(target) || (target = {}),
                i === length && (target = this,
                i--); i < length; i++)
                    if (null != (options = arguments[i]))
                        for (name in options)
                            src = target[name],
                            target !== (copy = options[name]) && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1,
                            clone = src && Array.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {},
                            target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
                return target
            }
            ,
            jQuery.extend({
                expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(msg) {
                    throw new Error(msg)
                },
                noop: function() {},
                isPlainObject: function(obj) {
                    var proto, Ctor;
                    return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || "function" == typeof (Ctor = hasOwn.call(proto, "constructor") && proto.constructor) && fnToString.call(Ctor) === ObjectFunctionString)
                },
                isEmptyObject: function(obj) {
                    var name;
                    for (name in obj)
                        return !1;
                    return !0
                },
                globalEval: function(code) {
                    DOMEval(code)
                },
                each: function(obj, callback) {
                    var length, i = 0;
                    if (isArrayLike(obj))
                        for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++)
                            ;
                    else
                        for (i in obj)
                            if (!1 === callback.call(obj[i], i, obj[i]))
                                break;
                    return obj
                },
                trim: function(text) {
                    return null == text ? "" : (text + "").replace(rtrim, "")
                },
                makeArray: function(arr, results) {
                    var ret = results || [];
                    return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)),
                    ret
                },
                inArray: function(elem, arr, i) {
                    return null == arr ? -1 : indexOf.call(arr, elem, i)
                },
                merge: function(first, second) {
                    for (var len = +second.length, j = 0, i = first.length; j < len; j++)
                        first[i++] = second[j];
                    return first.length = i,
                    first
                },
                grep: function(elems, callback, invert) {
                    for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++)
                        !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
                    return matches
                },
                map: function(elems, callback, arg) {
                    var length, value, i = 0, ret = [];
                    if (isArrayLike(elems))
                        for (length = elems.length; i < length; i++)
                            null != (value = callback(elems[i], i, arg)) && ret.push(value);
                    else
                        for (i in elems)
                            null != (value = callback(elems[i], i, arg)) && ret.push(value);
                    return concat.apply([], ret)
                },
                guid: 1,
                support: support
            }),
            "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]),
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
                class2type["[object " + name + "]"] = name.toLowerCase()
            });
            var Sizzle = function(window) {
                function Sizzle(selector, context, results, seed) {
                    var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
                    if (results = results || [],
                    "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType)
                        return results;
                    if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context),
                    context = context || document,
                    documentIsHTML)) {
                        if (11 !== nodeType && (match = rquickExpr.exec(selector)))
                            if (m = match[1]) {
                                if (9 === nodeType) {
                                    if (!(elem = context.getElementById(m)))
                                        return results;
                                    if (elem.id === m)
                                        return results.push(elem),
                                        results
                                } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m)
                                    return results.push(elem),
                                    results
                            } else {
                                if (match[2])
                                    return push.apply(results, context.getElementsByTagName(selector)),
                                    results;
                                if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName)
                                    return push.apply(results, context.getElementsByClassName(m)),
                                    results
                            }
                        if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            if (1 !== nodeType)
                                newContext = context,
                                newSelector = selector;
                            else if ("object" !== context.nodeName.toLowerCase()) {
                                for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando),
                                i = (groups = tokenize(selector)).length; i--; )
                                    groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                newSelector = groups.join(","),
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context
                            }
                            if (newSelector)
                                try {
                                    return push.apply(results, newContext.querySelectorAll(newSelector)),
                                    results
                                } catch (qsaError) {} finally {
                                    nid === expando && context.removeAttribute("id")
                                }
                        }
                    }
                    return select(selector.replace(rtrim, "$1"), context, results, seed)
                }
                function createCache() {
                    function cache(key, value) {
                        return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()],
                        cache[key + " "] = value
                    }
                    var keys = [];
                    return cache
                }
                function markFunction(fn) {
                    return fn[expando] = !0,
                    fn
                }
                function assert(fn) {
                    var el = document.createElement("fieldset");
                    try {
                        return !!fn(el)
                    } catch (e) {
                        return !1
                    } finally {
                        el.parentNode && el.parentNode.removeChild(el),
                        el = null
                    }
                }
                function addHandle(attrs, handler) {
                    for (var arr = attrs.split("|"), i = arr.length; i--; )
                        Expr.attrHandle[arr[i]] = handler
                }
                function siblingCheck(a, b) {
                    var cur = b && a
                      , diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
                    if (diff)
                        return diff;
                    if (cur)
                        for (; cur = cur.nextSibling; )
                            if (cur === b)
                                return -1;
                    return a ? 1 : -1
                }
                function createDisabledPseudo(disabled) {
                    return function(elem) {
                        return "form"in elem ? elem.parentNode && !1 === elem.disabled ? "label"in elem ? "label"in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label"in elem && elem.disabled === disabled
                    }
                }
                function createPositionalPseudo(fn) {
                    return markFunction(function(argument) {
                        return argument = +argument,
                        markFunction(function(seed, matches) {
                            for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; )
                                seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                        })
                    })
                }
                function testContext(context) {
                    return context && void 0 !== context.getElementsByTagName && context
                }
                function setFilters() {}
                function toSelector(tokens) {
                    for (var i = 0, len = tokens.length, selector = ""; i < len; i++)
                        selector += tokens[i].value;
                    return selector
                }
                function addCombinator(matcher, combinator, base) {
                    var dir = combinator.dir
                      , skip = combinator.next
                      , key = skip || dir
                      , checkNonElements = base && "parentNode" === key
                      , doneName = done++;
                    return combinator.first ? function(elem, context, xml) {
                        for (; elem = elem[dir]; )
                            if (1 === elem.nodeType || checkNonElements)
                                return matcher(elem, context, xml);
                        return !1
                    }
                    : function(elem, context, xml) {
                        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                        if (xml) {
                            for (; elem = elem[dir]; )
                                if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml))
                                    return !0
                        } else
                            for (; elem = elem[dir]; )
                                if (1 === elem.nodeType || checkNonElements)
                                    if (outerCache = elem[expando] || (elem[expando] = {}),
                                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}),
                                    skip && skip === elem.nodeName.toLowerCase())
                                        elem = elem[dir] || elem;
                                    else {
                                        if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName)
                                            return newCache[2] = oldCache[2];
                                        if (uniqueCache[key] = newCache,
                                        newCache[2] = matcher(elem, context, xml))
                                            return !0
                                    }
                        return !1
                    }
                }
                function elementMatcher(matchers) {
                    return matchers.length > 1 ? function(elem, context, xml) {
                        for (var i = matchers.length; i--; )
                            if (!matchers[i](elem, context, xml))
                                return !1;
                        return !0
                    }
                    : matchers[0]
                }
                function multipleContexts(selector, contexts, results) {
                    for (var i = 0, len = contexts.length; i < len; i++)
                        Sizzle(selector, contexts[i], results);
                    return results
                }
                function condense(unmatched, map, filter, context, xml) {
                    for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++)
                        (elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem),
                        mapped && map.push(i)));
                    return newUnmatched
                }
                function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                    return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)),
                    postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)),
                    markFunction(function(seed, results, context, xml) {
                        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                        if (matcher && matcher(matcherIn, matcherOut, context, xml),
                        postFilter)
                            for (temp = condense(matcherOut, postMap),
                            postFilter(temp, [], context, xml),
                            i = temp.length; i--; )
                                (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                        if (seed) {
                            if (postFinder || preFilter) {
                                if (postFinder) {
                                    for (temp = [],
                                    i = matcherOut.length; i--; )
                                        (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                    postFinder(null, matcherOut = [], temp, xml)
                                }
                                for (i = matcherOut.length; i--; )
                                    (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                            }
                        } else
                            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut),
                            postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                    })
                }
                function matcherFromTokens(tokens) {
                    for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                        return elem === checkContext
                    }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                        return indexOf(checkContext, elem) > -1
                    }, implicitRelative, !0), matchers = [function(elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        return checkContext = null,
                        ret
                    }
                    ]; i < len; i++)
                        if (matcher = Expr.relative[tokens[i].type])
                            matchers = [addCombinator(elementMatcher(matchers), matcher)];
                        else {
                            if ((matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches))[expando]) {
                                for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++)
                                    ;
                                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                    value: " " === tokens[i - 2].type ? "*" : ""
                                })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                            }
                            matchers.push(matcher)
                        }
                    return elementMatcher(matchers)
                }
                function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                    var bySet = setMatchers.length > 0
                      , byElement = elementMatchers.length > 0
                      , superMatcher = function(seed, context, xml, results, outermost) {
                        var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                        for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                            if (byElement && elem) {
                                for (j = 0,
                                context || elem.ownerDocument === document || (setDocument(elem),
                                xml = !documentIsHTML); matcher = elementMatchers[j++]; )
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break
                                    }
                                outermost && (dirruns = dirrunsUnique)
                            }
                            bySet && ((elem = !matcher && elem) && matchedCount--,
                            seed && unmatched.push(elem))
                        }
                        if (matchedCount += i,
                        bySet && i !== matchedCount) {
                            for (j = 0; matcher = setMatchers[j++]; )
                                matcher(unmatched, setMatched, context, xml);
                            if (seed) {
                                if (matchedCount > 0)
                                    for (; i--; )
                                        unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                                setMatched = condense(setMatched)
                            }
                            push.apply(results, setMatched),
                            outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                        }
                        return outermost && (dirruns = dirrunsUnique,
                        outermostContext = contextBackup),
                        unmatched
                    };
                    return bySet ? markFunction(superMatcher) : superMatcher
                }
                var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
                    return a === b && (hasDuplicate = !0),
                    0
                }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
                    for (var i = 0, len = list.length; i < len; i++)
                        if (list[i] === elem)
                            return i;
                    return -1
                }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+","g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$","g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]","g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                    ID: new RegExp("^#(" + identifier + ")"),
                    CLASS: new RegExp("^\\.(" + identifier + ")"),
                    TAG: new RegExp("^(" + identifier + "|[*])"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)","i"),
                    bool: new RegExp("^(?:" + booleans + ")$","i"),
                    needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)","i")
                }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)","ig"), funescape = function(_, escaped, escapedWhitespace) {
                    var high = "0x" + escaped - 65536;
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
                }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
                    return asCodePoint ? "\0" === ch ? "" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch
                }, unloadHandler = function() {
                    setDocument()
                }, disabledAncestor = addCombinator(function(elem) {
                    return !0 === elem.disabled && ("form"in elem || "label"in elem)
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
                try {
                    push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes),
                    arr[preferredDoc.childNodes.length].nodeType
                } catch (e) {
                    push = {
                        apply: arr.length ? function(target, els) {
                            push_native.apply(target, slice.call(els))
                        }
                        : function(target, els) {
                            for (var j = target.length, i = 0; target[j++] = els[i++]; )
                                ;
                            target.length = j - 1
                        }
                    }
                }
                support = Sizzle.support = {},
                isXML = Sizzle.isXML = function(elem) {
                    var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                    return !!documentElement && "HTML" !== documentElement.nodeName
                }
                ,
                setDocument = Sizzle.setDocument = function(node) {
                    var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                    return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc,
                    docElem = document.documentElement,
                    documentIsHTML = !isXML(document),
                    preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)),
                    support.attributes = assert(function(el) {
                        return el.className = "i",
                        !el.getAttribute("className")
                    }),
                    support.getElementsByTagName = assert(function(el) {
                        return el.appendChild(document.createComment("")),
                        !el.getElementsByTagName("*").length
                    }),
                    support.getElementsByClassName = rnative.test(document.getElementsByClassName),
                    support.getById = assert(function(el) {
                        return docElem.appendChild(el).id = expando,
                        !document.getElementsByName || !document.getElementsByName(expando).length
                    }),
                    support.getById ? (Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            return elem.getAttribute("id") === attrId
                        }
                    }
                    ,
                    Expr.find.ID = function(id, context) {
                        if (void 0 !== context.getElementById && documentIsHTML) {
                            var elem = context.getElementById(id);
                            return elem ? [elem] : []
                        }
                    }
                    ) : (Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                            return node && node.value === attrId
                        }
                    }
                    ,
                    Expr.find.ID = function(id, context) {
                        if (void 0 !== context.getElementById && documentIsHTML) {
                            var node, i, elems, elem = context.getElementById(id);
                            if (elem) {
                                if ((node = elem.getAttributeNode("id")) && node.value === id)
                                    return [elem];
                                for (elems = context.getElementsByName(id),
                                i = 0; elem = elems[i++]; )
                                    if ((node = elem.getAttributeNode("id")) && node.value === id)
                                        return [elem]
                            }
                            return []
                        }
                    }
                    ),
                    Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                        return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
                    }
                    : function(tag, context) {
                        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                        if ("*" === tag) {
                            for (; elem = results[i++]; )
                                1 === elem.nodeType && tmp.push(elem);
                            return tmp
                        }
                        return results
                    }
                    ,
                    Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                        if (void 0 !== context.getElementsByClassName && documentIsHTML)
                            return context.getElementsByClassName(className)
                    }
                    ,
                    rbuggyMatches = [],
                    rbuggyQSA = [],
                    (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>",
                        el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"),
                        el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"),
                        el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="),
                        el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"),
                        el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
                    }),
                    assert(function(el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden"),
                        el.appendChild(input).setAttribute("name", "D"),
                        el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="),
                        2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                        docElem.appendChild(el).disabled = !0,
                        2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"),
                        el.querySelectorAll("*,:x"),
                        rbuggyQSA.push(",.*:")
                    })),
                    (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                        support.disconnectedMatch = matches.call(el, "*"),
                        matches.call(el, "[s!='']:x"),
                        rbuggyMatches.push("!=", pseudos)
                    }),
                    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")),
                    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")),
                    hasCompare = rnative.test(docElem.compareDocumentPosition),
                    contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                        var adown = 9 === a.nodeType ? a.documentElement : a
                          , bup = b && b.parentNode;
                        return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                    }
                    : function(a, b) {
                        if (b)
                            for (; b = b.parentNode; )
                                if (b === a)
                                    return !0;
                        return !1
                    }
                    ,
                    sortOrder = hasCompare ? function(a, b) {
                        if (a === b)
                            return hasDuplicate = !0,
                            0;
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return compare || (1 & (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1) || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
                    }
                    : function(a, b) {
                        if (a === b)
                            return hasDuplicate = !0,
                            0;
                        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                        if (!aup || !bup)
                            return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                        if (aup === bup)
                            return siblingCheck(a, b);
                        for (cur = a; cur = cur.parentNode; )
                            ap.unshift(cur);
                        for (cur = b; cur = cur.parentNode; )
                            bp.unshift(cur);
                        for (; ap[i] === bp[i]; )
                            i++;
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                    }
                    ,
                    document) : document
                }
                ,
                Sizzle.matches = function(expr, elements) {
                    return Sizzle(expr, null, null, elements)
                }
                ,
                Sizzle.matchesSelector = function(elem, expr) {
                    if ((elem.ownerDocument || elem) !== document && setDocument(elem),
                    expr = expr.replace(rattributeQuotes, "='$1']"),
                    support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr)))
                        try {
                            var ret = matches.call(elem, expr);
                            if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType)
                                return ret
                        } catch (e) {}
                    return Sizzle(expr, document, null, [elem]).length > 0
                }
                ,
                Sizzle.contains = function(context, elem) {
                    return (context.ownerDocument || context) !== document && setDocument(context),
                    contains(context, elem)
                }
                ,
                Sizzle.attr = function(elem, name) {
                    (elem.ownerDocument || elem) !== document && setDocument(elem);
                    var fn = Expr.attrHandle[name.toLowerCase()]
                      , val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                    return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }
                ,
                Sizzle.escape = function(sel) {
                    return (sel + "").replace(rcssescape, fcssescape)
                }
                ,
                Sizzle.error = function(msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg)
                }
                ,
                Sizzle.uniqueSort = function(results) {
                    var elem, duplicates = [], j = 0, i = 0;
                    if (hasDuplicate = !support.detectDuplicates,
                    sortInput = !support.sortStable && results.slice(0),
                    results.sort(sortOrder),
                    hasDuplicate) {
                        for (; elem = results[i++]; )
                            elem === results[i] && (j = duplicates.push(i));
                        for (; j--; )
                            results.splice(duplicates[j], 1)
                    }
                    return sortInput = null,
                    results
                }
                ,
                getText = Sizzle.getText = function(elem) {
                    var node, ret = "", i = 0, nodeType = elem.nodeType;
                    if (nodeType) {
                        if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                            if ("string" == typeof elem.textContent)
                                return elem.textContent;
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                ret += getText(elem)
                        } else if (3 === nodeType || 4 === nodeType)
                            return elem.nodeValue
                    } else
                        for (; node = elem[i++]; )
                            ret += getText(node);
                    return ret
                }
                ,
                (Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(match) {
                            return match[1] = match[1].replace(runescape, funescape),
                            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape),
                            "~=" === match[2] && (match[3] = " " + match[3] + " "),
                            match.slice(0, 4)
                        },
                        CHILD: function(match) {
                            return match[1] = match[1].toLowerCase(),
                            "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]),
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])),
                            match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]),
                            match
                        },
                        PSEUDO: function(match) {
                            var excess, unquoted = !match[6] && match[2];
                            return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess),
                            match[2] = unquoted.slice(0, excess)),
                            match.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return "*" === nodeNameSelector ? function() {
                                return !0
                            }
                            : function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                            }
                        },
                        CLASS: function(className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                                return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "")
                            })
                        },
                        ATTR: function(name, operator, check) {
                            return function(elem) {
                                var result = Sizzle.attr(elem, name);
                                return null == result ? "!=" === operator : !operator || (result += "",
                                "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"))
                            }
                        },
                        CHILD: function(type, what, argument, first, last) {
                            var simple = "nth" !== type.slice(0, 3)
                              , forward = "last" !== type.slice(-4)
                              , ofType = "of-type" === what;
                            return 1 === first && 0 === last ? function(elem) {
                                return !!elem.parentNode
                            }
                            : function(elem, context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                                if (parent) {
                                    if (simple) {
                                        for (; dir; ) {
                                            for (node = elem; node = node[dir]; )
                                                if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType)
                                                    return !1;
                                            start = dir = "only" === type && !start && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (start = [forward ? parent.firstChild : parent.lastChild],
                                    forward && useCache) {
                                        for (diff = (nodeIndex = (cache = (uniqueCache = (outerCache = (node = parent)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]) && cache[2],
                                        node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); )
                                            if (1 === node.nodeType && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break
                                            }
                                    } else if (useCache && (diff = nodeIndex = (cache = (uniqueCache = (outerCache = (node = elem)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]),
                                    !1 === diff)
                                        for (; (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((uniqueCache = (outerCache = node[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] = [dirruns, diff]),
                                        node !== elem)); )
                                            ;
                                    return (diff -= last) === first || diff % first == 0 && diff / first >= 0
                                }
                            }
                        },
                        PSEUDO: function(pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument],
                            Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                                for (var idx, matched = fn(seed, argument), i = matched.length; i--; )
                                    seed[idx = indexOf(seed, matched[i])] = !(matches[idx] = matched[i])
                            }) : function(elem) {
                                return fn(elem, 0, args)
                            }
                            ) : fn
                        }
                    },
                    pseudos: {
                        not: markFunction(function(selector) {
                            var input = []
                              , results = []
                              , matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; )
                                    (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            }) : function(elem, context, xml) {
                                return input[0] = elem,
                                matcher(input, null, xml, results),
                                input[0] = null,
                                !results.pop()
                            }
                        }),
                        has: markFunction(function(selector) {
                            return function(elem) {
                                return Sizzle(selector, elem).length > 0
                            }
                        }),
                        contains: markFunction(function(text) {
                            return text = text.replace(runescape, funescape),
                            function(elem) {
                                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                            }
                        }),
                        lang: markFunction(function(lang) {
                            return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang),
                            lang = lang.replace(runescape, funescape).toLowerCase(),
                            function(elem) {
                                var elemLang;
                                do {
                                    if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))
                                        return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-")
                                } while ((elem = elem.parentNode) && 1 === elem.nodeType);return !1
                            }
                        }),
                        target: function(elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id
                        },
                        root: function(elem) {
                            return elem === docElem
                        },
                        focus: function(elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                        },
                        enabled: createDisabledPseudo(!1),
                        disabled: createDisabledPseudo(!0),
                        checked: function(elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                        },
                        selected: function(elem) {
                            return elem.parentNode && elem.parentNode.selectedIndex,
                            !0 === elem.selected
                        },
                        empty: function(elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                if (elem.nodeType < 6)
                                    return !1;
                            return !0
                        },
                        parent: function(elem) {
                            return !Expr.pseudos.empty(elem)
                        },
                        header: function(elem) {
                            return rheader.test(elem.nodeName)
                        },
                        input: function(elem) {
                            return rinputs.test(elem.nodeName)
                        },
                        button: function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return "input" === name && "button" === elem.type || "button" === name
                        },
                        text: function(elem) {
                            var attr;
                            return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                        },
                        first: createPositionalPseudo(function() {
                            return [0]
                        }),
                        last: createPositionalPseudo(function(matchIndexes, length) {
                            return [length - 1]
                        }),
                        eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument]
                        }),
                        even: createPositionalPseudo(function(matchIndexes, length) {
                            for (var i = 0; i < length; i += 2)
                                matchIndexes.push(i);
                            return matchIndexes
                        }),
                        odd: createPositionalPseudo(function(matchIndexes, length) {
                            for (var i = 1; i < length; i += 2)
                                matchIndexes.push(i);
                            return matchIndexes
                        }),
                        lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument; --i >= 0; )
                                matchIndexes.push(i);
                            return matchIndexes
                        }),
                        gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument; ++i < length; )
                                matchIndexes.push(i);
                            return matchIndexes
                        })
                    }
                }).pseudos.nth = Expr.pseudos.eq;
                for (i in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                })
                    Expr.pseudos[i] = function(type) {
                        return function(elem) {
                            return "input" === elem.nodeName.toLowerCase() && elem.type === type
                        }
                    }(i);
                for (i in {
                    submit: !0,
                    reset: !0
                })
                    Expr.pseudos[i] = function(type) {
                        return function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return ("input" === name || "button" === name) && elem.type === type
                        }
                    }(i);
                return setFilters.prototype = Expr.filters = Expr.pseudos,
                Expr.setFilters = new setFilters,
                tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                    if (cached)
                        return parseOnly ? 0 : cached.slice(0);
                    for (soFar = selector,
                    groups = [],
                    preFilters = Expr.preFilter; soFar; ) {
                        matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar),
                        groups.push(tokens = [])),
                        matched = !1,
                        (match = rcombinators.exec(soFar)) && (matched = match.shift(),
                        tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        }),
                        soFar = soFar.slice(matched.length));
                        for (type in Expr.filter)
                            !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(),
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            }),
                            soFar = soFar.slice(matched.length));
                        if (!matched)
                            break
                    }
                    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
                }
                ,
                compile = Sizzle.compile = function(selector, match) {
                    var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                    if (!cached) {
                        for (match || (match = tokenize(selector)),
                        i = match.length; i--; )
                            (cached = matcherFromTokens(match[i]))[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                        (cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers))).selector = selector
                    }
                    return cached
                }
                ,
                select = Sizzle.select = function(selector, context, results, seed) {
                    var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                    if (results = results || [],
                    1 === match.length) {
                        if ((tokens = match[0] = match[0].slice(0)).length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                            if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0]))
                                return results;
                            compiled && (context = context.parentNode),
                            selector = selector.slice(tokens.shift().value.length)
                        }
                        for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i],
                        !Expr.relative[type = token.type]); )
                            if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                                if (tokens.splice(i, 1),
                                !(selector = seed.length && toSelector(tokens)))
                                    return push.apply(results, seed),
                                    results;
                                break
                            }
                    }
                    return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context),
                    results
                }
                ,
                support.sortStable = expando.split("").sort(sortOrder).join("") === expando,
                support.detectDuplicates = !!hasDuplicate,
                setDocument(),
                support.sortDetached = assert(function(el) {
                    return 1 & el.compareDocumentPosition(document.createElement("fieldset"))
                }),
                assert(function(el) {
                    return el.innerHTML = "<a href='#'></a>",
                    "#" === el.firstChild.getAttribute("href")
                }) || addHandle("type|href|height|width", function(elem, name, isXML) {
                    if (!isXML)
                        return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
                }),
                support.attributes && assert(function(el) {
                    return el.innerHTML = "<input/>",
                    el.firstChild.setAttribute("value", ""),
                    "" === el.firstChild.getAttribute("value")
                }) || addHandle("value", function(elem, name, isXML) {
                    if (!isXML && "input" === elem.nodeName.toLowerCase())
                        return elem.defaultValue
                }),
                assert(function(el) {
                    return null == el.getAttribute("disabled")
                }) || addHandle(booleans, function(elem, name, isXML) {
                    var val;
                    if (!isXML)
                        return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }),
                Sizzle
            }(window);
            jQuery.find = Sizzle,
            jQuery.expr = Sizzle.selectors,
            jQuery.expr[":"] = jQuery.expr.pseudos,
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort,
            jQuery.text = Sizzle.getText,
            jQuery.isXMLDoc = Sizzle.isXML,
            jQuery.contains = Sizzle.contains,
            jQuery.escapeSelector = Sizzle.escape;
            var dir = function(elem, dir, until) {
                for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; )
                    if (1 === elem.nodeType) {
                        if (truncate && jQuery(elem).is(until))
                            break;
                        matched.push(elem)
                    }
                return matched
            }
              , siblings = function(n, elem) {
                for (var matched = []; n; n = n.nextSibling)
                    1 === n.nodeType && n !== elem && matched.push(n);
                return matched
            }
              , rneedsContext = jQuery.expr.match.needsContext
              , rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
            jQuery.filter = function(expr, elems, not) {
                var elem = elems[0];
                return not && (expr = ":not(" + expr + ")"),
                1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                    return 1 === elem.nodeType
                }))
            }
            ,
            jQuery.fn.extend({
                find: function(selector) {
                    var i, ret, len = this.length, self = this;
                    if ("string" != typeof selector)
                        return this.pushStack(jQuery(selector).filter(function() {
                            for (i = 0; i < len; i++)
                                if (jQuery.contains(self[i], this))
                                    return !0
                        }));
                    for (ret = this.pushStack([]),
                    i = 0; i < len; i++)
                        jQuery.find(selector, self[i], ret);
                    return len > 1 ? jQuery.uniqueSort(ret) : ret
                },
                filter: function(selector) {
                    return this.pushStack(winnow(this, selector || [], !1))
                },
                not: function(selector) {
                    return this.pushStack(winnow(this, selector || [], !0))
                },
                is: function(selector) {
                    return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
                }
            });
            var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            (jQuery.fn.init = function(selector, context, root) {
                var match, elem;
                if (!selector)
                    return this;
                if (root = root || rootjQuery,
                "string" == typeof selector) {
                    if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector)) || !match[1] && context)
                        return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
                    if (match[1]) {
                        if (context = context instanceof jQuery ? context[0] : context,
                        jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)),
                        rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                            for (match in context)
                                isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                        return this
                    }
                    return (elem = document.getElementById(match[2])) && (this[0] = elem,
                    this.length = 1),
                    this
                }
                return selector.nodeType ? (this[0] = selector,
                this.length = 1,
                this) : isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this)
            }
            ).prototype = jQuery.fn,
            rootjQuery = jQuery(document);
            var rparentsprev = /^(?:parents|prev(?:Until|All))/
              , guaranteedUnique = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
            jQuery.fn.extend({
                has: function(target) {
                    var targets = jQuery(target, this)
                      , l = targets.length;
                    return this.filter(function() {
                        for (var i = 0; i < l; i++)
                            if (jQuery.contains(this, targets[i]))
                                return !0
                    })
                },
                closest: function(selectors, context) {
                    var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
                    if (!rneedsContext.test(selectors))
                        for (; i < l; i++)
                            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                                    matched.push(cur);
                                    break
                                }
                    return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)
                },
                index: function(elem) {
                    return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(selector, context) {
                    return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
                },
                addBack: function(selector) {
                    return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
                }
            }),
            jQuery.each({
                parent: function(elem) {
                    var parent = elem.parentNode;
                    return parent && 11 !== parent.nodeType ? parent : null
                },
                parents: function(elem) {
                    return dir(elem, "parentNode")
                },
                parentsUntil: function(elem, i, until) {
                    return dir(elem, "parentNode", until)
                },
                next: function(elem) {
                    return sibling(elem, "nextSibling")
                },
                prev: function(elem) {
                    return sibling(elem, "previousSibling")
                },
                nextAll: function(elem) {
                    return dir(elem, "nextSibling")
                },
                prevAll: function(elem) {
                    return dir(elem, "previousSibling")
                },
                nextUntil: function(elem, i, until) {
                    return dir(elem, "nextSibling", until)
                },
                prevUntil: function(elem, i, until) {
                    return dir(elem, "previousSibling", until)
                },
                siblings: function(elem) {
                    return siblings((elem.parentNode || {}).firstChild, elem)
                },
                children: function(elem) {
                    return siblings(elem.firstChild)
                },
                contents: function(elem) {
                    return nodeName(elem, "iframe") ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem),
                    jQuery.merge([], elem.childNodes))
                }
            }, function(name, fn) {
                jQuery.fn[name] = function(until, selector) {
                    var matched = jQuery.map(this, fn, until);
                    return "Until" !== name.slice(-5) && (selector = until),
                    selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)),
                    this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched),
                    rparentsprev.test(name) && matched.reverse()),
                    this.pushStack(matched)
                }
            });
            var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
            jQuery.Callbacks = function(options) {
                options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
                var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
                    for (locked = locked || options.once,
                    fired = firing = !0; queue.length; firingIndex = -1)
                        for (memory = queue.shift(); ++firingIndex < list.length; )
                            !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length,
                            memory = !1);
                    options.memory || (memory = !1),
                    firing = !1,
                    locked && (list = memory ? [] : "")
                }, self = {
                    add: function() {
                        return list && (memory && !firing && (firingIndex = list.length - 1,
                        queue.push(memory)),
                        function add(args) {
                            jQuery.each(args, function(_, arg) {
                                isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== toType(arg) && add(arg)
                            })
                        }(arguments),
                        memory && !firing && fire()),
                        this
                    },
                    remove: function() {
                        return jQuery.each(arguments, function(_, arg) {
                            for (var index; (index = jQuery.inArray(arg, list, index)) > -1; )
                                list.splice(index, 1),
                                index <= firingIndex && firingIndex--
                        }),
                        this
                    },
                    has: function(fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
                    },
                    empty: function() {
                        return list && (list = []),
                        this
                    },
                    disable: function() {
                        return locked = queue = [],
                        list = memory = "",
                        this
                    },
                    disabled: function() {
                        return !list
                    },
                    lock: function() {
                        return locked = queue = [],
                        memory || firing || (list = memory = ""),
                        this
                    },
                    locked: function() {
                        return !!locked
                    },
                    fireWith: function(context, args) {
                        return locked || (args = [context, (args = args || []).slice ? args.slice() : args],
                        queue.push(args),
                        firing || fire()),
                        this
                    },
                    fire: function() {
                        return self.fireWith(this, arguments),
                        this
                    },
                    fired: function() {
                        return !!fired
                    }
                };
                return self
            }
            ,
            jQuery.extend({
                Deferred: function(func) {
                    var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]]
                      , state = "pending"
                      , promise = {
                        state: function() {
                            return state
                        },
                        always: function() {
                            return deferred.done(arguments).fail(arguments),
                            this
                        },
                        catch: function(fn) {
                            return promise.then(null, fn)
                        },
                        pipe: function() {
                            var fns = arguments;
                            return jQuery.Deferred(function(newDefer) {
                                jQuery.each(tuples, function(i, tuple) {
                                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                    deferred[tuple[1]](function() {
                                        var returned = fn && fn.apply(this, arguments);
                                        returned && isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
                                    })
                                }),
                                fns = null
                            }).promise()
                        },
                        then: function(onFulfilled, onRejected, onProgress) {
                            function resolve(depth, deferred, handler, special) {
                                return function() {
                                    var that = this
                                      , args = arguments
                                      , mightThrow = function() {
                                        var returned, then;
                                        if (!(depth < maxDepth)) {
                                            if ((returned = handler.apply(that, args)) === deferred.promise())
                                                throw new TypeError("Thenable self-resolution");
                                            then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then,
                                            isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++,
                                            then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0,
                                            args = [returned]),
                                            (special || deferred.resolveWith)(that, args))
                                        }
                                    }
                                      , process = special ? mightThrow : function() {
                                        try {
                                            mightThrow()
                                        } catch (e) {
                                            jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace),
                                            depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0,
                                            args = [e]),
                                            deferred.rejectWith(that, args))
                                        }
                                    }
                                    ;
                                    depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()),
                                    window.setTimeout(process))
                                }
                            }
                            var maxDepth = 0;
                            return jQuery.Deferred(function(newDefer) {
                                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)),
                                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)),
                                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower))
                            }).promise()
                        },
                        promise: function(obj) {
                            return null != obj ? jQuery.extend(obj, promise) : promise
                        }
                    }
                      , deferred = {};
                    return jQuery.each(tuples, function(i, tuple) {
                        var list = tuple[2]
                          , stateString = tuple[5];
                        promise[tuple[1]] = list.add,
                        stateString && list.add(function() {
                            state = stateString
                        }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock),
                        list.add(tuple[3].fire),
                        deferred[tuple[0]] = function() {
                            return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments),
                            this
                        }
                        ,
                        deferred[tuple[0] + "With"] = list.fireWith
                    }),
                    promise.promise(deferred),
                    func && func.call(deferred, deferred),
                    deferred
                },
                when: function(singleValue) {
                    var remaining = arguments.length
                      , i = remaining
                      , resolveContexts = Array(i)
                      , resolveValues = slice.call(arguments)
                      , master = jQuery.Deferred()
                      , updateFunc = function(i) {
                        return function(value) {
                            resolveContexts[i] = this,
                            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value,
                            --remaining || master.resolveWith(resolveContexts, resolveValues)
                        }
                    };
                    if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining),
                    "pending" === master.state() || isFunction(resolveValues[i] && resolveValues[i].then)))
                        return master.then();
                    for (; i--; )
                        adoptValue(resolveValues[i], updateFunc(i), master.reject);
                    return master.promise()
                }
            });
            var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            jQuery.Deferred.exceptionHook = function(error, stack) {
                window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
            }
            ,
            jQuery.readyException = function(error) {
                window.setTimeout(function() {
                    throw error
                })
            }
            ;
            var readyList = jQuery.Deferred();
            jQuery.fn.ready = function(fn) {
                return readyList.then(fn).catch(function(error) {
                    jQuery.readyException(error)
                }),
                this
            }
            ,
            jQuery.extend({
                isReady: !1,
                readyWait: 1,
                ready: function(wait) {
                    (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0,
                    !0 !== wait && --jQuery.readyWait > 0 || readyList.resolveWith(document, [jQuery]))
                }
            }),
            jQuery.ready.then = readyList.then,
            "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed),
            window.addEventListener("load", completed));
            var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0
                  , len = elems.length
                  , bulk = null == key;
                if ("object" === toType(key)) {
                    chainable = !0;
                    for (i in key)
                        access(elems, fn, i, key[i], !0, emptyGet, raw)
                } else if (void 0 !== value && (chainable = !0,
                isFunction(value) || (raw = !0),
                bulk && (raw ? (fn.call(elems, value),
                fn = null) : (bulk = fn,
                fn = function(elem, key, value) {
                    return bulk.call(jQuery(elem), value)
                }
                )),
                fn))
                    for (; i < len; i++)
                        fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
            }
              , rmsPrefix = /^-ms-/
              , rdashAlpha = /-([a-z])/g
              , acceptData = function(owner) {
                return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
            };
            Data.uid = 1,
            Data.prototype = {
                cache: function(owner) {
                    var value = owner[this.expando];
                    return value || (value = {},
                    acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: !0
                    }))),
                    value
                },
                set: function(owner, data, value) {
                    var prop, cache = this.cache(owner);
                    if ("string" == typeof data)
                        cache[camelCase(data)] = value;
                    else
                        for (prop in data)
                            cache[camelCase(prop)] = data[prop];
                    return cache
                },
                get: function(owner, key) {
                    return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)]
                },
                access: function(owner, key, value) {
                    return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value),
                    void 0 !== value ? value : key)
                },
                remove: function(owner, key) {
                    var i, cache = owner[this.expando];
                    if (void 0 !== cache) {
                        if (void 0 !== key) {
                            i = (key = Array.isArray(key) ? key.map(camelCase) : (key = camelCase(key))in cache ? [key] : key.match(rnothtmlwhite) || []).length;
                            for (; i--; )
                                delete cache[key[i]]
                        }
                        (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando])
                    }
                },
                hasData: function(owner) {
                    var cache = owner[this.expando];
                    return void 0 !== cache && !jQuery.isEmptyObject(cache)
                }
            };
            var dataPriv = new Data
              , dataUser = new Data
              , rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
              , rmultiDash = /[A-Z]/g;
            jQuery.extend({
                hasData: function(elem) {
                    return dataUser.hasData(elem) || dataPriv.hasData(elem)
                },
                data: function(elem, name, data) {
                    return dataUser.access(elem, name, data)
                },
                removeData: function(elem, name) {
                    dataUser.remove(elem, name)
                },
                _data: function(elem, name, data) {
                    return dataPriv.access(elem, name, data)
                },
                _removeData: function(elem, name) {
                    dataPriv.remove(elem, name)
                }
            }),
            jQuery.fn.extend({
                data: function(key, value) {
                    var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                    if (void 0 === key) {
                        if (this.length && (data = dataUser.get(elem),
                        1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                            for (i = attrs.length; i--; )
                                attrs[i] && 0 === (name = attrs[i].name).indexOf("data-") && (name = camelCase(name.slice(5)),
                                dataAttr(elem, name, data[name]));
                            dataPriv.set(elem, "hasDataAttrs", !0)
                        }
                        return data
                    }
                    return "object" == typeof key ? this.each(function() {
                        dataUser.set(this, key)
                    }) : access(this, function(value) {
                        var data;
                        if (elem && void 0 === value) {
                            if (void 0 !== (data = dataUser.get(elem, key)))
                                return data;
                            if (void 0 !== (data = dataAttr(elem, key)))
                                return data
                        } else
                            this.each(function() {
                                dataUser.set(this, key, value)
                            })
                    }, null, value, arguments.length > 1, null, !0)
                },
                removeData: function(key) {
                    return this.each(function() {
                        dataUser.remove(this, key)
                    })
                }
            }),
            jQuery.extend({
                queue: function(elem, type, data) {
                    var queue;
                    if (elem)
                        return type = (type || "fx") + "queue",
                        queue = dataPriv.get(elem, type),
                        data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)),
                        queue || []
                },
                dequeue: function(elem, type) {
                    type = type || "fx";
                    var queue = jQuery.queue(elem, type)
                      , startLength = queue.length
                      , fn = queue.shift()
                      , hooks = jQuery._queueHooks(elem, type);
                    "inprogress" === fn && (fn = queue.shift(),
                    startLength--),
                    fn && ("fx" === type && queue.unshift("inprogress"),
                    delete hooks.stop,
                    fn.call(elem, function() {
                        jQuery.dequeue(elem, type)
                    }, hooks)),
                    !startLength && hooks && hooks.empty.fire()
                },
                _queueHooks: function(elem, type) {
                    var key = type + "queueHooks";
                    return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            dataPriv.remove(elem, [type + "queue", key])
                        })
                    })
                }
            }),
            jQuery.fn.extend({
                queue: function(type, data) {
                    var setter = 2;
                    return "string" != typeof type && (data = type,
                    type = "fx",
                    setter--),
                    arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                        var queue = jQuery.queue(this, type, data);
                        jQuery._queueHooks(this, type),
                        "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                    })
                },
                dequeue: function(type) {
                    return this.each(function() {
                        jQuery.dequeue(this, type)
                    })
                },
                clearQueue: function(type) {
                    return this.queue(type || "fx", [])
                },
                promise: function(type, obj) {
                    var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                        --count || defer.resolveWith(elements, [elements])
                    };
                    for ("string" != typeof type && (obj = type,
                    type = void 0),
                    type = type || "fx"; i--; )
                        (tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++,
                        tmp.empty.add(resolve));
                    return resolve(),
                    defer.promise(obj)
                }
            });
            var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
              , rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$","i")
              , cssExpand = ["Top", "Right", "Bottom", "Left"]
              , isHiddenWithinTree = function(elem, el) {
                return "none" === (elem = el || elem).style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display")
            }
              , swap = function(elem, options, callback, args) {
                var ret, name, old = {};
                for (name in options)
                    old[name] = elem.style[name],
                    elem.style[name] = options[name];
                ret = callback.apply(elem, args || []);
                for (name in options)
                    elem.style[name] = old[name];
                return ret
            }
              , defaultDisplayMap = {};
            jQuery.fn.extend({
                show: function() {
                    return showHide(this, !0)
                },
                hide: function() {
                    return showHide(this)
                },
                toggle: function(state) {
                    return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                        isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide()
                    })
                }
            });
            var rcheckableType = /^(?:checkbox|radio)$/i
              , rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i
              , rscriptType = /^$|^module$|\/(?:java|ecma)script/i
              , wrapMap = {
                option: [1, "<select multiple='multiple'>", "</select>"],
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
            wrapMap.optgroup = wrapMap.option,
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead,
            wrapMap.th = wrapMap.td;
            var rhtml = /<|&#?\w+;/;
            !function() {
                var div = document.createDocumentFragment().appendChild(document.createElement("div"))
                  , input = document.createElement("input");
                input.setAttribute("type", "radio"),
                input.setAttribute("checked", "checked"),
                input.setAttribute("name", "t"),
                div.appendChild(input),
                support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked,
                div.innerHTML = "<textarea>x</textarea>",
                support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue
            }();
            var documentElement = document.documentElement
              , rkeyEvent = /^key/
              , rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/
              , rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
            jQuery.event = {
                global: {},
                add: function(elem, types, handler, data, selector) {
                    var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                    if (elemData)
                        for (handler.handler && (handler = (handleObjIn = handler).handler,
                        selector = handleObjIn.selector),
                        selector && jQuery.find.matchesSelector(documentElement, selector),
                        handler.guid || (handler.guid = jQuery.guid++),
                        (events = elemData.events) || (events = elemData.events = {}),
                        (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                            return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                        }
                        ),
                        t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--; )
                            type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1],
                            namespaces = (tmp[2] || "").split(".").sort(),
                            type && (special = jQuery.event.special[type] || {},
                            type = (selector ? special.delegateType : special.bindType) || type,
                            special = jQuery.event.special[type] || {},
                            handleObj = jQuery.extend({
                                type: type,
                                origType: origType,
                                data: data,
                                handler: handler,
                                guid: handler.guid,
                                selector: selector,
                                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                                namespace: namespaces.join(".")
                            }, handleObjIn),
                            (handlers = events[type]) || ((handlers = events[type] = []).delegateCount = 0,
                            special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)),
                            special.add && (special.add.call(elem, handleObj),
                            handleObj.handler.guid || (handleObj.handler.guid = handler.guid)),
                            selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj),
                            jQuery.event.global[type] = !0)
                },
                remove: function(elem, types, handler, selector, mappedTypes) {
                    var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                    if (elemData && (events = elemData.events)) {
                        for (t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--; )
                            if (tmp = rtypenamespace.exec(types[t]) || [],
                            type = origType = tmp[1],
                            namespaces = (tmp[2] || "").split(".").sort(),
                            type) {
                                for (special = jQuery.event.special[type] || {},
                                handlers = events[type = (selector ? special.delegateType : special.bindType) || type] || [],
                                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                                origCount = j = handlers.length; j--; )
                                    handleObj = handlers[j],
                                    !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1),
                                    handleObj.selector && handlers.delegateCount--,
                                    special.remove && special.remove.call(elem, handleObj));
                                origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle),
                                delete events[type])
                            } else
                                for (type in events)
                                    jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                        jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events")
                    }
                },
                dispatch: function(nativeEvent) {
                    var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                    for (args[0] = event,
                    i = 1; i < arguments.length; i++)
                        args[i] = arguments[i];
                    if (event.delegateTarget = this,
                    !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                        for (handlerQueue = jQuery.event.handlers.call(this, event, handlers),
                        i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); )
                            for (event.currentTarget = matched.elem,
                            j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); )
                                event.rnamespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj,
                                event.data = handleObj.data,
                                void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(),
                                event.stopPropagation()));
                        return special.postDispatch && special.postDispatch.call(this, event),
                        event.result
                    }
                },
                handlers: function(event, handlers) {
                    var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                    if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1))
                        for (; cur !== this; cur = cur.parentNode || this)
                            if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                                for (matchedHandlers = [],
                                matchedSelectors = {},
                                i = 0; i < delegateCount; i++)
                                    void 0 === matchedSelectors[sel = (handleObj = handlers[i]).selector + " "] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length),
                                    matchedSelectors[sel] && matchedHandlers.push(handleObj);
                                matchedHandlers.length && handlerQueue.push({
                                    elem: cur,
                                    handlers: matchedHandlers
                                })
                            }
                    return cur = this,
                    delegateCount < handlers.length && handlerQueue.push({
                        elem: cur,
                        handlers: handlers.slice(delegateCount)
                    }),
                    handlerQueue
                },
                addProp: function(name, hook) {
                    Object.defineProperty(jQuery.Event.prototype, name, {
                        enumerable: !0,
                        configurable: !0,
                        get: isFunction(hook) ? function() {
                            if (this.originalEvent)
                                return hook(this.originalEvent)
                        }
                        : function() {
                            if (this.originalEvent)
                                return this.originalEvent[name]
                        }
                        ,
                        set: function(value) {
                            Object.defineProperty(this, name, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: value
                            })
                        }
                    })
                },
                fix: function(originalEvent) {
                    return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    focus: {
                        trigger: function() {
                            if (this !== safeActiveElement() && this.focus)
                                return this.focus(),
                                !1
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === safeActiveElement() && this.blur)
                                return this.blur(),
                                !1
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        trigger: function() {
                            if ("checkbox" === this.type && this.click && nodeName(this, "input"))
                                return this.click(),
                                !1
                        },
                        _default: function(event) {
                            return nodeName(event.target, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(event) {
                            void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                        }
                    }
                }
            },
            jQuery.removeEvent = function(elem, type, handle) {
                elem.removeEventListener && elem.removeEventListener(type, handle)
            }
            ,
            jQuery.Event = function(src, props) {
                if (!(this instanceof jQuery.Event))
                    return new jQuery.Event(src,props);
                src && src.type ? (this.originalEvent = src,
                this.type = src.type,
                this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse,
                this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target,
                this.currentTarget = src.currentTarget,
                this.relatedTarget = src.relatedTarget) : this.type = src,
                props && jQuery.extend(this, props),
                this.timeStamp = src && src.timeStamp || Date.now(),
                this[jQuery.expando] = !0
            }
            ,
            jQuery.Event.prototype = {
                constructor: jQuery.Event,
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                isSimulated: !1,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = returnTrue,
                    e && !this.isSimulated && e.preventDefault()
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = returnTrue,
                    e && !this.isSimulated && e.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = returnTrue,
                    e && !this.isSimulated && e.stopImmediatePropagation(),
                    this.stopPropagation()
                }
            },
            jQuery.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: function(event) {
                    var button = event.button;
                    return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which
                }
            }, jQuery.event.addProp),
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,
                    handle: function(event) {
                        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                        return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType,
                        ret = handleObj.handler.apply(this, arguments),
                        event.type = fix),
                        ret
                    }
                }
            }),
            jQuery.fn.extend({
                on: function(types, selector, data, fn) {
                    return on(this, types, selector, data, fn)
                },
                one: function(types, selector, data, fn) {
                    return on(this, types, selector, data, fn, 1)
                },
                off: function(types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj)
                        return handleObj = types.handleObj,
                        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler),
                        this;
                    if ("object" == typeof types) {
                        for (type in types)
                            this.off(type, selector, types[type]);
                        return this
                    }
                    return !1 !== selector && "function" != typeof selector || (fn = selector,
                    selector = void 0),
                    !1 === fn && (fn = returnFalse),
                    this.each(function() {
                        jQuery.event.remove(this, types, fn, selector)
                    })
                }
            });
            var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi
              , rnoInnerhtml = /<script|<style|<link/i
              , rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i
              , rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            jQuery.extend({
                htmlPrefilter: function(html) {
                    return html.replace(rxhtmlTag, "<$1></$2>")
                },
                clone: function(elem, dataAndEvents, deepDataAndEvents) {
                    var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
                    if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                        for (destElements = getAll(clone),
                        i = 0,
                        l = (srcElements = getAll(elem)).length; i < l; i++)
                            fixInput(srcElements[i], destElements[i]);
                    if (dataAndEvents)
                        if (deepDataAndEvents)
                            for (srcElements = srcElements || getAll(elem),
                            destElements = destElements || getAll(clone),
                            i = 0,
                            l = srcElements.length; i < l; i++)
                                cloneCopyEvent(srcElements[i], destElements[i]);
                        else
                            cloneCopyEvent(elem, clone);
                    return (destElements = getAll(clone, "script")).length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")),
                    clone
                },
                cleanData: function(elems) {
                    for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++)
                        if (acceptData(elem)) {
                            if (data = elem[dataPriv.expando]) {
                                if (data.events)
                                    for (type in data.events)
                                        special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                                elem[dataPriv.expando] = void 0
                            }
                            elem[dataUser.expando] && (elem[dataUser.expando] = void 0)
                        }
                }
            }),
            jQuery.fn.extend({
                detach: function(selector) {
                    return remove(this, selector, !0)
                },
                remove: function(selector) {
                    return remove(this, selector)
                },
                text: function(value) {
                    return access(this, function(value) {
                        return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value)
                        })
                    }, null, value, arguments.length)
                },
                append: function() {
                    return domManip(this, arguments, function(elem) {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || manipulationTarget(this, elem).appendChild(elem)
                    })
                },
                prepend: function() {
                    return domManip(this, arguments, function(elem) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild)
                        }
                    })
                },
                before: function() {
                    return domManip(this, arguments, function(elem) {
                        this.parentNode && this.parentNode.insertBefore(elem, this)
                    })
                },
                after: function() {
                    return domManip(this, arguments, function(elem) {
                        this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                    })
                },
                empty: function() {
                    for (var elem, i = 0; null != (elem = this[i]); i++)
                        1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)),
                        elem.textContent = "");
                    return this
                },
                clone: function(dataAndEvents, deepDataAndEvents) {
                    return dataAndEvents = null != dataAndEvents && dataAndEvents,
                    deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents,
                    this.map(function() {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                    })
                },
                html: function(value) {
                    return access(this, function(value) {
                        var elem = this[0] || {}
                          , i = 0
                          , l = this.length;
                        if (void 0 === value && 1 === elem.nodeType)
                            return elem.innerHTML;
                        if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                            value = jQuery.htmlPrefilter(value);
                            try {
                                for (; i < l; i++)
                                    1 === (elem = this[i] || {}).nodeType && (jQuery.cleanData(getAll(elem, !1)),
                                    elem.innerHTML = value);
                                elem = 0
                            } catch (e) {}
                        }
                        elem && this.empty().append(value)
                    }, null, value, arguments.length)
                },
                replaceWith: function() {
                    var ignored = [];
                    return domManip(this, arguments, function(elem) {
                        var parent = this.parentNode;
                        jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)),
                        parent && parent.replaceChild(elem, this))
                    }, ignored)
                }
            }),
            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(name, original) {
                jQuery.fn[name] = function(selector) {
                    for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++)
                        elems = i === last ? this : this.clone(!0),
                        jQuery(insert[i])[original](elems),
                        push.apply(ret, elems.get());
                    return this.pushStack(ret)
                }
            });
            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$","i")
              , getStyles = function(elem) {
                var view = elem.ownerDocument.defaultView;
                return view && view.opener || (view = window),
                view.getComputedStyle(elem)
            }
              , rboxStyle = new RegExp(cssExpand.join("|"),"i");
            !function() {
                function computeStyleTests() {
                    if (div) {
                        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                        documentElement.appendChild(container).appendChild(div);
                        var divStyle = window.getComputedStyle(div);
                        pixelPositionVal = "1%" !== divStyle.top,
                        reliableMarginLeftVal = 12 === roundPixelMeasures(divStyle.marginLeft),
                        div.style.right = "60%",
                        pixelBoxStylesVal = 36 === roundPixelMeasures(divStyle.right),
                        boxSizingReliableVal = 36 === roundPixelMeasures(divStyle.width),
                        div.style.position = "absolute",
                        scrollboxSizeVal = 36 === div.offsetWidth || "absolute",
                        documentElement.removeChild(container),
                        div = null
                    }
                }
                function roundPixelMeasures(measure) {
                    return Math.round(parseFloat(measure))
                }
                var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
                div.style && (div.style.backgroundClip = "content-box",
                div.cloneNode(!0).style.backgroundClip = "",
                support.clearCloneStyle = "content-box" === div.style.backgroundClip,
                jQuery.extend(support, {
                    boxSizingReliable: function() {
                        return computeStyleTests(),
                        boxSizingReliableVal
                    },
                    pixelBoxStyles: function() {
                        return computeStyleTests(),
                        pixelBoxStylesVal
                    },
                    pixelPosition: function() {
                        return computeStyleTests(),
                        pixelPositionVal
                    },
                    reliableMarginLeft: function() {
                        return computeStyleTests(),
                        reliableMarginLeftVal
                    },
                    scrollboxSize: function() {
                        return computeStyleTests(),
                        scrollboxSizeVal
                    }
                }))
            }();
            var rdisplayswap = /^(none|table(?!-c[ea]).+)/
              , rcustomProp = /^--/
              , cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }
              , cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            }
              , cssPrefixes = ["Webkit", "Moz", "ms"]
              , emptyStyle = document.createElement("div").style;
            jQuery.extend({
                cssHooks: {
                    opacity: {
                        get: function(elem, computed) {
                            if (computed) {
                                var ret = curCSS(elem, "opacity");
                                return "" === ret ? "1" : ret
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {},
                style: function(elem, name, value, extra) {
                    if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                        var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
                        if (isCustomProp || (name = finalPropName(origName)),
                        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName],
                        void 0 === value)
                            return hooks && "get"in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                        "string" == (type = typeof value) && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret),
                        type = "number"),
                        null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")),
                        support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"),
                        hooks && "set"in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value))
                    }
                },
                css: function(elem, name, extra, styles) {
                    var val, num, hooks, origName = camelCase(name);
                    return rcustomProp.test(name) || (name = finalPropName(origName)),
                    (hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]) && "get"in hooks && (val = hooks.get(elem, !0, extra)),
                    void 0 === val && (val = curCSS(elem, name, styles)),
                    "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]),
                    "" === extra || extra ? (num = parseFloat(val),
                    !0 === extra || isFinite(num) ? num || 0 : val) : val
                }
            }),
            jQuery.each(["height", "width"], function(i, dimension) {
                jQuery.cssHooks[dimension] = {
                    get: function(elem, computed, extra) {
                        if (computed)
                            return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, dimension, extra) : swap(elem, cssShow, function() {
                                return getWidthOrHeight(elem, dimension, extra)
                            })
                    },
                    set: function(elem, value, extra) {
                        var matches, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles), subtract = extra && boxModelAdjustment(elem, dimension, extra, isBorderBox, styles);
                        return isBorderBox && support.scrollboxSize() === styles.position && (subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", !1, styles) - .5)),
                        subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[dimension] = value,
                        value = jQuery.css(elem, dimension)),
                        setPositiveNumber(0, value, subtract)
                    }
                }
            }),
            jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
                if (computed)
                    return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                        marginLeft: 0
                    }, function() {
                        return elem.getBoundingClientRect().left
                    })) + "px"
            }),
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function(value) {
                        for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; i < 4; i++)
                            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                        return expanded
                    }
                },
                "margin" !== prefix && (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
            }),
            jQuery.fn.extend({
                css: function(name, value) {
                    return access(this, function(elem, name, value) {
                        var styles, len, map = {}, i = 0;
                        if (Array.isArray(name)) {
                            for (styles = getStyles(elem),
                            len = name.length; i < len; i++)
                                map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                            return map
                        }
                        return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                    }, name, value, arguments.length > 1)
                }
            }),
            jQuery.Tween = Tween,
            Tween.prototype = {
                constructor: Tween,
                init: function(elem, options, prop, end, easing, unit) {
                    this.elem = elem,
                    this.prop = prop,
                    this.easing = easing || jQuery.easing._default,
                    this.options = options,
                    this.start = this.now = this.cur(),
                    this.end = end,
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
                },
                cur: function() {
                    var hooks = Tween.propHooks[this.prop];
                    return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
                },
                run: function(percent) {
                    var eased, hooks = Tween.propHooks[this.prop];
                    return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent,
                    this.now = (this.end - this.start) * eased + this.start,
                    this.options.step && this.options.step.call(this.elem, this.now, this),
                    hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this),
                    this
                }
            },
            Tween.prototype.init.prototype = Tween.prototype,
            Tween.propHooks = {
                _default: {
                    get: function(tween) {
                        var result;
                        return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, "")) && "auto" !== result ? result : 0
                    },
                    set: function(tween) {
                        jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                    }
                }
            },
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function(tween) {
                    tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
                }
            },
            jQuery.easing = {
                linear: function(p) {
                    return p
                },
                swing: function(p) {
                    return .5 - Math.cos(p * Math.PI) / 2
                },
                _default: "swing"
            },
            jQuery.fx = Tween.prototype.init,
            jQuery.fx.step = {};
            var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
            jQuery.Animation = jQuery.extend(Animation, {
                tweeners: {
                    "*": [function(prop, value) {
                        var tween = this.createTween(prop, value);
                        return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween),
                        tween
                    }
                    ]
                },
                tweener: function(props, callback) {
                    isFunction(props) ? (callback = props,
                    props = ["*"]) : props = props.match(rnothtmlwhite);
                    for (var prop, index = 0, length = props.length; index < length; index++)
                        prop = props[index],
                        Animation.tweeners[prop] = Animation.tweeners[prop] || [],
                        Animation.tweeners[prop].unshift(callback)
                },
                prefilters: [function(elem, props, opts) {
                    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width"in props || "height"in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
                    opts.queue || (null == (hooks = jQuery._queueHooks(elem, "fx")).unqueued && (hooks.unqueued = 0,
                    oldfire = hooks.empty.fire,
                    hooks.empty.fire = function() {
                        hooks.unqueued || oldfire()
                    }
                    ),
                    hooks.unqueued++,
                    anim.always(function() {
                        anim.always(function() {
                            hooks.unqueued--,
                            jQuery.queue(elem, "fx").length || hooks.empty.fire()
                        })
                    }));
                    for (prop in props)
                        if (value = props[prop],
                        rfxtypes.test(value)) {
                            if (delete props[prop],
                            toggle = toggle || "toggle" === value,
                            value === (hidden ? "hide" : "show")) {
                                if ("show" !== value || !dataShow || void 0 === dataShow[prop])
                                    continue;
                                hidden = !0
                            }
                            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
                        }
                    if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig)) {
                        isBox && 1 === elem.nodeType && (opts.overflow = [style.overflow, style.overflowX, style.overflowY],
                        null == (restoreDisplay = dataShow && dataShow.display) && (restoreDisplay = dataPriv.get(elem, "display")),
                        "none" === (display = jQuery.css(elem, "display")) && (restoreDisplay ? display = restoreDisplay : (showHide([elem], !0),
                        restoreDisplay = elem.style.display || restoreDisplay,
                        display = jQuery.css(elem, "display"),
                        showHide([elem]))),
                        ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                            style.display = restoreDisplay
                        }),
                        null == restoreDisplay && (display = style.display,
                        restoreDisplay = "none" === display ? "" : display)),
                        style.display = "inline-block")),
                        opts.overflow && (style.overflow = "hidden",
                        anim.always(function() {
                            style.overflow = opts.overflow[0],
                            style.overflowX = opts.overflow[1],
                            style.overflowY = opts.overflow[2]
                        })),
                        propTween = !1;
                        for (prop in orig)
                            propTween || (dataShow ? "hidden"in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                                display: restoreDisplay
                            }),
                            toggle && (dataShow.hidden = !hidden),
                            hidden && showHide([elem], !0),
                            anim.done(function() {
                                hidden || showHide([elem]),
                                dataPriv.remove(elem, "fxshow");
                                for (prop in orig)
                                    jQuery.style(elem, prop, orig[prop])
                            })),
                            propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim),
                            prop in dataShow || (dataShow[prop] = propTween.start,
                            hidden && (propTween.end = propTween.start,
                            propTween.start = 0))
                    }
                }
                ],
                prefilter: function(callback, prepend) {
                    prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback)
                }
            }),
            jQuery.speed = function(speed, easing, fn) {
                var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !isFunction(easing) && easing
                };
                return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default),
                null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"),
                opt.old = opt.complete,
                opt.complete = function() {
                    isFunction(opt.old) && opt.old.call(this),
                    opt.queue && jQuery.dequeue(this, opt.queue)
                }
                ,
                opt
            }
            ,
            jQuery.fn.extend({
                fadeTo: function(speed, to, easing, callback) {
                    return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                        opacity: to
                    }, speed, easing, callback)
                },
                animate: function(prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop)
                      , optall = jQuery.speed(speed, easing, callback)
                      , doAnimation = function() {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        (empty || dataPriv.get(this, "finish")) && anim.stop(!0)
                    };
                    return doAnimation.finish = doAnimation,
                    empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
                },
                stop: function(type, clearQueue, gotoEnd) {
                    var stopQueue = function(hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop,
                        stop(gotoEnd)
                    };
                    return "string" != typeof type && (gotoEnd = clearQueue,
                    clearQueue = type,
                    type = void 0),
                    clearQueue && !1 !== type && this.queue(type || "fx", []),
                    this.each(function() {
                        var dequeue = !0
                          , index = null != type && type + "queueHooks"
                          , timers = jQuery.timers
                          , data = dataPriv.get(this);
                        if (index)
                            data[index] && data[index].stop && stopQueue(data[index]);
                        else
                            for (index in data)
                                data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                        for (index = timers.length; index--; )
                            timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd),
                            dequeue = !1,
                            timers.splice(index, 1));
                        !dequeue && gotoEnd || jQuery.dequeue(this, type)
                    })
                },
                finish: function(type) {
                    return !1 !== type && (type = type || "fx"),
                    this.each(function() {
                        var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                        for (data.finish = !0,
                        jQuery.queue(this, type, []),
                        hooks && hooks.stop && hooks.stop.call(this, !0),
                        index = timers.length; index--; )
                            timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0),
                            timers.splice(index, 1));
                        for (index = 0; index < length; index++)
                            queue[index] && queue[index].finish && queue[index].finish.call(this);
                        delete data.finish
                    })
                }
            }),
            jQuery.each(["toggle", "show", "hide"], function(i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function(speed, easing, callback) {
                    return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
                }
            }),
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(name, props) {
                jQuery.fn[name] = function(speed, easing, callback) {
                    return this.animate(props, speed, easing, callback)
                }
            }),
            jQuery.timers = [],
            jQuery.fx.tick = function() {
                var timer, i = 0, timers = jQuery.timers;
                for (fxNow = Date.now(); i < timers.length; i++)
                    (timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
                timers.length || jQuery.fx.stop(),
                fxNow = void 0
            }
            ,
            jQuery.fx.timer = function(timer) {
                jQuery.timers.push(timer),
                jQuery.fx.start()
            }
            ,
            jQuery.fx.interval = 13,
            jQuery.fx.start = function() {
                inProgress || (inProgress = !0,
                schedule())
            }
            ,
            jQuery.fx.stop = function() {
                inProgress = null
            }
            ,
            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            },
            jQuery.fn.delay = function(time, type) {
                return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time,
                type = type || "fx",
                this.queue(type, function(next, hooks) {
                    var timeout = window.setTimeout(next, time);
                    hooks.stop = function() {
                        window.clearTimeout(timeout)
                    }
                })
            }
            ,
            function() {
                var input = document.createElement("input")
                  , opt = document.createElement("select").appendChild(document.createElement("option"));
                input.type = "checkbox",
                support.checkOn = "" !== input.value,
                support.optSelected = opt.selected,
                (input = document.createElement("input")).value = "t",
                input.type = "radio",
                support.radioValue = "t" === input.value
            }();
            var boolHook, attrHandle = jQuery.expr.attrHandle;
            jQuery.fn.extend({
                attr: function(name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1)
                },
                removeAttr: function(name) {
                    return this.each(function() {
                        jQuery.removeAttr(this, name)
                    })
                }
            }),
            jQuery.extend({
                attr: function(elem, name, value) {
                    var ret, hooks, nType = elem.nodeType;
                    if (3 !== nType && 8 !== nType && 2 !== nType)
                        return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)),
                        void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""),
                        value) : hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : null == (ret = jQuery.find.attr(elem, name)) ? void 0 : ret)
                },
                attrHooks: {
                    type: {
                        set: function(elem, value) {
                            if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                                var val = elem.value;
                                return elem.setAttribute("type", value),
                                val && (elem.value = val),
                                value
                            }
                        }
                    }
                },
                removeAttr: function(elem, value) {
                    var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
                    if (attrNames && 1 === elem.nodeType)
                        for (; name = attrNames[i++]; )
                            elem.removeAttribute(name)
                }
            }),
            boolHook = {
                set: function(elem, value, name) {
                    return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name),
                    name
                }
            },
            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;
                attrHandle[name] = function(elem, name, isXML) {
                    var ret, handle, lowercaseName = name.toLowerCase();
                    return isXML || (handle = attrHandle[lowercaseName],
                    attrHandle[lowercaseName] = ret,
                    ret = null != getter(elem, name, isXML) ? lowercaseName : null,
                    attrHandle[lowercaseName] = handle),
                    ret
                }
            });
            var rfocusable = /^(?:input|select|textarea|button)$/i
              , rclickable = /^(?:a|area)$/i;
            jQuery.fn.extend({
                prop: function(name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1)
                },
                removeProp: function(name) {
                    return this.each(function() {
                        delete this[jQuery.propFix[name] || name]
                    })
                }
            }),
            jQuery.extend({
                prop: function(elem, name, value) {
                    var ret, hooks, nType = elem.nodeType;
                    if (3 !== nType && 8 !== nType && 2 !== nType)
                        return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name,
                        hooks = jQuery.propHooks[name]),
                        void 0 !== value ? hooks && "set"in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get"in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
                },
                propHooks: {
                    tabIndex: {
                        get: function(elem) {
                            var tabindex = jQuery.find.attr(elem, "tabindex");
                            return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }),
            support.optSelected || (jQuery.propHooks.selected = {
                get: function(elem) {
                    var parent = elem.parentNode;
                    return parent && parent.parentNode && parent.parentNode.selectedIndex,
                    null
                },
                set: function(elem) {
                    var parent = elem.parentNode;
                    parent && (parent.selectedIndex,
                    parent.parentNode && parent.parentNode.selectedIndex)
                }
            }),
            jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                jQuery.propFix[this.toLowerCase()] = this
            }),
            jQuery.fn.extend({
                addClass: function(value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                    if (isFunction(value))
                        return this.each(function(j) {
                            jQuery(this).addClass(value.call(this, j, getClass(this)))
                        });
                    if ((classes = classesToArray(value)).length)
                        for (; elem = this[i++]; )
                            if (curValue = getClass(elem),
                            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                                for (j = 0; clazz = classes[j++]; )
                                    cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                                curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
                            }
                    return this
                },
                removeClass: function(value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                    if (isFunction(value))
                        return this.each(function(j) {
                            jQuery(this).removeClass(value.call(this, j, getClass(this)))
                        });
                    if (!arguments.length)
                        return this.attr("class", "");
                    if ((classes = classesToArray(value)).length)
                        for (; elem = this[i++]; )
                            if (curValue = getClass(elem),
                            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                                for (j = 0; clazz = classes[j++]; )
                                    for (; cur.indexOf(" " + clazz + " ") > -1; )
                                        cur = cur.replace(" " + clazz + " ", " ");
                                curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
                            }
                    return this
                },
                toggleClass: function(value, stateVal) {
                    var type = typeof value
                      , isValidValue = "string" === type || Array.isArray(value);
                    return "boolean" == typeof stateVal && isValidValue ? stateVal ? this.addClass(value) : this.removeClass(value) : isFunction(value) ? this.each(function(i) {
                        jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
                    }) : this.each(function() {
                        var className, i, self, classNames;
                        if (isValidValue)
                            for (i = 0,
                            self = jQuery(this),
                            classNames = classesToArray(value); className = classNames[i++]; )
                                self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                        else
                            void 0 !== value && "boolean" !== type || ((className = getClass(this)) && dataPriv.set(this, "__className__", className),
                            this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""))
                    })
                },
                hasClass: function(selector) {
                    var className, elem, i = 0;
                    for (className = " " + selector + " "; elem = this[i++]; )
                        if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1)
                            return !0;
                    return !1
                }
            });
            var rreturn = /\r/g;
            jQuery.fn.extend({
                val: function(value) {
                    var hooks, ret, valueIsFunction, elem = this[0];
                    {
                        if (arguments.length)
                            return valueIsFunction = isFunction(value),
                            this.each(function(i) {
                                var val;
                                1 === this.nodeType && (null == (val = valueIsFunction ? value.call(this, i, jQuery(this).val()) : value) ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, function(value) {
                                    return null == value ? "" : value + ""
                                })),
                                (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set"in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                            });
                        if (elem)
                            return (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get"in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : "string" == typeof (ret = elem.value) ? ret.replace(rreturn, "") : null == ret ? "" : ret
                    }
                }
            }),
            jQuery.extend({
                valHooks: {
                    option: {
                        get: function(elem) {
                            var val = jQuery.find.attr(elem, "value");
                            return null != val ? val : stripAndCollapse(jQuery.text(elem))
                        }
                    },
                    select: {
                        get: function(elem) {
                            var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                            for (i = index < 0 ? max : one ? index : 0; i < max; i++)
                                if (((option = options[i]).selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                                    if (value = jQuery(option).val(),
                                    one)
                                        return value;
                                    values.push(value)
                                }
                            return values
                        },
                        set: function(elem, value) {
                            for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; )
                                ((option = options[i]).selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                            return optionSet || (elem.selectedIndex = -1),
                            values
                        }
                    }
                }
            }),
            jQuery.each(["radio", "checkbox"], function() {
                jQuery.valHooks[this] = {
                    set: function(elem, value) {
                        if (Array.isArray(value))
                            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1
                    }
                },
                support.checkOn || (jQuery.valHooks[this].get = function(elem) {
                    return null === elem.getAttribute("value") ? "on" : elem.value
                }
                )
            }),
            support.focusin = "onfocusin"in window;
            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/
              , stopPropagationCallback = function(e) {
                e.stopPropagation()
            };
            jQuery.extend(jQuery.event, {
                trigger: function(event, data, elem, onlyHandlers) {
                    var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                    if (cur = lastElement = tmp = elem = elem || document,
                    3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (type = (namespaces = type.split(".")).shift(),
                    namespaces.sort()),
                    ontype = type.indexOf(":") < 0 && "on" + type,
                    event = event[jQuery.expando] ? event : new jQuery.Event(type,"object" == typeof event && event),
                    event.isTrigger = onlyHandlers ? 2 : 3,
                    event.namespace = namespaces.join("."),
                    event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
                    event.result = void 0,
                    event.target || (event.target = elem),
                    data = null == data ? [event] : jQuery.makeArray(data, [event]),
                    special = jQuery.event.special[type] || {},
                    onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                            for (bubbleType = special.delegateType || type,
                            rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode)
                                eventPath.push(cur),
                                tmp = cur;
                            tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                        }
                        for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); )
                            lastElement = cur,
                            event.type = i > 1 ? bubbleType : special.bindType || type,
                            (handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle")) && handle.apply(cur, data),
                            (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data),
                            !1 === event.result && event.preventDefault());
                        return event.type = type,
                        onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && isFunction(elem[type]) && !isWindow(elem) && ((tmp = elem[ontype]) && (elem[ontype] = null),
                        jQuery.event.triggered = type,
                        event.isPropagationStopped() && lastElement.addEventListener(type, stopPropagationCallback),
                        elem[type](),
                        event.isPropagationStopped() && lastElement.removeEventListener(type, stopPropagationCallback),
                        jQuery.event.triggered = void 0,
                        tmp && (elem[ontype] = tmp)),
                        event.result
                    }
                },
                simulate: function(type, elem, event) {
                    var e = jQuery.extend(new jQuery.Event, event, {
                        type: type,
                        isSimulated: !0
                    });
                    jQuery.event.trigger(e, null, elem)
                }
            }),
            jQuery.fn.extend({
                trigger: function(type, data) {
                    return this.each(function() {
                        jQuery.event.trigger(type, data, this)
                    })
                },
                triggerHandler: function(type, data) {
                    var elem = this[0];
                    if (elem)
                        return jQuery.event.trigger(type, data, elem, !0)
                }
            }),
            support.focusin || jQuery.each({
                focus: "focusin",
                blur: "focusout"
            }, function(orig, fix) {
                var handler = function(event) {
                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
                };
                jQuery.event.special[fix] = {
                    setup: function() {
                        var doc = this.ownerDocument || this
                          , attaches = dataPriv.access(doc, fix);
                        attaches || doc.addEventListener(orig, handler, !0),
                        dataPriv.access(doc, fix, (attaches || 0) + 1)
                    },
                    teardown: function() {
                        var doc = this.ownerDocument || this
                          , attaches = dataPriv.access(doc, fix) - 1;
                        attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0),
                        dataPriv.remove(doc, fix))
                    }
                }
            });
            var location = window.location
              , nonce = Date.now()
              , rquery = /\?/;
            jQuery.parseXML = function(data) {
                var xml;
                if (!data || "string" != typeof data)
                    return null;
                try {
                    xml = (new window.DOMParser).parseFromString(data, "text/xml")
                } catch (e) {
                    xml = void 0
                }
                return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data),
                xml
            }
            ;
            var rbracket = /\[\]$/
              , rCRLF = /\r?\n/g
              , rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i
              , rsubmittable = /^(?:input|select|textarea|keygen)/i;
            jQuery.param = function(a, traditional) {
                var prefix, s = [], add = function(key, valueOrFunction) {
                    var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value)
                };
                if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a))
                    jQuery.each(a, function() {
                        add(this.name, this.value)
                    });
                else
                    for (prefix in a)
                        buildParams(prefix, a[prefix], traditional, add);
                return s.join("&")
            }
            ,
            jQuery.fn.extend({
                serialize: function() {
                    return jQuery.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map(function() {
                        var elements = jQuery.prop(this, "elements");
                        return elements ? jQuery.makeArray(elements) : this
                    }).filter(function() {
                        var type = this.type;
                        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
                    }).map(function(i, elem) {
                        var val = jQuery(this).val();
                        return null == val ? null : Array.isArray(val) ? jQuery.map(val, function(val) {
                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            }
                        }) : {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        }
                    }).get()
                }
            });
            var r20 = /%20/g
              , rhash = /#.*$/
              , rantiCache = /([?&])_=[^&]*/
              , rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm
              , rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/
              , rnoContent = /^(?:GET|HEAD)$/
              , rprotocol = /^\/\//
              , prefilters = {}
              , transports = {}
              , allTypes = "*/".concat("*")
              , originAnchor = document.createElement("a");
            originAnchor.href = location.href,
            jQuery.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: location.href,
                    type: "GET",
                    isLocal: rlocalProtocol.test(location.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": JSON.parse,
                        "text xml": jQuery.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function(target, settings) {
                    return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
                },
                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),
                ajax: function(url, options) {
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                        completed || (completed = !0,
                        timeoutTimer && window.clearTimeout(timeoutTimer),
                        transport = void 0,
                        responseHeadersString = headers || "",
                        jqXHR.readyState = status > 0 ? 4 : 0,
                        isSuccess = status >= 200 && status < 300 || 304 === status,
                        responses && (response = ajaxHandleResponses(s, jqXHR, responses)),
                        response = ajaxConvert(s, response, jqXHR, isSuccess),
                        isSuccess ? (s.ifModified && ((modified = jqXHR.getResponseHeader("Last-Modified")) && (jQuery.lastModified[cacheURL] = modified),
                        (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)),
                        204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state,
                        success = response.data,
                        isSuccess = !(error = response.error))) : (error = statusText,
                        !status && statusText || (statusText = "error",
                        status < 0 && (status = 0))),
                        jqXHR.status = status,
                        jqXHR.statusText = (nativeStatusText || statusText) + "",
                        isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]),
                        jqXHR.statusCode(statusCode),
                        statusCode = void 0,
                        fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]),
                        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]),
                        fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]),
                        --jQuery.active || jQuery.event.trigger("ajaxStop")))
                    }
                    "object" == typeof url && (options = url,
                    url = void 0),
                    options = options || {};
                    var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                        readyState: 0,
                        getResponseHeader: function(key) {
                            var match;
                            if (completed) {
                                if (!responseHeaders)
                                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); )
                                        responseHeaders[match[1].toLowerCase()] = match[2];
                                match = responseHeaders[key.toLowerCase()]
                            }
                            return null == match ? null : match
                        },
                        getAllResponseHeaders: function() {
                            return completed ? responseHeadersString : null
                        },
                        setRequestHeader: function(name, value) {
                            return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name,
                            requestHeaders[name] = value),
                            this
                        },
                        overrideMimeType: function(type) {
                            return null == completed && (s.mimeType = type),
                            this
                        },
                        statusCode: function(map) {
                            var code;
                            if (map)
                                if (completed)
                                    jqXHR.always(map[jqXHR.status]);
                                else
                                    for (code in map)
                                        statusCode[code] = [statusCode[code], map[code]];
                            return this
                        },
                        abort: function(statusText) {
                            var finalText = statusText || strAbort;
                            return transport && transport.abort(finalText),
                            done(0, finalText),
                            this
                        }
                    };
                    if (deferred.promise(jqXHR),
                    s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"),
                    s.type = options.method || options.type || s.method || s.type,
                    s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""],
                    null == s.crossDomain) {
                        urlAnchor = document.createElement("a");
                        try {
                            urlAnchor.href = s.url,
                            urlAnchor.href = urlAnchor.href,
                            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host
                        } catch (e) {
                            s.crossDomain = !0
                        }
                    }
                    if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)),
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR),
                    completed)
                        return jqXHR;
                    (fireGlobals = jQuery.event && s.global) && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"),
                    s.type = s.type.toUpperCase(),
                    s.hasContent = !rnoContent.test(s.type),
                    cacheURL = s.url.replace(rhash, ""),
                    s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length),
                    s.data && (s.processData || "string" == typeof s.data) && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data,
                    delete s.data),
                    !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"),
                    uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached),
                    s.url = cacheURL + uncached),
                    s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]),
                    jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])),
                    (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType),
                    jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                    for (i in s.headers)
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed))
                        return jqXHR.abort();
                    if (strAbort = "abort",
                    completeDeferred.add(s.complete),
                    jqXHR.done(s.success),
                    jqXHR.fail(s.error),
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                        if (jqXHR.readyState = 1,
                        fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]),
                        completed)
                            return jqXHR;
                        s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                            jqXHR.abort("timeout")
                        }, s.timeout));
                        try {
                            completed = !1,
                            transport.send(requestHeaders, done)
                        } catch (e) {
                            if (completed)
                                throw e;
                            done(-1, e)
                        }
                    } else
                        done(-1, "No Transport");
                    return jqXHR
                },
                getJSON: function(url, data, callback) {
                    return jQuery.get(url, data, callback, "json")
                },
                getScript: function(url, callback) {
                    return jQuery.get(url, void 0, callback, "script")
                }
            }),
            jQuery.each(["get", "post"], function(i, method) {
                jQuery[method] = function(url, data, callback, type) {
                    return isFunction(data) && (type = type || callback,
                    callback = data,
                    data = void 0),
                    jQuery.ajax(jQuery.extend({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    }, jQuery.isPlainObject(url) && url))
                }
            }),
            jQuery._evalUrl = function(url) {
                return jQuery.ajax({
                    url: url,
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    throws: !0
                })
            }
            ,
            jQuery.fn.extend({
                wrapAll: function(html) {
                    var wrap;
                    return this[0] && (isFunction(html) && (html = html.call(this[0])),
                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0),
                    this[0].parentNode && wrap.insertBefore(this[0]),
                    wrap.map(function() {
                        for (var elem = this; elem.firstElementChild; )
                            elem = elem.firstElementChild;
                        return elem
                    }).append(this)),
                    this
                },
                wrapInner: function(html) {
                    return isFunction(html) ? this.each(function(i) {
                        jQuery(this).wrapInner(html.call(this, i))
                    }) : this.each(function() {
                        var self = jQuery(this)
                          , contents = self.contents();
                        contents.length ? contents.wrapAll(html) : self.append(html)
                    })
                },
                wrap: function(html) {
                    var htmlIsFunction = isFunction(html);
                    return this.each(function(i) {
                        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
                    })
                },
                unwrap: function(selector) {
                    return this.parent(selector).not("body").each(function() {
                        jQuery(this).replaceWith(this.childNodes)
                    }),
                    this
                }
            }),
            jQuery.expr.pseudos.hidden = function(elem) {
                return !jQuery.expr.pseudos.visible(elem)
            }
            ,
            jQuery.expr.pseudos.visible = function(elem) {
                return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
            }
            ,
            jQuery.ajaxSettings.xhr = function() {
                try {
                    return new window.XMLHttpRequest
                } catch (e) {}
            }
            ;
            var xhrSuccessStatus = {
                0: 200,
                1223: 204
            }
              , xhrSupported = jQuery.ajaxSettings.xhr();
            support.cors = !!xhrSupported && "withCredentials"in xhrSupported,
            support.ajax = xhrSupported = !!xhrSupported,
            jQuery.ajaxTransport(function(options) {
                var callback, errorCallback;
                if (support.cors || xhrSupported && !options.crossDomain)
                    return {
                        send: function(headers, complete) {
                            var i, xhr = options.xhr();
                            if (xhr.open(options.type, options.url, options.async, options.username, options.password),
                            options.xhrFields)
                                for (i in options.xhrFields)
                                    xhr[i] = options.xhrFields[i];
                            options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType),
                            options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                            for (i in headers)
                                xhr.setRequestHeader(i, headers[i]);
                            callback = function(type) {
                                return function() {
                                    callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null,
                                    "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                                        binary: xhr.response
                                    } : {
                                        text: xhr.responseText
                                    }, xhr.getAllResponseHeaders()))
                                }
                            }
                            ,
                            xhr.onload = callback(),
                            errorCallback = xhr.onerror = xhr.ontimeout = callback("error"),
                            void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                                4 === xhr.readyState && window.setTimeout(function() {
                                    callback && errorCallback()
                                })
                            }
                            ,
                            callback = callback("abort");
                            try {
                                xhr.send(options.hasContent && options.data || null)
                            } catch (e) {
                                if (callback)
                                    throw e
                            }
                        },
                        abort: function() {
                            callback && callback()
                        }
                    }
            }),
            jQuery.ajaxPrefilter(function(s) {
                s.crossDomain && (s.contents.script = !1)
            }),
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(text) {
                        return jQuery.globalEval(text),
                        text
                    }
                }
            }),
            jQuery.ajaxPrefilter("script", function(s) {
                void 0 === s.cache && (s.cache = !1),
                s.crossDomain && (s.type = "GET")
            }),
            jQuery.ajaxTransport("script", function(s) {
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function(_, complete) {
                            script = jQuery("<script>").prop({
                                charset: s.scriptCharset,
                                src: s.url
                            }).on("load error", callback = function(evt) {
                                script.remove(),
                                callback = null,
                                evt && complete("error" === evt.type ? 404 : 200, evt.type)
                            }
                            ),
                            document.head.appendChild(script[0])
                        },
                        abort: function() {
                            callback && callback()
                        }
                    }
                }
            });
            var oldCallbacks = []
              , rjsonp = /(=)\?(?=&|$)|\?\?/;
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                    return this[callback] = !0,
                    callback
                }
            }),
            jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
                var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
                if (jsonProp || "jsonp" === s.dataTypes[0])
                    return callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback,
                    jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName),
                    s.converters["script json"] = function() {
                        return responseContainer || jQuery.error(callbackName + " was not called"),
                        responseContainer[0]
                    }
                    ,
                    s.dataTypes[0] = "json",
                    overwritten = window[callbackName],
                    window[callbackName] = function() {
                        responseContainer = arguments
                    }
                    ,
                    jqXHR.always(function() {
                        void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten,
                        s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback,
                        oldCallbacks.push(callbackName)),
                        responseContainer && isFunction(overwritten) && overwritten(responseContainer[0]),
                        responseContainer = overwritten = void 0
                    }),
                    "script"
            }),
            support.createHTMLDocument = function() {
                var body = document.implementation.createHTMLDocument("").body;
                return body.innerHTML = "<form></form><form></form>",
                2 === body.childNodes.length
            }(),
            jQuery.parseHTML = function(data, context, keepScripts) {
                if ("string" != typeof data)
                    return [];
                "boolean" == typeof context && (keepScripts = context,
                context = !1);
                var base, parsed, scripts;
                return context || (support.createHTMLDocument ? ((base = (context = document.implementation.createHTMLDocument("")).createElement("base")).href = document.location.href,
                context.head.appendChild(base)) : context = document),
                parsed = rsingleTag.exec(data),
                scripts = !keepScripts && [],
                parsed ? [context.createElement(parsed[1])] : (parsed = buildFragment([data], context, scripts),
                scripts && scripts.length && jQuery(scripts).remove(),
                jQuery.merge([], parsed.childNodes))
            }
            ,
            jQuery.fn.load = function(url, params, callback) {
                var selector, type, response, self = this, off = url.indexOf(" ");
                return off > -1 && (selector = stripAndCollapse(url.slice(off)),
                url = url.slice(0, off)),
                isFunction(params) ? (callback = params,
                params = void 0) : params && "object" == typeof params && (type = "POST"),
                self.length > 0 && jQuery.ajax({
                    url: url,
                    type: type || "GET",
                    dataType: "html",
                    data: params
                }).done(function(responseText) {
                    response = arguments,
                    self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
                }).always(callback && function(jqXHR, status) {
                    self.each(function() {
                        callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
                    })
                }
                ),
                this
            }
            ,
            jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
                jQuery.fn[type] = function(fn) {
                    return this.on(type, fn)
                }
            }),
            jQuery.expr.pseudos.animated = function(elem) {
                return jQuery.grep(jQuery.timers, function(fn) {
                    return elem === fn.elem
                }).length
            }
            ,
            jQuery.offset = {
                setOffset: function(elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
                    "static" === position && (elem.style.position = "relative"),
                    curOffset = curElem.offset(),
                    curCSSTop = jQuery.css(elem, "top"),
                    curCSSLeft = jQuery.css(elem, "left"),
                    ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1 ? (curTop = (curPosition = curElem.position()).top,
                    curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0,
                    curLeft = parseFloat(curCSSLeft) || 0),
                    isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))),
                    null != options.top && (props.top = options.top - curOffset.top + curTop),
                    null != options.left && (props.left = options.left - curOffset.left + curLeft),
                    "using"in options ? options.using.call(elem, props) : curElem.css(props)
                }
            },
            jQuery.fn.extend({
                offset: function(options) {
                    if (arguments.length)
                        return void 0 === options ? this : this.each(function(i) {
                            jQuery.offset.setOffset(this, options, i)
                        });
                    var rect, win, elem = this[0];
                    if (elem)
                        return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(),
                        win = elem.ownerDocument.defaultView,
                        {
                            top: rect.top + win.pageYOffset,
                            left: rect.left + win.pageXOffset
                        }) : {
                            top: 0,
                            left: 0
                        }
                },
                position: function() {
                    if (this[0]) {
                        var offsetParent, offset, doc, elem = this[0], parentOffset = {
                            top: 0,
                            left: 0
                        };
                        if ("fixed" === jQuery.css(elem, "position"))
                            offset = elem.getBoundingClientRect();
                        else {
                            for (offset = this.offset(),
                            doc = elem.ownerDocument,
                            offsetParent = elem.offsetParent || doc.documentElement; offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && "static" === jQuery.css(offsetParent, "position"); )
                                offsetParent = offsetParent.parentNode;
                            offsetParent && offsetParent !== elem && 1 === offsetParent.nodeType && ((parentOffset = jQuery(offsetParent).offset()).top += jQuery.css(offsetParent, "borderTopWidth", !0),
                            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", !0))
                        }
                        return {
                            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map(function() {
                        for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); )
                            offsetParent = offsetParent.offsetParent;
                        return offsetParent || documentElement
                    })
                }
            }),
            jQuery.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(method, prop) {
                var top = "pageYOffset" === prop;
                jQuery.fn[method] = function(val) {
                    return access(this, function(elem, method, val) {
                        var win;
                        if (isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView),
                        void 0 === val)
                            return win ? win[prop] : elem[method];
                        win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val
                    }, method, val, arguments.length)
                }
            }),
            jQuery.each(["top", "left"], function(i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
                    if (computed)
                        return computed = curCSS(elem, prop),
                        rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
                })
            }),
            jQuery.each({
                Height: "height",
                Width: "width"
            }, function(name, type) {
                jQuery.each({
                    padding: "inner" + name,
                    content: type,
                    "": "outer" + name
                }, function(defaultExtra, funcName) {
                    jQuery.fn[funcName] = function(margin, value) {
                        var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin)
                          , extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                        return access(this, function(elem, type, value) {
                            var doc;
                            return isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement,
                            Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                        }, type, chainable ? margin : void 0, chainable)
                    }
                })
            }),
            jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
                jQuery.fn[name] = function(data, fn) {
                    return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
                }
            }),
            jQuery.fn.extend({
                hover: function(fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
                }
            }),
            jQuery.fn.extend({
                bind: function(types, data, fn) {
                    return this.on(types, null, data, fn)
                },
                unbind: function(types, fn) {
                    return this.off(types, null, fn)
                },
                delegate: function(selector, types, data, fn) {
                    return this.on(types, selector, data, fn)
                },
                undelegate: function(selector, types, fn) {
                    return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
                }
            }),
            jQuery.proxy = function(fn, context) {
                var tmp, args, proxy;
                if ("string" == typeof context && (tmp = fn[context],
                context = fn,
                fn = tmp),
                isFunction(fn))
                    return args = slice.call(arguments, 2),
                    proxy = function() {
                        return fn.apply(context || this, args.concat(slice.call(arguments)))
                    }
                    ,
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++,
                    proxy
            }
            ,
            jQuery.holdReady = function(hold) {
                hold ? jQuery.readyWait++ : jQuery.ready(!0)
            }
            ,
            jQuery.isArray = Array.isArray,
            jQuery.parseJSON = JSON.parse,
            jQuery.nodeName = nodeName,
            jQuery.isFunction = isFunction,
            jQuery.isWindow = isWindow,
            jQuery.camelCase = camelCase,
            jQuery.type = toType,
            jQuery.now = Date.now,
            jQuery.isNumeric = function(obj) {
                var type = jQuery.type(obj);
                return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj))
            }
            ,
            "function" == typeof define && define.amd && define("jquery", [], function() {
                return jQuery
            });
            var _jQuery = window.jQuery
              , _$ = window.$;
            return jQuery.noConflict = function(deep) {
                return window.$ === jQuery && (window.$ = _$),
                deep && window.jQuery === jQuery && (window.jQuery = _jQuery),
                jQuery
            }
            ,
            noGlobal || (window.jQuery = window.$ = jQuery),
            jQuery
        })
    }
    , {}],
    11: [function(require, module, exports) {
        !function(window, name, fn) {
            "object" == typeof module && module && "object" == typeof module.exports ? module.exports = fn : (window.jRespond = fn,
            "function" == typeof define && define.amd && define("jRespond", [], function(module) {
                return fn
            }))
        }(this, 0, function(win, doc, undefined) {
            "use strict";
            return function(breakpoints) {
                var mediaListeners = []
                  , mediaInit = []
                  , mediaBreakpoints = breakpoints
                  , curr = ""
                  , prev = ""
                  , resizeW = 0
                  , resizeTmrSpd = 500
                  , winWidth = function() {
                    return "number" != typeof window.innerWidth ? 0 !== document.documentElement.clientWidth ? document.documentElement.clientWidth : document.body.clientWidth : window.innerWidth
                }
                  , addFunction = function(elm) {
                    if (void 0 === elm.length)
                        addToStack(elm);
                    else
                        for (var i = 0; i < elm.length; i++)
                            addToStack(elm[i])
                }
                  , addToStack = function(elm) {
                    var brkpt = elm.breakpoint
                      , entr = elm.enter || void 0;
                    mediaListeners.push(elm),
                    mediaInit.push(!1),
                    testForCurr(brkpt) && (void 0 !== entr && entr.call(null, {
                        entering: curr,
                        exiting: prev
                    }),
                    mediaInit[mediaListeners.length - 1] = !0)
                }
                  , cycleThrough = function() {
                    for (var enterArray = [], exitArray = [], i = 0; i < mediaListeners.length; i++) {
                        var brkpt = mediaListeners[i].breakpoint
                          , entr = mediaListeners[i].enter || void 0
                          , exit = mediaListeners[i].exit || void 0;
                        "*" === brkpt ? (void 0 !== entr && enterArray.push(entr),
                        void 0 !== exit && exitArray.push(exit)) : testForCurr(brkpt) ? (void 0 === entr || mediaInit[i] || enterArray.push(entr),
                        mediaInit[i] = !0) : (void 0 !== exit && mediaInit[i] && exitArray.push(exit),
                        mediaInit[i] = !1)
                    }
                    for (var eventObject = {
                        entering: curr,
                        exiting: prev
                    }, j = 0; j < exitArray.length; j++)
                        exitArray[j].call(null, eventObject);
                    for (var k = 0; k < enterArray.length; k++)
                        enterArray[k].call(null, eventObject)
                }
                  , returnBreakpoint = function(width) {
                    for (var foundBrkpt = !1, i = 0; i < mediaBreakpoints.length; i++)
                        if (width >= mediaBreakpoints[i].enter && width <= mediaBreakpoints[i].exit) {
                            foundBrkpt = !0;
                            break
                        }
                    foundBrkpt && curr !== mediaBreakpoints[i].label ? (prev = curr,
                    curr = mediaBreakpoints[i].label,
                    cycleThrough()) : foundBrkpt || "" === curr || (curr = "",
                    cycleThrough())
                }
                  , testForCurr = function(elm) {
                    if ("object" == typeof elm) {
                        if (elm.join().indexOf(curr) >= 0)
                            return !0
                    } else {
                        if ("*" === elm)
                            return !0;
                        if ("string" == typeof elm && curr === elm)
                            return !0
                    }
                }
                  , checkResize = function() {
                    var w = winWidth();
                    w !== resizeW ? (resizeTmrSpd = 100,
                    returnBreakpoint(w)) : resizeTmrSpd = 500,
                    resizeW = w,
                    setTimeout(checkResize, resizeTmrSpd)
                };
                return checkResize(),
                {
                    addFunc: function(elm) {
                        addFunction(elm)
                    },
                    getBreakpoint: function() {
                        return curr
                    }
                }
            }
        }(0, this.document))
    }
    , {}],
    12: [function(require, module, exports) {
        !function(factory) {
            var registeredInModuleLoader = !1;
            if ("function" == typeof define && define.amd && (define(factory),
            registeredInModuleLoader = !0),
            "object" == typeof exports && (module.exports = factory(),
            registeredInModuleLoader = !0),
            !registeredInModuleLoader) {
                var OldCookies = window.Cookies
                  , api = window.Cookies = factory();
                api.noConflict = function() {
                    return window.Cookies = OldCookies,
                    api
                }
            }
        }(function() {
            function extend() {
                for (var i = 0, result = {}; i < arguments.length; i++) {
                    var attributes = arguments[i];
                    for (var key in attributes)
                        result[key] = attributes[key]
                }
                return result
            }
            function init(converter) {
                function api(key, value, attributes) {
                    var result;
                    if ("undefined" != typeof document) {
                        if (arguments.length > 1) {
                            if ("number" == typeof (attributes = extend({
                                path: "/"
                            }, api.defaults, attributes)).expires) {
                                var expires = new Date;
                                expires.setMilliseconds(expires.getMilliseconds() + 864e5 * attributes.expires),
                                attributes.expires = expires
                            }
                            attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
                            try {
                                result = JSON.stringify(value),
                                /^[\{\[]/.test(result) && (value = result)
                            } catch (e) {}
                            value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent),
                            key = (key = (key = encodeURIComponent(String(key))).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)).replace(/[\(\)]/g, escape);
                            var stringifiedAttributes = "";
                            for (var attributeName in attributes)
                                attributes[attributeName] && (stringifiedAttributes += "; " + attributeName,
                                !0 !== attributes[attributeName] && (stringifiedAttributes += "=" + attributes[attributeName]));
                            return document.cookie = key + "=" + value + stringifiedAttributes
                        }
                        key || (result = {});
                        for (var cookies = document.cookie ? document.cookie.split("; ") : [], rdecode = /(%[0-9A-Z]{2})+/g, i = 0; i < cookies.length; i++) {
                            var parts = cookies[i].split("=")
                              , cookie = parts.slice(1).join("=");
                            '"' === cookie.charAt(0) && (cookie = cookie.slice(1, -1));
                            try {
                                var name = parts[0].replace(rdecode, decodeURIComponent);
                                if (cookie = converter.read ? converter.read(cookie, name) : converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent),
                                this.json)
                                    try {
                                        cookie = JSON.parse(cookie)
                                    } catch (e) {}
                                if (key === name) {
                                    result = cookie;
                                    break
                                }
                                key || (result[name] = cookie)
                            } catch (e) {}
                        }
                        return result
                    }
                }
                return api.set = api,
                api.get = function(key) {
                    return api.call(api, key)
                }
                ,
                api.getJSON = function() {
                    return api.apply({
                        json: !0
                    }, [].slice.call(arguments))
                }
                ,
                api.defaults = {},
                api.remove = function(key, attributes) {
                    api(key, "", extend(attributes, {
                        expires: -1
                    }))
                }
                ,
                api.withConverter = init,
                api
            }
            return init(function() {})
        })
    }
    , {}],
    13: [function(require, module, exports) {
        !function(window, factory) {
            var lazySizes = factory(window, window.document);
            window.lazySizes = lazySizes,
            "object" == typeof module && module.exports && (module.exports = lazySizes)
        }(window, function(window, document) {
            "use strict";
            if (document.getElementsByClassName) {
                var lazysizes, lazySizesConfig, docElem = document.documentElement, Date = window.Date, supportPicture = window.HTMLPictureElement, addEventListener = window.addEventListener, setTimeout = window.setTimeout, requestAnimationFrame = window.requestAnimationFrame || setTimeout, requestIdleCallback = window.requestIdleCallback, regPicture = /^picture$/i, loadEvents = ["load", "error", "lazyincluded", "_lazyloaded"], regClassCache = {}, forEach = Array.prototype.forEach, hasClass = function(ele, cls) {
                    return regClassCache[cls] || (regClassCache[cls] = new RegExp("(\\s|^)" + cls + "(\\s|$)")),
                    regClassCache[cls].test(ele.getAttribute("class") || "") && regClassCache[cls]
                }, addClass = function(ele, cls) {
                    hasClass(ele, cls) || ele.setAttribute("class", (ele.getAttribute("class") || "").trim() + " " + cls)
                }, removeClass = function(ele, cls) {
                    var reg;
                    (reg = hasClass(ele, cls)) && ele.setAttribute("class", (ele.getAttribute("class") || "").replace(reg, " "))
                }, addRemoveLoadEvents = function(dom, fn, add) {
                    var action = add ? "addEventListener" : "removeEventListener";
                    add && addRemoveLoadEvents(dom, fn),
                    loadEvents.forEach(function(evt) {
                        dom[action](evt, fn)
                    })
                }, triggerEvent = function(elem, name, detail, noBubbles, noCancelable) {
                    var event = document.createEvent("Event");
                    return detail || (detail = {}),
                    detail.instance = lazysizes,
                    event.initEvent(name, !noBubbles, !noCancelable),
                    event.detail = detail,
                    elem.dispatchEvent(event),
                    event
                }, updatePolyfill = function(el, full) {
                    var polyfill;
                    !supportPicture && (polyfill = window.picturefill || lazySizesConfig.pf) ? (full && full.src && !el.getAttribute("srcset") && el.setAttribute("srcset", full.src),
                    polyfill({
                        reevaluate: !0,
                        elements: [el]
                    })) : full && full.src && (el.src = full.src)
                }, getCSS = function(elem, style) {
                    return (getComputedStyle(elem, null) || {})[style]
                }, getWidth = function(elem, parent, width) {
                    for (width = width || elem.offsetWidth; width < lazySizesConfig.minSize && parent && !elem._lazysizesWidth; )
                        width = parent.offsetWidth,
                        parent = parent.parentNode;
                    return width
                }, rAF = function() {
                    var running, waiting, firstFns = [], secondFns = [], fns = firstFns, run = function() {
                        var runFns = fns;
                        for (fns = firstFns.length ? secondFns : firstFns,
                        running = !0,
                        waiting = !1; runFns.length; )
                            runFns.shift()();
                        running = !1
                    }, rafBatch = function(fn, queue) {
                        running && !queue ? fn.apply(this, arguments) : (fns.push(fn),
                        waiting || (waiting = !0,
                        (document.hidden ? setTimeout : requestAnimationFrame)(run)))
                    };
                    return rafBatch._lsFlush = run,
                    rafBatch
                }(), rAFIt = function(fn, simple) {
                    return simple ? function() {
                        rAF(fn)
                    }
                    : function() {
                        var that = this
                          , args = arguments;
                        rAF(function() {
                            fn.apply(that, args)
                        })
                    }
                }, throttle = function(fn) {
                    var running, lastTime = 0, gDelay = lazySizesConfig.throttleDelay, rICTimeout = lazySizesConfig.ricTimeout, run = function() {
                        running = !1,
                        lastTime = Date.now(),
                        fn()
                    }, idleCallback = requestIdleCallback && rICTimeout > 49 ? function() {
                        requestIdleCallback(run, {
                            timeout: rICTimeout
                        }),
                        rICTimeout !== lazySizesConfig.ricTimeout && (rICTimeout = lazySizesConfig.ricTimeout)
                    }
                    : rAFIt(function() {
                        setTimeout(run)
                    }, !0);
                    return function(isPriority) {
                        var delay;
                        (isPriority = !0 === isPriority) && (rICTimeout = 33),
                        running || (running = !0,
                        (delay = gDelay - (Date.now() - lastTime)) < 0 && (delay = 0),
                        isPriority || delay < 9 ? idleCallback() : setTimeout(idleCallback, delay))
                    }
                }, debounce = function(func) {
                    var timeout, timestamp, run = function() {
                        timeout = null,
                        func()
                    }, later = function() {
                        var last = Date.now() - timestamp;
                        last < 99 ? setTimeout(later, 99 - last) : (requestIdleCallback || run)(run)
                    };
                    return function() {
                        timestamp = Date.now(),
                        timeout || (timeout = setTimeout(later, 99))
                    }
                };
                !function() {
                    var prop, lazySizesDefaults = {
                        lazyClass: "lazyload",
                        loadedClass: "lazyloaded",
                        loadingClass: "lazyloading",
                        preloadClass: "lazypreload",
                        errorClass: "lazyerror",
                        autosizesClass: "lazyautosizes",
                        srcAttr: "data-src",
                        srcsetAttr: "data-srcset",
                        sizesAttr: "data-sizes",
                        minSize: 40,
                        customMedia: {},
                        init: !0,
                        expFactor: 1.5,
                        hFac: .8,
                        loadMode: 2,
                        loadHidden: !0,
                        ricTimeout: 0,
                        throttleDelay: 125
                    };
                    lazySizesConfig = window.lazySizesConfig || window.lazysizesConfig || {};
                    for (prop in lazySizesDefaults)
                        prop in lazySizesConfig || (lazySizesConfig[prop] = lazySizesDefaults[prop]);
                    window.lazySizesConfig = lazySizesConfig,
                    setTimeout(function() {
                        lazySizesConfig.init && init()
                    })
                }();
                var loader = function() {
                    var preloadElems, isCompleted, resetPreloadingTimer, loadMode, started, eLvW, elvH, eLtop, eLleft, eLright, eLbottom, isBodyHidden, regImg = /^img$/i, regIframe = /^iframe$/i, supportScroll = "onscroll"in window && !/(gle|ing)bot/.test(navigator.userAgent), currentExpand = 0, isLoading = 0, lowRuns = -1, resetPreloading = function(e) {
                        isLoading--,
                        (!e || isLoading < 0 || !e.target) && (isLoading = 0)
                    }, isVisible = function(elem) {
                        return null == isBodyHidden && (isBodyHidden = "hidden" == getCSS(document.body, "visibility")),
                        isBodyHidden || "hidden" != getCSS(elem.parentNode, "visibility") && "hidden" != getCSS(elem, "visibility")
                    }, isNestedVisible = function(elem, elemExpand) {
                        var outerRect, parent = elem, visible = isVisible(elem);
                        for (eLtop -= elemExpand,
                        eLbottom += elemExpand,
                        eLleft -= elemExpand,
                        eLright += elemExpand; visible && (parent = parent.offsetParent) && parent != document.body && parent != docElem; )
                            (visible = (getCSS(parent, "opacity") || 1) > 0) && "visible" != getCSS(parent, "overflow") && (outerRect = parent.getBoundingClientRect(),
                            visible = eLright > outerRect.left && eLleft < outerRect.right && eLbottom > outerRect.top - 1 && eLtop < outerRect.bottom + 1);
                        return visible
                    }, checkElements = function() {
                        var eLlen, i, rect, autoLoadElem, loadedSomething, elemExpand, elemNegativeExpand, elemExpandVal, beforeExpandVal, defaultExpand, preloadExpand, hFac, lazyloadElems = lazysizes.elements;
                        if ((loadMode = lazySizesConfig.loadMode) && isLoading < 8 && (eLlen = lazyloadElems.length)) {
                            for (i = 0,
                            lowRuns++,
                            defaultExpand = !lazySizesConfig.expand || lazySizesConfig.expand < 1 ? docElem.clientHeight > 500 && docElem.clientWidth > 500 ? 500 : 370 : lazySizesConfig.expand,
                            lazysizes._defEx = defaultExpand,
                            preloadExpand = defaultExpand * lazySizesConfig.expFactor,
                            hFac = lazySizesConfig.hFac,
                            isBodyHidden = null,
                            currentExpand < preloadExpand && isLoading < 1 && lowRuns > 2 && loadMode > 2 && !document.hidden ? (currentExpand = preloadExpand,
                            lowRuns = 0) : currentExpand = loadMode > 1 && lowRuns > 1 && isLoading < 6 ? defaultExpand : 0; i < eLlen; i++)
                                if (lazyloadElems[i] && !lazyloadElems[i]._lazyRace)
                                    if (supportScroll)
                                        if ((elemExpandVal = lazyloadElems[i].getAttribute("data-expand")) && (elemExpand = 1 * elemExpandVal) || (elemExpand = currentExpand),
                                        beforeExpandVal !== elemExpand && (eLvW = innerWidth + elemExpand * hFac,
                                        elvH = innerHeight + elemExpand,
                                        elemNegativeExpand = -1 * elemExpand,
                                        beforeExpandVal = elemExpand),
                                        rect = lazyloadElems[i].getBoundingClientRect(),
                                        (eLbottom = rect.bottom) >= elemNegativeExpand && (eLtop = rect.top) <= elvH && (eLright = rect.right) >= elemNegativeExpand * hFac && (eLleft = rect.left) <= eLvW && (eLbottom || eLright || eLleft || eLtop) && (lazySizesConfig.loadHidden || isVisible(lazyloadElems[i])) && (isCompleted && isLoading < 3 && !elemExpandVal && (loadMode < 3 || lowRuns < 4) || isNestedVisible(lazyloadElems[i], elemExpand))) {
                                            if (unveilElement(lazyloadElems[i]),
                                            loadedSomething = !0,
                                            isLoading > 9)
                                                break
                                        } else
                                            !loadedSomething && isCompleted && !autoLoadElem && isLoading < 4 && lowRuns < 4 && loadMode > 2 && (preloadElems[0] || lazySizesConfig.preloadAfterLoad) && (preloadElems[0] || !elemExpandVal && (eLbottom || eLright || eLleft || eLtop || "auto" != lazyloadElems[i].getAttribute(lazySizesConfig.sizesAttr))) && (autoLoadElem = preloadElems[0] || lazyloadElems[i]);
                                    else
                                        unveilElement(lazyloadElems[i]);
                            autoLoadElem && !loadedSomething && unveilElement(autoLoadElem)
                        }
                    }, throttledCheckElements = throttle(checkElements), switchLoadingClass = function(e) {
                        var elem = e.target;
                        elem._lazyCache ? delete elem._lazyCache : (resetPreloading(e),
                        addClass(elem, lazySizesConfig.loadedClass),
                        removeClass(elem, lazySizesConfig.loadingClass),
                        addRemoveLoadEvents(elem, rafSwitchLoadingClass),
                        triggerEvent(elem, "lazyloaded"))
                    }, rafedSwitchLoadingClass = rAFIt(switchLoadingClass), rafSwitchLoadingClass = function(e) {
                        rafedSwitchLoadingClass({
                            target: e.target
                        })
                    }, changeIframeSrc = function(elem, src) {
                        try {
                            elem.contentWindow.location.replace(src)
                        } catch (e) {
                            elem.src = src
                        }
                    }, handleSources = function(source) {
                        var customMedia, sourceSrcset = source.getAttribute(lazySizesConfig.srcsetAttr);
                        (customMedia = lazySizesConfig.customMedia[source.getAttribute("data-media") || source.getAttribute("media")]) && source.setAttribute("media", customMedia),
                        sourceSrcset && source.setAttribute("srcset", sourceSrcset)
                    }, lazyUnveil = rAFIt(function(elem, detail, isAuto, sizes, isImg) {
                        var src, srcset, parent, isPicture, event, firesLoad;
                        (event = triggerEvent(elem, "lazybeforeunveil", detail)).defaultPrevented || (sizes && (isAuto ? addClass(elem, lazySizesConfig.autosizesClass) : elem.setAttribute("sizes", sizes)),
                        srcset = elem.getAttribute(lazySizesConfig.srcsetAttr),
                        src = elem.getAttribute(lazySizesConfig.srcAttr),
                        isImg && (isPicture = (parent = elem.parentNode) && regPicture.test(parent.nodeName || "")),
                        firesLoad = detail.firesLoad || "src"in elem && (srcset || src || isPicture),
                        event = {
                            target: elem
                        },
                        addClass(elem, lazySizesConfig.loadingClass),
                        firesLoad && (clearTimeout(resetPreloadingTimer),
                        resetPreloadingTimer = setTimeout(resetPreloading, 2500),
                        addRemoveLoadEvents(elem, rafSwitchLoadingClass, !0)),
                        isPicture && forEach.call(parent.getElementsByTagName("source"), handleSources),
                        srcset ? elem.setAttribute("srcset", srcset) : src && !isPicture && (regIframe.test(elem.nodeName) ? changeIframeSrc(elem, src) : elem.src = src),
                        isImg && (srcset || isPicture) && updatePolyfill(elem, {
                            src: src
                        })),
                        elem._lazyRace && delete elem._lazyRace,
                        removeClass(elem, lazySizesConfig.lazyClass),
                        rAF(function() {
                            (!firesLoad || elem.complete && elem.naturalWidth > 1) && (switchLoadingClass(event),
                            elem._lazyCache = !0,
                            setTimeout(function() {
                                "_lazyCache"in elem && delete elem._lazyCache
                            }, 9))
                        }, !0)
                    }), unveilElement = function(elem) {
                        var detail, isImg = regImg.test(elem.nodeName), sizes = isImg && (elem.getAttribute(lazySizesConfig.sizesAttr) || elem.getAttribute("sizes")), isAuto = "auto" == sizes;
                        (!isAuto && isCompleted || !isImg || !elem.getAttribute("src") && !elem.srcset || elem.complete || hasClass(elem, lazySizesConfig.errorClass) || !hasClass(elem, lazySizesConfig.lazyClass)) && (detail = triggerEvent(elem, "lazyunveilread").detail,
                        isAuto && autoSizer.updateElem(elem, !0, elem.offsetWidth),
                        elem._lazyRace = !0,
                        isLoading++,
                        lazyUnveil(elem, detail, isAuto, sizes, isImg))
                    }, onload = function() {
                        if (!isCompleted)
                            if (Date.now() - started < 999)
                                setTimeout(onload, 999);
                            else {
                                var afterScroll = debounce(function() {
                                    lazySizesConfig.loadMode = 3,
                                    throttledCheckElements()
                                });
                                isCompleted = !0,
                                lazySizesConfig.loadMode = 3,
                                throttledCheckElements(),
                                addEventListener("scroll", function() {
                                    3 == lazySizesConfig.loadMode && (lazySizesConfig.loadMode = 2),
                                    afterScroll()
                                }, !0)
                            }
                    };
                    return {
                        _: function() {
                            started = Date.now(),
                            lazysizes.elements = document.getElementsByClassName(lazySizesConfig.lazyClass),
                            preloadElems = document.getElementsByClassName(lazySizesConfig.lazyClass + " " + lazySizesConfig.preloadClass),
                            addEventListener("scroll", throttledCheckElements, !0),
                            addEventListener("resize", throttledCheckElements, !0),
                            window.MutationObserver ? new MutationObserver(throttledCheckElements).observe(docElem, {
                                childList: !0,
                                subtree: !0,
                                attributes: !0
                            }) : (docElem.addEventListener("DOMNodeInserted", throttledCheckElements, !0),
                            docElem.addEventListener("DOMAttrModified", throttledCheckElements, !0),
                            setInterval(throttledCheckElements, 999)),
                            addEventListener("hashchange", throttledCheckElements, !0),
                            ["focus", "mouseover", "click", "load", "transitionend", "animationend", "webkitAnimationEnd"].forEach(function(name) {
                                document.addEventListener(name, throttledCheckElements, !0)
                            }),
                            /d$|^c/.test(document.readyState) ? onload() : (addEventListener("load", onload),
                            document.addEventListener("DOMContentLoaded", throttledCheckElements),
                            setTimeout(onload, 2e4)),
                            lazysizes.elements.length ? (checkElements(),
                            rAF._lsFlush()) : throttledCheckElements()
                        },
                        checkElems: throttledCheckElements,
                        unveil: unveilElement
                    }
                }()
                  , autoSizer = function() {
                    var autosizesElems, sizeElement = rAFIt(function(elem, parent, event, width) {
                        var sources, i, len;
                        if (elem._lazysizesWidth = width,
                        width += "px",
                        elem.setAttribute("sizes", width),
                        regPicture.test(parent.nodeName || ""))
                            for (i = 0,
                            len = (sources = parent.getElementsByTagName("source")).length; i < len; i++)
                                sources[i].setAttribute("sizes", width);
                        event.detail.dataAttr || updatePolyfill(elem, event.detail)
                    }), getSizeElement = function(elem, dataAttr, width) {
                        var event, parent = elem.parentNode;
                        parent && (width = getWidth(elem, parent, width),
                        (event = triggerEvent(elem, "lazybeforesizes", {
                            width: width,
                            dataAttr: !!dataAttr
                        })).defaultPrevented || (width = event.detail.width) && width !== elem._lazysizesWidth && sizeElement(elem, parent, event, width))
                    }, debouncedUpdateElementsSizes = debounce(function() {
                        var i, len = autosizesElems.length;
                        if (len)
                            for (i = 0; i < len; i++)
                                getSizeElement(autosizesElems[i])
                    });
                    return {
                        _: function() {
                            autosizesElems = document.getElementsByClassName(lazySizesConfig.autosizesClass),
                            addEventListener("resize", debouncedUpdateElementsSizes)
                        },
                        checkElems: debouncedUpdateElementsSizes,
                        updateElem: getSizeElement
                    }
                }()
                  , init = function() {
                    init.i || (init.i = !0,
                    autoSizer._(),
                    loader._())
                };
                return lazysizes = {
                    cfg: lazySizesConfig,
                    autoSizer: autoSizer,
                    loader: loader,
                    init: init,
                    uP: updatePolyfill,
                    aC: addClass,
                    rC: removeClass,
                    hC: hasClass,
                    fire: triggerEvent,
                    gW: getWidth,
                    rAF: rAF
                }
            }
        })
    }
    , {}],
    14: [function(require, module, exports) {
        !function(global, factory) {
            void 0 !== module && "object" == typeof module.exports ? module.exports = factory() : "function" == typeof define && define.amd ? define("litelog", factory) : global.Logger = factory()
        }(window, function() {
            "use strict";
            function Logger(module, showline) {
                if (!(this instanceof Logger))
                    return Logger.l.apply(null, arguments);
                "string" == typeof module ? this.modulename = module : "boolean" == typeof module ? this.modulename = module ? _modulenamefromstack() : "" : (Logger.w("Invalid 'module name' for logger.", "use 'default'"),
                this.modulename = "*"),
                instances.push(this),
                this.showline = !!showline,
                this.mute(_mute),
                this.level(_level)
            }
            function _wrap(level) {
                return function() {
                    var args = Array.prototype.slice.call(arguments, 0)
                      , _current_level = null;
                    if (this instanceof Logger) {
                        if (this._mute)
                            return !1;
                        args.unshift(this.showline),
                        args.unshift(this.modulename),
                        _current_level = this._level
                    } else {
                        if (_mute)
                            return !1;
                        args.unshift(!1),
                        args.unshift(void 0),
                        _current_level = _level
                    }
                    return !(null !== _current_level && !isNaN(_current_level) && Levels[level] > _current_level) && (args.unshift(level),
                    Logger._write.apply(null, args))
                }
            }
            function _getstack() {
                var error = null;
                if (window.Error)
                    error = new Error("nothing");
                else
                    try {
                        __unexisting_function_42__()
                    } catch (e) {
                        error = e
                    }
                return error.stack
            }
            function _getlinenumber() {
                return _getstack().split("\n")[5].match(/([^\/]+$)/)[1].split(":")[1]
            }
            function _modulenamefromstack() {
                var fileparts = _getstack().split("\n")[4].match(/([^\/]+$)/)[1].split(":")[0].split(".");
                return fileparts.pop(),
                fileparts.join(".")
            }
            var instances = []
              , _mute = !1
              , Levels = {
                error: 1,
                warn: 2,
                info: 3,
                log: 4,
                debug: 4
            }
              , _level = Levels.log;
            Logger.prototype = {
                e: _wrap("error"),
                w: _wrap("warn"),
                i: _wrap("info"),
                l: _wrap("log"),
                d: _wrap("debug"),
                mute: function(mute, all) {
                    if (this instanceof Logger)
                        return this._mute = !!mute,
                        this;
                    if (_mute = !!mute,
                    !0 === all)
                        for (var log, i = 0; log = instances[i]; i++)
                            log.mute(_mute);
                    return Logger
                },
                level: function(lvl, all) {
                    if (0 === arguments.length)
                        return this instanceof Logger ? this._level : _level;
                    if (lvl = parseInt(lvl, 10),
                    isNaN(lvl))
                        throw "No valid 'level' specified: " + lvl;
                    if (this instanceof Logger)
                        return this._level = lvl,
                        this;
                    if (_level = lvl,
                    !0 === all)
                        for (var log, i = 0; log = instances[i]; i++)
                            log.level(_level);
                    return Logger
                }
            },
            Logger._write = function(level, module, showline) {
                var args = Array.prototype.slice.call(arguments, 3);
                if (module) {
                    var module_str = "";
                    module_str = showline ? "[" + module + ":" + _getlinenumber() + "]" : "[" + module + "]",
                    "string" == typeof args[0] ? args[0] = module_str + " " + args[0] : args.unshift(module_str)
                }
                return args.unshift(level),
                Logger.__write_stream__.apply(Logger, args)
            }
            ,
            Logger.__write_stream__ = function() {
                var args = Array.prototype.slice.call(arguments)
                  , level = args.shift();
                return "undefined" != typeof console && (!console[level] && console.log && (level = "log"),
                console[level] && console[level].apply && console[level].apply(console, args))
            }
            ,
            Logger.prototype.error = Logger.prototype.e,
            Logger.prototype.warn = Logger.prototype.w,
            Logger.prototype.info = Logger.prototype.i,
            Logger.prototype.log = Logger.prototype.l,
            Logger.prototype.debug = Logger.prototype.d;
            for (var fn in Logger.prototype)
                Logger.prototype.hasOwnProperty(fn) && (Logger[fn] = Logger.prototype[fn]);
            return Logger
        })
    }
    , {}],
    15: [function(require, module, exports) {
        (function(global) {
            (function() {
                function apply(func, thisArg, args) {
                    switch (args.length) {
                    case 0:
                        return func.call(thisArg);
                    case 1:
                        return func.call(thisArg, args[0]);
                    case 2:
                        return func.call(thisArg, args[0], args[1]);
                    case 3:
                        return func.call(thisArg, args[0], args[1], args[2])
                    }
                    return func.apply(thisArg, args)
                }
                function arrayAggregator(array, setter, iteratee, accumulator) {
                    for (var index = -1, length = null == array ? 0 : array.length; ++index < length; ) {
                        var value = array[index];
                        setter(accumulator, value, iteratee(value), array)
                    }
                    return accumulator
                }
                function arrayEach(array, iteratee) {
                    for (var index = -1, length = null == array ? 0 : array.length; ++index < length && !1 !== iteratee(array[index], index, array); )
                        ;
                    return array
                }
                function arrayEachRight(array, iteratee) {
                    for (var length = null == array ? 0 : array.length; length-- && !1 !== iteratee(array[length], length, array); )
                        ;
                    return array
                }
                function arrayEvery(array, predicate) {
                    for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
                        if (!predicate(array[index], index, array))
                            return !1;
                    return !0
                }
                function arrayFilter(array, predicate) {
                    for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                        var value = array[index];
                        predicate(value, index, array) && (result[resIndex++] = value)
                    }
                    return result
                }
                function arrayIncludes(array, value) {
                    return !!(null == array ? 0 : array.length) && baseIndexOf(array, value, 0) > -1
                }
                function arrayIncludesWith(array, value, comparator) {
                    for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
                        if (comparator(value, array[index]))
                            return !0;
                    return !1
                }
                function arrayMap(array, iteratee) {
                    for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length; )
                        result[index] = iteratee(array[index], index, array);
                    return result
                }
                function arrayPush(array, values) {
                    for (var index = -1, length = values.length, offset = array.length; ++index < length; )
                        array[offset + index] = values[index];
                    return array
                }
                function arrayReduce(array, iteratee, accumulator, initAccum) {
                    var index = -1
                      , length = null == array ? 0 : array.length;
                    for (initAccum && length && (accumulator = array[++index]); ++index < length; )
                        accumulator = iteratee(accumulator, array[index], index, array);
                    return accumulator
                }
                function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                    var length = null == array ? 0 : array.length;
                    for (initAccum && length && (accumulator = array[--length]); length--; )
                        accumulator = iteratee(accumulator, array[length], length, array);
                    return accumulator
                }
                function arraySome(array, predicate) {
                    for (var index = -1, length = null == array ? 0 : array.length; ++index < length; )
                        if (predicate(array[index], index, array))
                            return !0;
                    return !1
                }
                function asciiToArray(string) {
                    return string.split("")
                }
                function asciiWords(string) {
                    return string.match(reAsciiWord) || []
                }
                function baseFindKey(collection, predicate, eachFunc) {
                    var result;
                    return eachFunc(collection, function(value, key, collection) {
                        if (predicate(value, key, collection))
                            return result = key,
                            !1
                    }),
                    result
                }
                function baseFindIndex(array, predicate, fromIndex, fromRight) {
                    for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
                        if (predicate(array[index], index, array))
                            return index;
                    return -1
                }
                function baseIndexOf(array, value, fromIndex) {
                    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
                }
                function baseIndexOfWith(array, value, fromIndex, comparator) {
                    for (var index = fromIndex - 1, length = array.length; ++index < length; )
                        if (comparator(array[index], value))
                            return index;
                    return -1
                }
                function baseIsNaN(value) {
                    return value !== value
                }
                function baseMean(array, iteratee) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseSum(array, iteratee) / length : NAN
                }
                function baseProperty(key) {
                    return function(object) {
                        return null == object ? undefined : object[key]
                    }
                }
                function basePropertyOf(object) {
                    return function(key) {
                        return null == object ? undefined : object[key]
                    }
                }
                function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                    return eachFunc(collection, function(value, index, collection) {
                        accumulator = initAccum ? (initAccum = !1,
                        value) : iteratee(accumulator, value, index, collection)
                    }),
                    accumulator
                }
                function baseSortBy(array, comparer) {
                    var length = array.length;
                    for (array.sort(comparer); length--; )
                        array[length] = array[length].value;
                    return array
                }
                function baseSum(array, iteratee) {
                    for (var result, index = -1, length = array.length; ++index < length; ) {
                        var current = iteratee(array[index]);
                        current !== undefined && (result = result === undefined ? current : result + current)
                    }
                    return result
                }
                function baseTimes(n, iteratee) {
                    for (var index = -1, result = Array(n); ++index < n; )
                        result[index] = iteratee(index);
                    return result
                }
                function baseToPairs(object, props) {
                    return arrayMap(props, function(key) {
                        return [key, object[key]]
                    })
                }
                function baseUnary(func) {
                    return function(value) {
                        return func(value)
                    }
                }
                function baseValues(object, props) {
                    return arrayMap(props, function(key) {
                        return object[key]
                    })
                }
                function cacheHas(cache, key) {
                    return cache.has(key)
                }
                function charsStartIndex(strSymbols, chrSymbols) {
                    for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
                        ;
                    return index
                }
                function charsEndIndex(strSymbols, chrSymbols) {
                    for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
                        ;
                    return index
                }
                function countHolders(array, placeholder) {
                    for (var length = array.length, result = 0; length--; )
                        array[length] === placeholder && ++result;
                    return result
                }
                function escapeStringChar(chr) {
                    return "\\" + stringEscapes[chr]
                }
                function getValue(object, key) {
                    return null == object ? undefined : object[key]
                }
                function hasUnicode(string) {
                    return reHasUnicode.test(string)
                }
                function hasUnicodeWord(string) {
                    return reHasUnicodeWord.test(string)
                }
                function iteratorToArray(iterator) {
                    for (var data, result = []; !(data = iterator.next()).done; )
                        result.push(data.value);
                    return result
                }
                function mapToArray(map) {
                    var index = -1
                      , result = Array(map.size);
                    return map.forEach(function(value, key) {
                        result[++index] = [key, value]
                    }),
                    result
                }
                function overArg(func, transform) {
                    return function(arg) {
                        return func(transform(arg))
                    }
                }
                function replaceHolders(array, placeholder) {
                    for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                        var value = array[index];
                        value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER,
                        result[resIndex++] = index)
                    }
                    return result
                }
                function setToArray(set) {
                    var index = -1
                      , result = Array(set.size);
                    return set.forEach(function(value) {
                        result[++index] = value
                    }),
                    result
                }
                function setToPairs(set) {
                    var index = -1
                      , result = Array(set.size);
                    return set.forEach(function(value) {
                        result[++index] = [value, value]
                    }),
                    result
                }
                function strictIndexOf(array, value, fromIndex) {
                    for (var index = fromIndex - 1, length = array.length; ++index < length; )
                        if (array[index] === value)
                            return index;
                    return -1
                }
                function strictLastIndexOf(array, value, fromIndex) {
                    for (var index = fromIndex + 1; index--; )
                        if (array[index] === value)
                            return index;
                    return index
                }
                function stringSize(string) {
                    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
                }
                function stringToArray(string) {
                    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string)
                }
                function unicodeSize(string) {
                    for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); )
                        ++result;
                    return result
                }
                function unicodeToArray(string) {
                    return string.match(reUnicode) || []
                }
                function unicodeWords(string) {
                    return string.match(reUnicodeWord) || []
                }
                var undefined, LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e308, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrim = /^\s+|\s+$/g, reTrimStart = /^\s+/, reTrimEnd = /\s+$/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsComboRange = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff", rsBreakRange = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsLower = "[a-z\\xdf-\\xf6\\xf8-\\xff]", rsMisc = "[^\\ud800-\\udfff" + rsBreakRange + "\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[A-Z\\xc0-\\xd6\\xd8-\\xde]", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", reOptMod = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?", rsSeq = "[\\ufe0e\\ufe0f]?" + reOptMod + ("(?:\\u200d(?:" + ["[^\\ud800-\\udfff]", rsRegional, rsSurrPair].join("|") + ")[\\ufe0e\\ufe0f]?" + reOptMod + ")*"), rsEmoji = "(?:" + ["[\\u2700-\\u27bf]", rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + ["[^\\ud800-\\udfff]" + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, "[\\ud800-\\udfff]"].join("|") + ")", reApos = RegExp("[']", "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+(?:['](?:d|ll|m|re|s|t|ve))?(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", "(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+(?:['](?:d|ll|m|re|s|t|ve))?", rsUpper + "+(?:['](?:D|LL|M|RE|S|T|VE))?", "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", "\\d+", rsEmoji].join("|"), "g"), reHasUnicode = RegExp("[\\u200d\\ud800-\\udfff" + rsComboRange + "\\ufe0e\\ufe0f]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], templateCounter = -1, typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0,
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0,
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
                var deburredLetters = {
                    "": "A",
                    "": "A",
                    "": "A",
                    "": "A",
                    "": "A",
                    "": "A",
                    "": "a",
                    "": "a",
                    "": "a",
                    "": "a",
                    "": "a",
                    "": "a",
                    "": "C",
                    "": "c",
                    "": "D",
                    "": "d",
                    "": "E",
                    "": "E",
                    "": "E",
                    "": "E",
                    "": "e",
                    "": "e",
                    "": "e",
                    "": "e",
                    "": "I",
                    "": "I",
                    "": "I",
                    "": "I",
                    "": "i",
                    "": "i",
                    "": "i",
                    "": "i",
                    "": "N",
                    "": "n",
                    "": "O",
                    "": "O",
                    "": "O",
                    "": "O",
                    "": "O",
                    "": "O",
                    "": "o",
                    "": "o",
                    "": "o",
                    "": "o",
                    "": "o",
                    "": "o",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "Y",
                    "": "y",
                    "": "y",
                    "": "Ae",
                    "": "ae",
                    "": "Th",
                    "": "th",
                    "": "ss",
                    "": "A",
                    "": "A",
                    "": "A",
                    "": "a",
                    "": "a",
                    "": "a",
                    "": "C",
                    "": "C",
                    "": "C",
                    "": "C",
                    "": "c",
                    "": "c",
                    "": "c",
                    "": "c",
                    "": "D",
                    "": "D",
                    "": "d",
                    "": "d",
                    "": "E",
                    "": "E",
                    "": "E",
                    "": "E",
                    "": "E",
                    "": "e",
                    "": "e",
                    "": "e",
                    "": "e",
                    "": "e",
                    "": "G",
                    "": "G",
                    "": "G",
                    "": "G",
                    "": "g",
                    "": "g",
                    "": "g",
                    "": "g",
                    "": "H",
                    "": "H",
                    "": "h",
                    "": "h",
                    "": "I",
                    "": "I",
                    "": "I",
                    "": "I",
                    "": "I",
                    "": "i",
                    "": "i",
                    "": "i",
                    "": "i",
                    "": "i",
                    "": "J",
                    "": "j",
                    "": "K",
                    "": "k",
                    "": "k",
                    "": "L",
                    "": "L",
                    "": "L",
                    "": "L",
                    "": "L",
                    "": "l",
                    "": "l",
                    "": "l",
                    "": "l",
                    "": "l",
                    "": "N",
                    "": "N",
                    "": "N",
                    "": "N",
                    "": "n",
                    "": "n",
                    "": "n",
                    "": "n",
                    "": "O",
                    "": "O",
                    "": "O",
                    "": "o",
                    "": "o",
                    "": "o",
                    "": "R",
                    "": "R",
                    "": "R",
                    "": "r",
                    "": "r",
                    "": "r",
                    "": "S",
                    "": "S",
                    "": "S",
                    "": "S",
                    "": "s",
                    "": "s",
                    "": "s",
                    "": "s",
                    "": "T",
                    "": "T",
                    "": "T",
                    "": "t",
                    "": "t",
                    "": "t",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "U",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "u",
                    "": "W",
                    "": "w",
                    "": "Y",
                    "": "y",
                    "": "Y",
                    "": "Z",
                    "": "Z",
                    "": "Z",
                    "": "z",
                    "": "z",
                    "": "z",
                    "": "IJ",
                    "": "ij",
                    "": "Oe",
                    "": "oe",
                    "": "'n",
                    "": "s"
                }
                  , htmlEscapes = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;"
                }
                  , htmlUnescapes = {
                    "&amp;": "&",
                    "&lt;": "<",
                    "&gt;": ">",
                    "&quot;": '"',
                    "&#39;": "'"
                }
                  , stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                }
                  , freeParseFloat = parseFloat
                  , freeParseInt = parseInt
                  , freeGlobal = "object" == typeof global && global && global.Object === Object && global
                  , freeSelf = "object" == typeof self && self && self.Object === Object && self
                  , root = freeGlobal || freeSelf || Function("return this")()
                  , freeExports = "object" == typeof exports && exports && !exports.nodeType && exports
                  , freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module
                  , moduleExports = freeModule && freeModule.exports === freeExports
                  , freeProcess = moduleExports && freeGlobal.process
                  , nodeUtil = function() {
                    try {
                        var types = freeModule && freeModule.require && freeModule.require("util").types;
                        return types || freeProcess && freeProcess.binding && freeProcess.binding("util")
                    } catch (e) {}
                }()
                  , nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer
                  , nodeIsDate = nodeUtil && nodeUtil.isDate
                  , nodeIsMap = nodeUtil && nodeUtil.isMap
                  , nodeIsRegExp = nodeUtil && nodeUtil.isRegExp
                  , nodeIsSet = nodeUtil && nodeUtil.isSet
                  , nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
                  , asciiSize = baseProperty("length")
                  , deburrLetter = basePropertyOf(deburredLetters)
                  , escapeHtmlChar = basePropertyOf(htmlEscapes)
                  , unescapeHtmlChar = basePropertyOf(htmlUnescapes)
                  , _ = function runInContext(context) {
                    function lodash(value) {
                        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                            if (value instanceof LodashWrapper)
                                return value;
                            if (hasOwnProperty.call(value, "__wrapped__"))
                                return wrapperClone(value)
                        }
                        return new LodashWrapper(value)
                    }
                    function baseLodash() {}
                    function LodashWrapper(value, chainAll) {
                        this.__wrapped__ = value,
                        this.__actions__ = [],
                        this.__chain__ = !!chainAll,
                        this.__index__ = 0,
                        this.__values__ = undefined
                    }
                    function LazyWrapper(value) {
                        this.__wrapped__ = value,
                        this.__actions__ = [],
                        this.__dir__ = 1,
                        this.__filtered__ = !1,
                        this.__iteratees__ = [],
                        this.__takeCount__ = MAX_ARRAY_LENGTH,
                        this.__views__ = []
                    }
                    function Hash(entries) {
                        var index = -1
                          , length = null == entries ? 0 : entries.length;
                        for (this.clear(); ++index < length; ) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }
                    function ListCache(entries) {
                        var index = -1
                          , length = null == entries ? 0 : entries.length;
                        for (this.clear(); ++index < length; ) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }
                    function MapCache(entries) {
                        var index = -1
                          , length = null == entries ? 0 : entries.length;
                        for (this.clear(); ++index < length; ) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1])
                        }
                    }
                    function SetCache(values) {
                        var index = -1
                          , length = null == values ? 0 : values.length;
                        for (this.__data__ = new MapCache; ++index < length; )
                            this.add(values[index])
                    }
                    function Stack(entries) {
                        var data = this.__data__ = new ListCache(entries);
                        this.size = data.size
                    }
                    function arrayLikeKeys(value, inherited) {
                        var isArr = isArray(value)
                          , isArg = !isArr && isArguments(value)
                          , isBuff = !isArr && !isArg && isBuffer(value)
                          , isType = !isArr && !isArg && !isBuff && isTypedArray(value)
                          , skipIndexes = isArr || isArg || isBuff || isType
                          , result = skipIndexes ? baseTimes(value.length, String) : []
                          , length = result.length;
                        for (var key in value)
                            !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
                        return result
                    }
                    function arraySample(array) {
                        var length = array.length;
                        return length ? array[baseRandom(0, length - 1)] : undefined
                    }
                    function arraySampleSize(array, n) {
                        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
                    }
                    function arrayShuffle(array) {
                        return shuffleSelf(copyArray(array))
                    }
                    function assignMergeValue(object, key, value) {
                        (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
                    }
                    function assignValue(object, key, value) {
                        var objValue = object[key];
                        hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
                    }
                    function assocIndexOf(array, key) {
                        for (var length = array.length; length--; )
                            if (eq(array[length][0], key))
                                return length;
                        return -1
                    }
                    function baseAggregator(collection, setter, iteratee, accumulator) {
                        return baseEach(collection, function(value, key, collection) {
                            setter(accumulator, value, iteratee(value), collection)
                        }),
                        accumulator
                    }
                    function baseAssign(object, source) {
                        return object && copyObject(source, keys(source), object)
                    }
                    function baseAssignIn(object, source) {
                        return object && copyObject(source, keysIn(source), object)
                    }
                    function baseAssignValue(object, key, value) {
                        "__proto__" == key && defineProperty ? defineProperty(object, key, {
                            configurable: !0,
                            enumerable: !0,
                            value: value,
                            writable: !0
                        }) : object[key] = value
                    }
                    function baseAt(object, paths) {
                        for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length; )
                            result[index] = skip ? undefined : get(object, paths[index]);
                        return result
                    }
                    function baseClamp(number, lower, upper) {
                        return number === number && (upper !== undefined && (number = number <= upper ? number : upper),
                        lower !== undefined && (number = number >= lower ? number : lower)),
                        number
                    }
                    function baseClone(value, bitmask, customizer, key, object, stack) {
                        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                        if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)),
                        result !== undefined)
                            return result;
                        if (!isObject(value))
                            return value;
                        var isArr = isArray(value);
                        if (isArr) {
                            if (result = initCloneArray(value),
                            !isDeep)
                                return copyArray(value, result)
                        } else {
                            var tag = getTag(value)
                              , isFunc = tag == funcTag || tag == genTag;
                            if (isBuffer(value))
                                return cloneBuffer(value, isDeep);
                            if (tag == objectTag || tag == argsTag || isFunc && !object) {
                                if (result = isFlat || isFunc ? {} : initCloneObject(value),
                                !isDeep)
                                    return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value))
                            } else {
                                if (!cloneableTags[tag])
                                    return object ? value : {};
                                result = initCloneByTag(value, tag, isDeep)
                            }
                        }
                        stack || (stack = new Stack);
                        var stacked = stack.get(value);
                        if (stacked)
                            return stacked;
                        if (stack.set(value, result),
                        isSet(value))
                            return value.forEach(function(subValue) {
                                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
                            }),
                            result;
                        if (isMap(value))
                            return value.forEach(function(subValue, key) {
                                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
                            }),
                            result;
                        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys
                          , props = isArr ? undefined : keysFunc(value);
                        return arrayEach(props || value, function(subValue, key) {
                            props && (subValue = value[key = subValue]),
                            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
                        }),
                        result
                    }
                    function baseConforms(source) {
                        var props = keys(source);
                        return function(object) {
                            return baseConformsTo(object, source, props)
                        }
                    }
                    function baseConformsTo(object, source, props) {
                        var length = props.length;
                        if (null == object)
                            return !length;
                        for (object = Object(object); length--; ) {
                            var key = props[length]
                              , predicate = source[key]
                              , value = object[key];
                            if (value === undefined && !(key in object) || !predicate(value))
                                return !1
                        }
                        return !0
                    }
                    function baseDelay(func, wait, args) {
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return setTimeout(function() {
                            func.apply(undefined, args)
                        }, wait)
                    }
                    function baseDifference(array, values, iteratee, comparator) {
                        var index = -1
                          , includes = arrayIncludes
                          , isCommon = !0
                          , length = array.length
                          , result = []
                          , valuesLength = values.length;
                        if (!length)
                            return result;
                        iteratee && (values = arrayMap(values, baseUnary(iteratee))),
                        comparator ? (includes = arrayIncludesWith,
                        isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas,
                        isCommon = !1,
                        values = new SetCache(values));
                        outer: for (; ++index < length; ) {
                            var value = array[index]
                              , computed = null == iteratee ? value : iteratee(value);
                            if (value = comparator || 0 !== value ? value : 0,
                            isCommon && computed === computed) {
                                for (var valuesIndex = valuesLength; valuesIndex--; )
                                    if (values[valuesIndex] === computed)
                                        continue outer;
                                result.push(value)
                            } else
                                includes(values, computed, comparator) || result.push(value)
                        }
                        return result
                    }
                    function baseEvery(collection, predicate) {
                        var result = !0;
                        return baseEach(collection, function(value, index, collection) {
                            return result = !!predicate(value, index, collection)
                        }),
                        result
                    }
                    function baseExtremum(array, iteratee, comparator) {
                        for (var index = -1, length = array.length; ++index < length; ) {
                            var value = array[index]
                              , current = iteratee(value);
                            if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed)))
                                var computed = current
                                  , result = value
                        }
                        return result
                    }
                    function baseFill(array, value, start, end) {
                        var length = array.length;
                        for ((start = toInteger(start)) < 0 && (start = -start > length ? 0 : length + start),
                        (end = end === undefined || end > length ? length : toInteger(end)) < 0 && (end += length),
                        end = start > end ? 0 : toLength(end); start < end; )
                            array[start++] = value;
                        return array
                    }
                    function baseFilter(collection, predicate) {
                        var result = [];
                        return baseEach(collection, function(value, index, collection) {
                            predicate(value, index, collection) && result.push(value)
                        }),
                        result
                    }
                    function baseFlatten(array, depth, predicate, isStrict, result) {
                        var index = -1
                          , length = array.length;
                        for (predicate || (predicate = isFlattenable),
                        result || (result = []); ++index < length; ) {
                            var value = array[index];
                            depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
                        }
                        return result
                    }
                    function baseForOwn(object, iteratee) {
                        return object && baseFor(object, iteratee, keys)
                    }
                    function baseForOwnRight(object, iteratee) {
                        return object && baseForRight(object, iteratee, keys)
                    }
                    function baseFunctions(object, props) {
                        return arrayFilter(props, function(key) {
                            return isFunction(object[key])
                        })
                    }
                    function baseGet(object, path) {
                        for (var index = 0, length = (path = castPath(path, object)).length; null != object && index < length; )
                            object = object[toKey(path[index++])];
                        return index && index == length ? object : undefined
                    }
                    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result = keysFunc(object);
                        return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
                    }
                    function baseGetTag(value) {
                        return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)
                    }
                    function baseGt(value, other) {
                        return value > other
                    }
                    function baseHas(object, key) {
                        return null != object && hasOwnProperty.call(object, key)
                    }
                    function baseHasIn(object, key) {
                        return null != object && key in Object(object)
                    }
                    function baseInRange(number, start, end) {
                        return number >= nativeMin(start, end) && number < nativeMax(start, end)
                    }
                    function baseIntersection(arrays, iteratee, comparator) {
                        for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--; ) {
                            var array = arrays[othIndex];
                            othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))),
                            maxLength = nativeMin(array.length, maxLength),
                            caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
                        }
                        array = arrays[0];
                        var index = -1
                          , seen = caches[0];
                        outer: for (; ++index < length && result.length < maxLength; ) {
                            var value = array[index]
                              , computed = iteratee ? iteratee(value) : value;
                            if (value = comparator || 0 !== value ? value : 0,
                            !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                                for (othIndex = othLength; --othIndex; ) {
                                    var cache = caches[othIndex];
                                    if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator)))
                                        continue outer
                                }
                                seen && seen.push(computed),
                                result.push(value)
                            }
                        }
                        return result
                    }
                    function baseInverter(object, setter, iteratee, accumulator) {
                        return baseForOwn(object, function(value, key, object) {
                            setter(accumulator, iteratee(value), key, object)
                        }),
                        accumulator
                    }
                    function baseInvoke(object, path, args) {
                        var func = null == (object = parent(object, path = castPath(path, object))) ? object : object[toKey(last(path))];
                        return null == func ? undefined : apply(func, object, args)
                    }
                    function baseIsArguments(value) {
                        return isObjectLike(value) && baseGetTag(value) == argsTag
                    }
                    function baseIsEqual(value, other, bitmask, customizer, stack) {
                        return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack))
                    }
                    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                        var objIsArr = isArray(object)
                          , othIsArr = isArray(other)
                          , objTag = objIsArr ? arrayTag : getTag(object)
                          , othTag = othIsArr ? arrayTag : getTag(other)
                          , objIsObj = (objTag = objTag == argsTag ? objectTag : objTag) == objectTag
                          , othIsObj = (othTag = othTag == argsTag ? objectTag : othTag) == objectTag
                          , isSameTag = objTag == othTag;
                        if (isSameTag && isBuffer(object)) {
                            if (!isBuffer(other))
                                return !1;
                            objIsArr = !0,
                            objIsObj = !1
                        }
                        if (isSameTag && !objIsObj)
                            return stack || (stack = new Stack),
                            objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__")
                              , othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                            if (objIsWrapped || othIsWrapped) {
                                var objUnwrapped = objIsWrapped ? object.value() : object
                                  , othUnwrapped = othIsWrapped ? other.value() : other;
                                return stack || (stack = new Stack),
                                equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
                            }
                        }
                        return !!isSameTag && (stack || (stack = new Stack),
                        equalObjects(object, other, bitmask, customizer, equalFunc, stack))
                    }
                    function baseIsMatch(object, source, matchData, customizer) {
                        var index = matchData.length
                          , length = index
                          , noCustomizer = !customizer;
                        if (null == object)
                            return !length;
                        for (object = Object(object); index--; ) {
                            var data = matchData[index];
                            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0]in object))
                                return !1
                        }
                        for (; ++index < length; ) {
                            var key = (data = matchData[index])[0]
                              , objValue = object[key]
                              , srcValue = data[1];
                            if (noCustomizer && data[2]) {
                                if (objValue === undefined && !(key in object))
                                    return !1
                            } else {
                                var stack = new Stack;
                                if (customizer)
                                    var result = customizer(objValue, srcValue, key, object, source, stack);
                                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result))
                                    return !1
                            }
                        }
                        return !0
                    }
                    function baseIsNative(value) {
                        return !(!isObject(value) || isMasked(value)) && (isFunction(value) ? reIsNative : reIsHostCtor).test(toSource(value))
                    }
                    function baseIteratee(value) {
                        return "function" == typeof value ? value : null == value ? identity : "object" == typeof value ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value)
                    }
                    function baseKeys(object) {
                        if (!isPrototype(object))
                            return nativeKeys(object);
                        var result = [];
                        for (var key in Object(object))
                            hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                        return result
                    }
                    function baseKeysIn(object) {
                        if (!isObject(object))
                            return nativeKeysIn(object);
                        var isProto = isPrototype(object)
                          , result = [];
                        for (var key in object)
                            ("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
                        return result
                    }
                    function baseLt(value, other) {
                        return value < other
                    }
                    function baseMap(collection, iteratee) {
                        var index = -1
                          , result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function(value, key, collection) {
                            result[++index] = iteratee(value, key, collection)
                        }),
                        result
                    }
                    function baseMatches(source) {
                        var matchData = getMatchData(source);
                        return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                            return object === source || baseIsMatch(object, source, matchData)
                        }
                    }
                    function baseMatchesProperty(path, srcValue) {
                        return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                            var objValue = get(object, path);
                            return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
                        }
                    }
                    function baseMerge(object, source, srcIndex, customizer, stack) {
                        object !== source && baseFor(source, function(srcValue, key) {
                            if (isObject(srcValue))
                                stack || (stack = new Stack),
                                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                            else {
                                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                                newValue === undefined && (newValue = srcValue),
                                assignMergeValue(object, key, newValue)
                            }
                        }, keysIn)
                    }
                    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                        var objValue = safeGet(object, key)
                          , srcValue = safeGet(source, key)
                          , stacked = stack.get(srcValue);
                        if (stacked)
                            assignMergeValue(object, key, stacked);
                        else {
                            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined
                              , isCommon = newValue === undefined;
                            if (isCommon) {
                                var isArr = isArray(srcValue)
                                  , isBuff = !isArr && isBuffer(srcValue)
                                  , isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                                newValue = srcValue,
                                isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1,
                                newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1,
                                newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue,
                                isArguments(objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue))) : isCommon = !1
                            }
                            isCommon && (stack.set(srcValue, newValue),
                            mergeFunc(newValue, srcValue, srcIndex, customizer, stack),
                            stack.delete(srcValue)),
                            assignMergeValue(object, key, newValue)
                        }
                    }
                    function baseNth(array, n) {
                        var length = array.length;
                        if (length)
                            return n += n < 0 ? length : 0,
                            isIndex(n, length) ? array[n] : undefined
                    }
                    function baseOrderBy(collection, iteratees, orders) {
                        var index = -1;
                        return iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee())),
                        baseSortBy(baseMap(collection, function(value, key, collection) {
                            return {
                                criteria: arrayMap(iteratees, function(iteratee) {
                                    return iteratee(value)
                                }),
                                index: ++index,
                                value: value
                            }
                        }), function(object, other) {
                            return compareMultiple(object, other, orders)
                        })
                    }
                    function basePick(object, paths) {
                        return basePickBy(object, paths, function(value, path) {
                            return hasIn(object, path)
                        })
                    }
                    function basePickBy(object, paths, predicate) {
                        for (var index = -1, length = paths.length, result = {}; ++index < length; ) {
                            var path = paths[index]
                              , value = baseGet(object, path);
                            predicate(value, path) && baseSet(result, castPath(path, object), value)
                        }
                        return result
                    }
                    function basePropertyDeep(path) {
                        return function(object) {
                            return baseGet(object, path)
                        }
                    }
                    function basePullAll(array, values, iteratee, comparator) {
                        var indexOf = comparator ? baseIndexOfWith : baseIndexOf
                          , index = -1
                          , length = values.length
                          , seen = array;
                        for (array === values && (values = copyArray(values)),
                        iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length; )
                            for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value; (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1; )
                                seen !== array && splice.call(seen, fromIndex, 1),
                                splice.call(array, fromIndex, 1);
                        return array
                    }
                    function basePullAt(array, indexes) {
                        for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
                            var index = indexes[length];
                            if (length == lastIndex || index !== previous) {
                                var previous = index;
                                isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index)
                            }
                        }
                        return array
                    }
                    function baseRandom(lower, upper) {
                        return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                    }
                    function baseRange(start, end, step, fromRight) {
                        for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--; )
                            result[fromRight ? length : ++index] = start,
                            start += step;
                        return result
                    }
                    function baseRepeat(string, n) {
                        var result = "";
                        if (!string || n < 1 || n > MAX_SAFE_INTEGER)
                            return result;
                        do {
                            n % 2 && (result += string),
                            (n = nativeFloor(n / 2)) && (string += string)
                        } while (n);return result
                    }
                    function baseRest(func, start) {
                        return setToString(overRest(func, start, identity), func + "")
                    }
                    function baseSample(collection) {
                        return arraySample(values(collection))
                    }
                    function baseSampleSize(collection, n) {
                        var array = values(collection);
                        return shuffleSelf(array, baseClamp(n, 0, array.length))
                    }
                    function baseSet(object, path, value, customizer) {
                        if (!isObject(object))
                            return object;
                        for (var index = -1, length = (path = castPath(path, object)).length, lastIndex = length - 1, nested = object; null != nested && ++index < length; ) {
                            var key = toKey(path[index])
                              , newValue = value;
                            if (index != lastIndex) {
                                var objValue = nested[key];
                                (newValue = customizer ? customizer(objValue, key, nested) : undefined) === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {})
                            }
                            assignValue(nested, key, newValue),
                            nested = nested[key]
                        }
                        return object
                    }
                    function baseShuffle(collection) {
                        return shuffleSelf(values(collection))
                    }
                    function baseSlice(array, start, end) {
                        var index = -1
                          , length = array.length;
                        start < 0 && (start = -start > length ? 0 : length + start),
                        (end = end > length ? length : end) < 0 && (end += length),
                        length = start > end ? 0 : end - start >>> 0,
                        start >>>= 0;
                        for (var result = Array(length); ++index < length; )
                            result[index] = array[index + start];
                        return result
                    }
                    function baseSome(collection, predicate) {
                        var result;
                        return baseEach(collection, function(value, index, collection) {
                            return !(result = predicate(value, index, collection))
                        }),
                        !!result
                    }
                    function baseSortedIndex(array, value, retHighest) {
                        var low = 0
                          , high = null == array ? low : array.length;
                        if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                            for (; low < high; ) {
                                var mid = low + high >>> 1
                                  , computed = array[mid];
                                null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid
                            }
                            return high
                        }
                        return baseSortedIndexBy(array, value, identity, retHighest)
                    }
                    function baseSortedIndexBy(array, value, iteratee, retHighest) {
                        value = iteratee(value);
                        for (var low = 0, high = null == array ? 0 : array.length, valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; low < high; ) {
                            var mid = nativeFloor((low + high) / 2)
                              , computed = iteratee(array[mid])
                              , othIsDefined = computed !== undefined
                              , othIsNull = null === computed
                              , othIsReflexive = computed === computed
                              , othIsSymbol = isSymbol(computed);
                            if (valIsNaN)
                                var setLow = retHighest || othIsReflexive;
                            else
                                setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
                            setLow ? low = mid + 1 : high = mid
                        }
                        return nativeMin(high, MAX_ARRAY_INDEX)
                    }
                    function baseSortedUniq(array, iteratee) {
                        for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
                            var value = array[index]
                              , computed = iteratee ? iteratee(value) : value;
                            if (!index || !eq(computed, seen)) {
                                var seen = computed;
                                result[resIndex++] = 0 === value ? 0 : value
                            }
                        }
                        return result
                    }
                    function baseToNumber(value) {
                        return "number" == typeof value ? value : isSymbol(value) ? NAN : +value
                    }
                    function baseToString(value) {
                        if ("string" == typeof value)
                            return value;
                        if (isArray(value))
                            return arrayMap(value, baseToString) + "";
                        if (isSymbol(value))
                            return symbolToString ? symbolToString.call(value) : "";
                        var result = value + "";
                        return "0" == result && 1 / value == -INFINITY ? "-0" : result
                    }
                    function baseUniq(array, iteratee, comparator) {
                        var index = -1
                          , includes = arrayIncludes
                          , length = array.length
                          , isCommon = !0
                          , result = []
                          , seen = result;
                        if (comparator)
                            isCommon = !1,
                            includes = arrayIncludesWith;
                        else if (length >= LARGE_ARRAY_SIZE) {
                            var set = iteratee ? null : createSet(array);
                            if (set)
                                return setToArray(set);
                            isCommon = !1,
                            includes = cacheHas,
                            seen = new SetCache
                        } else
                            seen = iteratee ? [] : result;
                        outer: for (; ++index < length; ) {
                            var value = array[index]
                              , computed = iteratee ? iteratee(value) : value;
                            if (value = comparator || 0 !== value ? value : 0,
                            isCommon && computed === computed) {
                                for (var seenIndex = seen.length; seenIndex--; )
                                    if (seen[seenIndex] === computed)
                                        continue outer;
                                iteratee && seen.push(computed),
                                result.push(value)
                            } else
                                includes(seen, computed, comparator) || (seen !== result && seen.push(computed),
                                result.push(value))
                        }
                        return result
                    }
                    function baseUnset(object, path) {
                        return path = castPath(path, object),
                        null == (object = parent(object, path)) || delete object[toKey(last(path))]
                    }
                    function baseUpdate(object, path, updater, customizer) {
                        return baseSet(object, path, updater(baseGet(object, path)), customizer)
                    }
                    function baseWhile(array, predicate, isDrop, fromRight) {
                        for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); )
                            ;
                        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
                    }
                    function baseWrapperValue(value, actions) {
                        var result = value;
                        return result instanceof LazyWrapper && (result = result.value()),
                        arrayReduce(actions, function(result, action) {
                            return action.func.apply(action.thisArg, arrayPush([result], action.args))
                        }, result)
                    }
                    function baseXor(arrays, iteratee, comparator) {
                        var length = arrays.length;
                        if (length < 2)
                            return length ? baseUniq(arrays[0]) : [];
                        for (var index = -1, result = Array(length); ++index < length; )
                            for (var array = arrays[index], othIndex = -1; ++othIndex < length; )
                                othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
                        return baseUniq(baseFlatten(result, 1), iteratee, comparator)
                    }
                    function baseZipObject(props, values, assignFunc) {
                        for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length; ) {
                            var value = index < valsLength ? values[index] : undefined;
                            assignFunc(result, props[index], value)
                        }
                        return result
                    }
                    function castArrayLikeObject(value) {
                        return isArrayLikeObject(value) ? value : []
                    }
                    function castFunction(value) {
                        return "function" == typeof value ? value : identity
                    }
                    function castPath(value, object) {
                        return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value))
                    }
                    function castSlice(array, start, end) {
                        var length = array.length;
                        return end = end === undefined ? length : end,
                        !start && end >= length ? array : baseSlice(array, start, end)
                    }
                    function cloneBuffer(buffer, isDeep) {
                        if (isDeep)
                            return buffer.slice();
                        var length = buffer.length
                          , result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                        return buffer.copy(result),
                        result
                    }
                    function cloneArrayBuffer(arrayBuffer) {
                        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                        return new Uint8Array(result).set(new Uint8Array(arrayBuffer)),
                        result
                    }
                    function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                        return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength)
                    }
                    function cloneRegExp(regexp) {
                        var result = new regexp.constructor(regexp.source,reFlags.exec(regexp));
                        return result.lastIndex = regexp.lastIndex,
                        result
                    }
                    function cloneSymbol(symbol) {
                        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
                    }
                    function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                        return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length)
                    }
                    function compareAscending(value, other) {
                        if (value !== other) {
                            var valIsDefined = value !== undefined
                              , valIsNull = null === value
                              , valIsReflexive = value === value
                              , valIsSymbol = isSymbol(value)
                              , othIsDefined = other !== undefined
                              , othIsNull = null === other
                              , othIsReflexive = other === other
                              , othIsSymbol = isSymbol(other);
                            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
                                return 1;
                            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
                                return -1
                        }
                        return 0
                    }
                    function compareMultiple(object, other, orders) {
                        for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
                            var result = compareAscending(objCriteria[index], othCriteria[index]);
                            if (result)
                                return index >= ordersLength ? result : result * ("desc" == orders[index] ? -1 : 1)
                        }
                        return object.index - other.index
                    }
                    function composeArgs(args, partials, holders, isCurried) {
                        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
                            result[leftIndex] = partials[leftIndex];
                        for (; ++argsIndex < holdersLength; )
                            (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
                        for (; rangeLength--; )
                            result[leftIndex++] = args[argsIndex++];
                        return result
                    }
                    function composeArgsRight(args, partials, holders, isCurried) {
                        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
                            result[argsIndex] = args[argsIndex];
                        for (var offset = argsIndex; ++rightIndex < rightLength; )
                            result[offset + rightIndex] = partials[rightIndex];
                        for (; ++holdersIndex < holdersLength; )
                            (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
                        return result
                    }
                    function copyArray(source, array) {
                        var index = -1
                          , length = source.length;
                        for (array || (array = Array(length)); ++index < length; )
                            array[index] = source[index];
                        return array
                    }
                    function copyObject(source, props, object, customizer) {
                        var isNew = !object;
                        object || (object = {});
                        for (var index = -1, length = props.length; ++index < length; ) {
                            var key = props[index]
                              , newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                            newValue === undefined && (newValue = source[key]),
                            isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue)
                        }
                        return object
                    }
                    function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object)
                    }
                    function copySymbolsIn(source, object) {
                        return copyObject(source, getSymbolsIn(source), object)
                    }
                    function createAggregator(setter, initializer) {
                        return function(collection, iteratee) {
                            var func = isArray(collection) ? arrayAggregator : baseAggregator
                              , accumulator = initializer ? initializer() : {};
                            return func(collection, setter, getIteratee(iteratee, 2), accumulator)
                        }
                    }
                    function createAssigner(assigner) {
                        return baseRest(function(object, sources) {
                            var index = -1
                              , length = sources.length
                              , customizer = length > 1 ? sources[length - 1] : undefined
                              , guard = length > 2 ? sources[2] : undefined;
                            for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--,
                            customizer) : undefined,
                            guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined : customizer,
                            length = 1),
                            object = Object(object); ++index < length; ) {
                                var source = sources[index];
                                source && assigner(object, source, index, customizer)
                            }
                            return object
                        })
                    }
                    function createBaseEach(eachFunc, fromRight) {
                        return function(collection, iteratee) {
                            if (null == collection)
                                return collection;
                            if (!isArrayLike(collection))
                                return eachFunc(collection, iteratee);
                            for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection); (fromRight ? index-- : ++index < length) && !1 !== iteratee(iterable[index], index, iterable); )
                                ;
                            return collection
                        }
                    }
                    function createBaseFor(fromRight) {
                        return function(object, iteratee, keysFunc) {
                            for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--; ) {
                                var key = props[fromRight ? length : ++index];
                                if (!1 === iteratee(iterable[key], key, iterable))
                                    break
                            }
                            return object
                        }
                    }
                    function createBind(func, bitmask, thisArg) {
                        function wrapper() {
                            return (this && this !== root && this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, arguments)
                        }
                        var isBind = bitmask & WRAP_BIND_FLAG
                          , Ctor = createCtor(func);
                        return wrapper
                    }
                    function createCaseFirst(methodName) {
                        return function(string) {
                            var strSymbols = hasUnicode(string = toString(string)) ? stringToArray(string) : undefined
                              , chr = strSymbols ? strSymbols[0] : string.charAt(0)
                              , trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                            return chr[methodName]() + trailing
                        }
                    }
                    function createCompounder(callback) {
                        return function(string) {
                            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
                        }
                    }
                    function createCtor(Ctor) {
                        return function() {
                            var args = arguments;
                            switch (args.length) {
                            case 0:
                                return new Ctor;
                            case 1:
                                return new Ctor(args[0]);
                            case 2:
                                return new Ctor(args[0],args[1]);
                            case 3:
                                return new Ctor(args[0],args[1],args[2]);
                            case 4:
                                return new Ctor(args[0],args[1],args[2],args[3]);
                            case 5:
                                return new Ctor(args[0],args[1],args[2],args[3],args[4]);
                            case 6:
                                return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);
                            case 7:
                                return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6])
                            }
                            var thisBinding = baseCreate(Ctor.prototype)
                              , result = Ctor.apply(thisBinding, args);
                            return isObject(result) ? result : thisBinding
                        }
                    }
                    function createCurry(func, bitmask, arity) {
                        function wrapper() {
                            for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--; )
                                args[index] = arguments[index];
                            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                            return (length -= holders.length) < arity ? createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length) : apply(this && this !== root && this instanceof wrapper ? Ctor : func, this, args)
                        }
                        var Ctor = createCtor(func);
                        return wrapper
                    }
                    function createFind(findIndexFunc) {
                        return function(collection, predicate, fromIndex) {
                            var iterable = Object(collection);
                            if (!isArrayLike(collection)) {
                                var iteratee = getIteratee(predicate, 3);
                                collection = keys(collection),
                                predicate = function(key) {
                                    return iteratee(iterable[key], key, iterable)
                                }
                            }
                            var index = findIndexFunc(collection, predicate, fromIndex);
                            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
                        }
                    }
                    function createFlow(fromRight) {
                        return flatRest(function(funcs) {
                            var length = funcs.length
                              , index = length
                              , prereq = LodashWrapper.prototype.thru;
                            for (fromRight && funcs.reverse(); index--; ) {
                                var func = funcs[index];
                                if ("function" != typeof func)
                                    throw new TypeError(FUNC_ERROR_TEXT);
                                if (prereq && !wrapper && "wrapper" == getFuncName(func))
                                    var wrapper = new LodashWrapper([],!0)
                            }
                            for (index = wrapper ? index : length; ++index < length; ) {
                                var funcName = getFuncName(func = funcs[index])
                                  , data = "wrapper" == funcName ? getData(func) : undefined;
                                wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                            }
                            return function() {
                                var args = arguments
                                  , value = args[0];
                                if (wrapper && 1 == args.length && isArray(value))
                                    return wrapper.plant(value).value();
                                for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length; )
                                    result = funcs[index].call(this, result);
                                return result
                            }
                        })
                    }
                    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                        function wrapper() {
                            for (var length = arguments.length, args = Array(length), index = length; index--; )
                                args[index] = arguments[index];
                            if (isCurried)
                                var placeholder = getHolder(wrapper)
                                  , holdersCount = countHolders(args, placeholder);
                            if (partials && (args = composeArgs(args, partials, holders, isCurried)),
                            partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)),
                            length -= holdersCount,
                            isCurried && length < arity) {
                                var newHolders = replaceHolders(args, placeholder);
                                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
                            }
                            var thisBinding = isBind ? thisArg : this
                              , fn = isBindKey ? thisBinding[func] : func;
                            return length = args.length,
                            argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(),
                            isAry && ary < length && (args.length = ary),
                            this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)),
                            fn.apply(thisBinding, args)
                        }
                        var isAry = bitmask & WRAP_ARY_FLAG
                          , isBind = bitmask & WRAP_BIND_FLAG
                          , isBindKey = bitmask & WRAP_BIND_KEY_FLAG
                          , isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)
                          , isFlip = bitmask & WRAP_FLIP_FLAG
                          , Ctor = isBindKey ? undefined : createCtor(func);
                        return wrapper
                    }
                    function createInverter(setter, toIteratee) {
                        return function(object, iteratee) {
                            return baseInverter(object, setter, toIteratee(iteratee), {})
                        }
                    }
                    function createMathOperation(operator, defaultValue) {
                        return function(value, other) {
                            var result;
                            if (value === undefined && other === undefined)
                                return defaultValue;
                            if (value !== undefined && (result = value),
                            other !== undefined) {
                                if (result === undefined)
                                    return other;
                                "string" == typeof value || "string" == typeof other ? (value = baseToString(value),
                                other = baseToString(other)) : (value = baseToNumber(value),
                                other = baseToNumber(other)),
                                result = operator(value, other)
                            }
                            return result
                        }
                    }
                    function createOver(arrayFunc) {
                        return flatRest(function(iteratees) {
                            return iteratees = arrayMap(iteratees, baseUnary(getIteratee())),
                            baseRest(function(args) {
                                var thisArg = this;
                                return arrayFunc(iteratees, function(iteratee) {
                                    return apply(iteratee, thisArg, args)
                                })
                            })
                        })
                    }
                    function createPadding(length, chars) {
                        var charsLength = (chars = chars === undefined ? " " : baseToString(chars)).length;
                        if (charsLength < 2)
                            return charsLength ? baseRepeat(chars, length) : chars;
                        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
                    }
                    function createPartial(func, bitmask, thisArg, partials) {
                        function wrapper() {
                            for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
                                args[leftIndex] = partials[leftIndex];
                            for (; argsLength--; )
                                args[leftIndex++] = arguments[++argsIndex];
                            return apply(fn, isBind ? thisArg : this, args)
                        }
                        var isBind = bitmask & WRAP_BIND_FLAG
                          , Ctor = createCtor(func);
                        return wrapper
                    }
                    function createRange(fromRight) {
                        return function(start, end, step) {
                            return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined),
                            start = toFinite(start),
                            end === undefined ? (end = start,
                            start = 0) : end = toFinite(end),
                            step = step === undefined ? start < end ? 1 : -1 : toFinite(step),
                            baseRange(start, end, step, fromRight)
                        }
                    }
                    function createRelationalOperation(operator) {
                        return function(value, other) {
                            return "string" == typeof value && "string" == typeof other || (value = toNumber(value),
                            other = toNumber(other)),
                            operator(value, other)
                        }
                    }
                    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                        var isCurry = bitmask & WRAP_CURRY_FLAG
                          , newHolders = isCurry ? holders : undefined
                          , newHoldersRight = isCurry ? undefined : holders
                          , newPartials = isCurry ? partials : undefined
                          , newPartialsRight = isCurry ? undefined : partials;
                        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG,
                        (bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG)) & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
                        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity]
                          , result = wrapFunc.apply(undefined, newData);
                        return isLaziable(func) && setData(result, newData),
                        result.placeholder = placeholder,
                        setWrapToString(result, func, bitmask)
                    }
                    function createRound(methodName) {
                        var func = Math[methodName];
                        return function(number, precision) {
                            if (number = toNumber(number),
                            precision = null == precision ? 0 : nativeMin(toInteger(precision), 292)) {
                                var pair = (toString(number) + "e").split("e");
                                return +((pair = (toString(func(pair[0] + "e" + (+pair[1] + precision))) + "e").split("e"))[0] + "e" + (+pair[1] - precision))
                            }
                            return func(number)
                        }
                    }
                    function createToPairs(keysFunc) {
                        return function(object) {
                            var tag = getTag(object);
                            return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object))
                        }
                    }
                    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                        if (!isBindKey && "function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        var length = partials ? partials.length : 0;
                        if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG),
                        partials = holders = undefined),
                        ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0),
                        arity = arity === undefined ? arity : toInteger(arity),
                        length -= holders ? holders.length : 0,
                        bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                            var partialsRight = partials
                              , holdersRight = holders;
                            partials = holders = undefined
                        }
                        var data = isBindKey ? undefined : getData(func)
                          , newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
                        if (data && mergeData(newData, data),
                        func = newData[0],
                        bitmask = newData[1],
                        thisArg = newData[2],
                        partials = newData[3],
                        holders = newData[4],
                        !(arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0)) && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)),
                        bitmask && bitmask != WRAP_BIND_FLAG)
                            result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials);
                        else
                            var result = createBind(func, bitmask, thisArg);
                        return setWrapToString((data ? baseSetData : setData)(result, newData), func, bitmask)
                    }
                    function customDefaultsAssignIn(objValue, srcValue, key, object) {
                        return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue
                    }
                    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                        return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue),
                        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack),
                        stack.delete(srcValue)),
                        objValue
                    }
                    function customOmitClone(value) {
                        return isPlainObject(value) ? undefined : value
                    }
                    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG
                          , arrLength = array.length
                          , othLength = other.length;
                        if (arrLength != othLength && !(isPartial && othLength > arrLength))
                            return !1;
                        var stacked = stack.get(array);
                        if (stacked && stack.get(other))
                            return stacked == other;
                        var index = -1
                          , result = !0
                          , seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
                        for (stack.set(array, other),
                        stack.set(other, array); ++index < arrLength; ) {
                            var arrValue = array[index]
                              , othValue = other[index];
                            if (customizer)
                                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                            if (compared !== undefined) {
                                if (compared)
                                    continue;
                                result = !1;
                                break
                            }
                            if (seen) {
                                if (!arraySome(other, function(othValue, othIndex) {
                                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack)))
                                        return seen.push(othIndex)
                                })) {
                                    result = !1;
                                    break
                                }
                            } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                                result = !1;
                                break
                            }
                        }
                        return stack.delete(array),
                        stack.delete(other),
                        result
                    }
                    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                        switch (tag) {
                        case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
                                return !1;
                            object = object.buffer,
                            other = other.buffer;
                        case arrayBufferTag:
                            return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));
                        case boolTag:
                        case dateTag:
                        case numberTag:
                            return eq(+object, +other);
                        case errorTag:
                            return object.name == other.name && object.message == other.message;
                        case regexpTag:
                        case stringTag:
                            return object == other + "";
                        case mapTag:
                            var convert = mapToArray;
                        case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            if (convert || (convert = setToArray),
                            object.size != other.size && !isPartial)
                                return !1;
                            var stacked = stack.get(object);
                            if (stacked)
                                return stacked == other;
                            bitmask |= COMPARE_UNORDERED_FLAG,
                            stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            return stack.delete(object),
                            result;
                        case symbolTag:
                            if (symbolValueOf)
                                return symbolValueOf.call(object) == symbolValueOf.call(other)
                        }
                        return !1
                    }
                    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG
                          , objProps = getAllKeys(object)
                          , objLength = objProps.length;
                        if (objLength != getAllKeys(other).length && !isPartial)
                            return !1;
                        for (var index = objLength; index--; ) {
                            var key = objProps[index];
                            if (!(isPartial ? key in other : hasOwnProperty.call(other, key)))
                                return !1
                        }
                        var stacked = stack.get(object);
                        if (stacked && stack.get(other))
                            return stacked == other;
                        var result = !0;
                        stack.set(object, other),
                        stack.set(other, object);
                        for (var skipCtor = isPartial; ++index < objLength; ) {
                            var objValue = object[key = objProps[index]]
                              , othValue = other[key];
                            if (customizer)
                                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                            if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                                result = !1;
                                break
                            }
                            skipCtor || (skipCtor = "constructor" == key)
                        }
                        if (result && !skipCtor) {
                            var objCtor = object.constructor
                              , othCtor = other.constructor;
                            objCtor != othCtor && "constructor"in object && "constructor"in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1)
                        }
                        return stack.delete(object),
                        stack.delete(other),
                        result
                    }
                    function flatRest(func) {
                        return setToString(overRest(func, undefined, flatten), func + "")
                    }
                    function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols)
                    }
                    function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn)
                    }
                    function getFuncName(func) {
                        for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--; ) {
                            var data = array[length]
                              , otherFunc = data.func;
                            if (null == otherFunc || otherFunc == func)
                                return data.name
                        }
                        return result
                    }
                    function getHolder(func) {
                        return (hasOwnProperty.call(lodash, "placeholder") ? lodash : func).placeholder
                    }
                    function getIteratee() {
                        var result = lodash.iteratee || iteratee;
                        return result = result === iteratee ? baseIteratee : result,
                        arguments.length ? result(arguments[0], arguments[1]) : result
                    }
                    function getMapData(map, key) {
                        var data = map.__data__;
                        return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map
                    }
                    function getMatchData(object) {
                        for (var result = keys(object), length = result.length; length--; ) {
                            var key = result[length]
                              , value = object[key];
                            result[length] = [key, value, isStrictComparable(value)]
                        }
                        return result
                    }
                    function getNative(object, key) {
                        var value = getValue(object, key);
                        return baseIsNative(value) ? value : undefined
                    }
                    function getRawTag(value) {
                        var isOwn = hasOwnProperty.call(value, symToStringTag)
                          , tag = value[symToStringTag];
                        try {
                            value[symToStringTag] = undefined;
                            var unmasked = !0
                        } catch (e) {}
                        var result = nativeObjectToString.call(value);
                        return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]),
                        result
                    }
                    function getView(start, end, transforms) {
                        for (var index = -1, length = transforms.length; ++index < length; ) {
                            var data = transforms[index]
                              , size = data.size;
                            switch (data.type) {
                            case "drop":
                                start += size;
                                break;
                            case "dropRight":
                                end -= size;
                                break;
                            case "take":
                                end = nativeMin(end, start + size);
                                break;
                            case "takeRight":
                                start = nativeMax(start, end - size)
                            }
                        }
                        return {
                            start: start,
                            end: end
                        }
                    }
                    function getWrapDetails(source) {
                        var match = source.match(reWrapDetails);
                        return match ? match[1].split(reSplitDetails) : []
                    }
                    function hasPath(object, path, hasFunc) {
                        for (var index = -1, length = (path = castPath(path, object)).length, result = !1; ++index < length; ) {
                            var key = toKey(path[index]);
                            if (!(result = null != object && hasFunc(object, key)))
                                break;
                            object = object[key]
                        }
                        return result || ++index != length ? result : !!(length = null == object ? 0 : object.length) && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object))
                    }
                    function initCloneArray(array) {
                        var length = array.length
                          , result = new array.constructor(length);
                        return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index,
                        result.input = array.input),
                        result
                    }
                    function initCloneObject(object) {
                        return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object))
                    }
                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;
                        switch (tag) {
                        case arrayBufferTag:
                            return cloneArrayBuffer(object);
                        case boolTag:
                        case dateTag:
                            return new Ctor(+object);
                        case dataViewTag:
                            return cloneDataView(object, isDeep);
                        case float32Tag:
                        case float64Tag:
                        case int8Tag:
                        case int16Tag:
                        case int32Tag:
                        case uint8Tag:
                        case uint8ClampedTag:
                        case uint16Tag:
                        case uint32Tag:
                            return cloneTypedArray(object, isDeep);
                        case mapTag:
                            return new Ctor;
                        case numberTag:
                        case stringTag:
                            return new Ctor(object);
                        case regexpTag:
                            return cloneRegExp(object);
                        case setTag:
                            return new Ctor;
                        case symbolTag:
                            return cloneSymbol(object)
                        }
                    }
                    function insertWrapDetails(source, details) {
                        var length = details.length;
                        if (!length)
                            return source;
                        var lastIndex = length - 1;
                        return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex],
                        details = details.join(length > 2 ? ", " : " "),
                        source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n")
                    }
                    function isFlattenable(value) {
                        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
                    }
                    function isIndex(value, length) {
                        var type = typeof value;
                        return !!(length = null == length ? MAX_SAFE_INTEGER : length) && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length
                    }
                    function isIterateeCall(value, index, object) {
                        if (!isObject(object))
                            return !1;
                        var type = typeof index;
                        return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value)
                    }
                    function isKey(value, object) {
                        if (isArray(value))
                            return !1;
                        var type = typeof value;
                        return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object)
                    }
                    function isKeyable(value) {
                        var type = typeof value;
                        return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value
                    }
                    function isLaziable(func) {
                        var funcName = getFuncName(func)
                          , other = lodash[funcName];
                        if ("function" != typeof other || !(funcName in LazyWrapper.prototype))
                            return !1;
                        if (func === other)
                            return !0;
                        var data = getData(other);
                        return !!data && func === data[0]
                    }
                    function isMasked(func) {
                        return !!maskSrcKey && maskSrcKey in func
                    }
                    function isPrototype(value) {
                        var Ctor = value && value.constructor;
                        return value === ("function" == typeof Ctor && Ctor.prototype || objectProto)
                    }
                    function isStrictComparable(value) {
                        return value === value && !isObject(value)
                    }
                    function matchesStrictComparable(key, srcValue) {
                        return function(object) {
                            return null != object && object[key] === srcValue && (srcValue !== undefined || key in Object(object))
                        }
                    }
                    function mergeData(data, source) {
                        var bitmask = data[1]
                          , srcBitmask = source[1]
                          , newBitmask = bitmask | srcBitmask
                          , isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG)
                          , isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                        if (!isCommon && !isCombo)
                            return data;
                        srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2],
                        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
                        var value = source[3];
                        if (value) {
                            var partials = data[3];
                            data[3] = partials ? composeArgs(partials, value, source[4]) : value,
                            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
                        }
                        return (value = source[5]) && (partials = data[5],
                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value,
                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]),
                        (value = source[7]) && (data[7] = value),
                        srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])),
                        null == data[9] && (data[9] = source[9]),
                        data[0] = source[0],
                        data[1] = newBitmask,
                        data
                    }
                    function nativeKeysIn(object) {
                        var result = [];
                        if (null != object)
                            for (var key in Object(object))
                                result.push(key);
                        return result
                    }
                    function objectToString(value) {
                        return nativeObjectToString.call(value)
                    }
                    function overRest(func, start, transform) {
                        return start = nativeMax(start === undefined ? func.length - 1 : start, 0),
                        function() {
                            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length; )
                                array[index] = args[start + index];
                            index = -1;
                            for (var otherArgs = Array(start + 1); ++index < start; )
                                otherArgs[index] = args[index];
                            return otherArgs[start] = transform(array),
                            apply(func, this, otherArgs)
                        }
                    }
                    function parent(object, path) {
                        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
                    }
                    function reorder(array, indexes) {
                        for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
                            var index = indexes[length];
                            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                        }
                        return array
                    }
                    function safeGet(object, key) {
                        if ("__proto__" != key)
                            return object[key]
                    }
                    function setWrapToString(wrapper, reference, bitmask) {
                        var source = reference + "";
                        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
                    }
                    function shortOut(func) {
                        var count = 0
                          , lastCalled = 0;
                        return function() {
                            var stamp = nativeNow()
                              , remaining = HOT_SPAN - (stamp - lastCalled);
                            if (lastCalled = stamp,
                            remaining > 0) {
                                if (++count >= HOT_COUNT)
                                    return arguments[0]
                            } else
                                count = 0;
                            return func.apply(undefined, arguments)
                        }
                    }
                    function shuffleSelf(array, size) {
                        var index = -1
                          , length = array.length
                          , lastIndex = length - 1;
                        for (size = size === undefined ? length : size; ++index < size; ) {
                            var rand = baseRandom(index, lastIndex)
                              , value = array[rand];
                            array[rand] = array[index],
                            array[index] = value
                        }
                        return array.length = size,
                        array
                    }
                    function toKey(value) {
                        if ("string" == typeof value || isSymbol(value))
                            return value;
                        var result = value + "";
                        return "0" == result && 1 / value == -INFINITY ? "-0" : result
                    }
                    function toSource(func) {
                        if (null != func) {
                            try {
                                return funcToString.call(func)
                            } catch (e) {}
                            try {
                                return func + ""
                            } catch (e) {}
                        }
                        return ""
                    }
                    function updateWrapDetails(details, bitmask) {
                        return arrayEach(wrapFlags, function(pair) {
                            var value = "_." + pair[0];
                            bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value)
                        }),
                        details.sort()
                    }
                    function wrapperClone(wrapper) {
                        if (wrapper instanceof LazyWrapper)
                            return wrapper.clone();
                        var result = new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);
                        return result.__actions__ = copyArray(wrapper.__actions__),
                        result.__index__ = wrapper.__index__,
                        result.__values__ = wrapper.__values__,
                        result
                    }
                    function findIndex(array, predicate, fromIndex) {
                        var length = null == array ? 0 : array.length;
                        if (!length)
                            return -1;
                        var index = null == fromIndex ? 0 : toInteger(fromIndex);
                        return index < 0 && (index = nativeMax(length + index, 0)),
                        baseFindIndex(array, getIteratee(predicate, 3), index)
                    }
                    function findLastIndex(array, predicate, fromIndex) {
                        var length = null == array ? 0 : array.length;
                        if (!length)
                            return -1;
                        var index = length - 1;
                        return fromIndex !== undefined && (index = toInteger(fromIndex),
                        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)),
                        baseFindIndex(array, getIteratee(predicate, 3), index, !0)
                    }
                    function flatten(array) {
                        return (null == array ? 0 : array.length) ? baseFlatten(array, 1) : []
                    }
                    function head(array) {
                        return array && array.length ? array[0] : undefined
                    }
                    function last(array) {
                        var length = null == array ? 0 : array.length;
                        return length ? array[length - 1] : undefined
                    }
                    function pullAll(array, values) {
                        return array && array.length && values && values.length ? basePullAll(array, values) : array
                    }
                    function reverse(array) {
                        return null == array ? array : nativeReverse.call(array)
                    }
                    function unzip(array) {
                        if (!array || !array.length)
                            return [];
                        var length = 0;
                        return array = arrayFilter(array, function(group) {
                            if (isArrayLikeObject(group))
                                return length = nativeMax(group.length, length),
                                !0
                        }),
                        baseTimes(length, function(index) {
                            return arrayMap(array, baseProperty(index))
                        })
                    }
                    function unzipWith(array, iteratee) {
                        if (!array || !array.length)
                            return [];
                        var result = unzip(array);
                        return null == iteratee ? result : arrayMap(result, function(group) {
                            return apply(iteratee, undefined, group)
                        })
                    }
                    function chain(value) {
                        var result = lodash(value);
                        return result.__chain__ = !0,
                        result
                    }
                    function thru(value, interceptor) {
                        return interceptor(value)
                    }
                    function forEach(collection, iteratee) {
                        return (isArray(collection) ? arrayEach : baseEach)(collection, getIteratee(iteratee, 3))
                    }
                    function forEachRight(collection, iteratee) {
                        return (isArray(collection) ? arrayEachRight : baseEachRight)(collection, getIteratee(iteratee, 3))
                    }
                    function map(collection, iteratee) {
                        return (isArray(collection) ? arrayMap : baseMap)(collection, getIteratee(iteratee, 3))
                    }
                    function ary(func, n, guard) {
                        return n = guard ? undefined : n,
                        n = func && null == n ? func.length : n,
                        createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)
                    }
                    function before(n, func) {
                        var result;
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return n = toInteger(n),
                        function() {
                            return --n > 0 && (result = func.apply(this, arguments)),
                            n <= 1 && (func = undefined),
                            result
                        }
                    }
                    function curry(func, arity, guard) {
                        var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity = guard ? undefined : arity);
                        return result.placeholder = curry.placeholder,
                        result
                    }
                    function curryRight(func, arity, guard) {
                        var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity = guard ? undefined : arity);
                        return result.placeholder = curryRight.placeholder,
                        result
                    }
                    function debounce(func, wait, options) {
                        function invokeFunc(time) {
                            var args = lastArgs
                              , thisArg = lastThis;
                            return lastArgs = lastThis = undefined,
                            lastInvokeTime = time,
                            result = func.apply(thisArg, args)
                        }
                        function leadingEdge(time) {
                            return lastInvokeTime = time,
                            timerId = setTimeout(timerExpired, wait),
                            leading ? invokeFunc(time) : result
                        }
                        function remainingWait(time) {
                            var timeSinceLastInvoke = time - lastInvokeTime
                              , timeWaiting = wait - (time - lastCallTime);
                            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting
                        }
                        function shouldInvoke(time) {
                            var timeSinceLastCall = time - lastCallTime
                              , timeSinceLastInvoke = time - lastInvokeTime;
                            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait
                        }
                        function timerExpired() {
                            var time = now();
                            if (shouldInvoke(time))
                                return trailingEdge(time);
                            timerId = setTimeout(timerExpired, remainingWait(time))
                        }
                        function trailingEdge(time) {
                            return timerId = undefined,
                            trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined,
                            result)
                        }
                        function debounced() {
                            var time = now()
                              , isInvoking = shouldInvoke(time);
                            if (lastArgs = arguments,
                            lastThis = this,
                            lastCallTime = time,
                            isInvoking) {
                                if (timerId === undefined)
                                    return leadingEdge(lastCallTime);
                                if (maxing)
                                    return timerId = setTimeout(timerExpired, wait),
                                    invokeFunc(lastCallTime)
                            }
                            return timerId === undefined && (timerId = setTimeout(timerExpired, wait)),
                            result
                        }
                        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return wait = toNumber(wait) || 0,
                        isObject(options) && (leading = !!options.leading,
                        maxWait = (maxing = "maxWait"in options) ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait,
                        trailing = "trailing"in options ? !!options.trailing : trailing),
                        debounced.cancel = function() {
                            timerId !== undefined && clearTimeout(timerId),
                            lastInvokeTime = 0,
                            lastArgs = lastCallTime = lastThis = timerId = undefined
                        }
                        ,
                        debounced.flush = function() {
                            return timerId === undefined ? result : trailingEdge(now())
                        }
                        ,
                        debounced
                    }
                    function memoize(func, resolver) {
                        if ("function" != typeof func || null != resolver && "function" != typeof resolver)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        var memoized = function() {
                            var args = arguments
                              , key = resolver ? resolver.apply(this, args) : args[0]
                              , cache = memoized.cache;
                            if (cache.has(key))
                                return cache.get(key);
                            var result = func.apply(this, args);
                            return memoized.cache = cache.set(key, result) || cache,
                            result
                        };
                        return memoized.cache = new (memoize.Cache || MapCache),
                        memoized
                    }
                    function negate(predicate) {
                        if ("function" != typeof predicate)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return function() {
                            var args = arguments;
                            switch (args.length) {
                            case 0:
                                return !predicate.call(this);
                            case 1:
                                return !predicate.call(this, args[0]);
                            case 2:
                                return !predicate.call(this, args[0], args[1]);
                            case 3:
                                return !predicate.call(this, args[0], args[1], args[2])
                            }
                            return !predicate.apply(this, args)
                        }
                    }
                    function eq(value, other) {
                        return value === other || value !== value && other !== other
                    }
                    function isArrayLike(value) {
                        return null != value && isLength(value.length) && !isFunction(value)
                    }
                    function isArrayLikeObject(value) {
                        return isObjectLike(value) && isArrayLike(value)
                    }
                    function isError(value) {
                        if (!isObjectLike(value))
                            return !1;
                        var tag = baseGetTag(value);
                        return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value)
                    }
                    function isFunction(value) {
                        if (!isObject(value))
                            return !1;
                        var tag = baseGetTag(value);
                        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
                    }
                    function isInteger(value) {
                        return "number" == typeof value && value == toInteger(value)
                    }
                    function isLength(value) {
                        return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
                    }
                    function isObject(value) {
                        var type = typeof value;
                        return null != value && ("object" == type || "function" == type)
                    }
                    function isObjectLike(value) {
                        return null != value && "object" == typeof value
                    }
                    function isNumber(value) {
                        return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag
                    }
                    function isPlainObject(value) {
                        if (!isObjectLike(value) || baseGetTag(value) != objectTag)
                            return !1;
                        var proto = getPrototype(value);
                        if (null === proto)
                            return !0;
                        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                        return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
                    }
                    function isString(value) {
                        return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
                    }
                    function isSymbol(value) {
                        return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag
                    }
                    function toArray(value) {
                        if (!value)
                            return [];
                        if (isArrayLike(value))
                            return isString(value) ? stringToArray(value) : copyArray(value);
                        if (symIterator && value[symIterator])
                            return iteratorToArray(value[symIterator]());
                        var tag = getTag(value);
                        return (tag == mapTag ? mapToArray : tag == setTag ? setToArray : values)(value)
                    }
                    function toFinite(value) {
                        return value ? (value = toNumber(value)) === INFINITY || value === -INFINITY ? (value < 0 ? -1 : 1) * MAX_INTEGER : value === value ? value : 0 : 0 === value ? value : 0
                    }
                    function toInteger(value) {
                        var result = toFinite(value)
                          , remainder = result % 1;
                        return result === result ? remainder ? result - remainder : result : 0
                    }
                    function toLength(value) {
                        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
                    }
                    function toNumber(value) {
                        if ("number" == typeof value)
                            return value;
                        if (isSymbol(value))
                            return NAN;
                        if (isObject(value)) {
                            var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                            value = isObject(other) ? other + "" : other
                        }
                        if ("string" != typeof value)
                            return 0 === value ? value : +value;
                        value = value.replace(reTrim, "");
                        var isBinary = reIsBinary.test(value);
                        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
                    }
                    function toPlainObject(value) {
                        return copyObject(value, keysIn(value))
                    }
                    function toString(value) {
                        return null == value ? "" : baseToString(value)
                    }
                    function get(object, path, defaultValue) {
                        var result = null == object ? undefined : baseGet(object, path);
                        return result === undefined ? defaultValue : result
                    }
                    function hasIn(object, path) {
                        return null != object && hasPath(object, path, baseHasIn)
                    }
                    function keys(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
                    }
                    function keysIn(object) {
                        return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object)
                    }
                    function pickBy(object, predicate) {
                        if (null == object)
                            return {};
                        var props = arrayMap(getAllKeysIn(object), function(prop) {
                            return [prop]
                        });
                        return predicate = getIteratee(predicate),
                        basePickBy(object, props, function(value, path) {
                            return predicate(value, path[0])
                        })
                    }
                    function values(object) {
                        return null == object ? [] : baseValues(object, keys(object))
                    }
                    function capitalize(string) {
                        return upperFirst(toString(string).toLowerCase())
                    }
                    function deburr(string) {
                        return (string = toString(string)) && string.replace(reLatin, deburrLetter).replace(reComboMark, "")
                    }
                    function words(string, pattern, guard) {
                        return string = toString(string),
                        (pattern = guard ? undefined : pattern) === undefined ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || []
                    }
                    function constant(value) {
                        return function() {
                            return value
                        }
                    }
                    function identity(value) {
                        return value
                    }
                    function iteratee(func) {
                        return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG))
                    }
                    function mixin(object, source, options) {
                        var props = keys(source)
                          , methodNames = baseFunctions(source, props);
                        null != options || isObject(source) && (methodNames.length || !props.length) || (options = source,
                        source = object,
                        object = this,
                        methodNames = baseFunctions(source, keys(source)));
                        var chain = !(isObject(options) && "chain"in options && !options.chain)
                          , isFunc = isFunction(object);
                        return arrayEach(methodNames, function(methodName) {
                            var func = source[methodName];
                            object[methodName] = func,
                            isFunc && (object.prototype[methodName] = function() {
                                var chainAll = this.__chain__;
                                if (chain || chainAll) {
                                    var result = object(this.__wrapped__);
                                    return (result.__actions__ = copyArray(this.__actions__)).push({
                                        func: func,
                                        args: arguments,
                                        thisArg: object
                                    }),
                                    result.__chain__ = chainAll,
                                    result
                                }
                                return func.apply(object, arrayPush([this.value()], arguments))
                            }
                            )
                        }),
                        object
                    }
                    function noop() {}
                    function property(path) {
                        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
                    }
                    function stubArray() {
                        return []
                    }
                    function stubFalse() {
                        return !1
                    }
                    var Array = (context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps))).Array
                      , Date = context.Date
                      , Error = context.Error
                      , Function = context.Function
                      , Math = context.Math
                      , Object = context.Object
                      , RegExp = context.RegExp
                      , String = context.String
                      , TypeError = context.TypeError
                      , arrayProto = Array.prototype
                      , funcProto = Function.prototype
                      , objectProto = Object.prototype
                      , coreJsData = context["__core-js_shared__"]
                      , funcToString = funcProto.toString
                      , hasOwnProperty = objectProto.hasOwnProperty
                      , idCounter = 0
                      , maskSrcKey = function() {
                        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                        return uid ? "Symbol(src)_1." + uid : ""
                    }()
                      , nativeObjectToString = objectProto.toString
                      , objectCtorString = funcToString.call(Object)
                      , oldDash = root._
                      , reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
                      , Buffer = moduleExports ? context.Buffer : undefined
                      , Symbol = context.Symbol
                      , Uint8Array = context.Uint8Array
                      , allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined
                      , getPrototype = overArg(Object.getPrototypeOf, Object)
                      , objectCreate = Object.create
                      , propertyIsEnumerable = objectProto.propertyIsEnumerable
                      , splice = arrayProto.splice
                      , spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined
                      , symIterator = Symbol ? Symbol.iterator : undefined
                      , symToStringTag = Symbol ? Symbol.toStringTag : undefined
                      , defineProperty = function() {
                        try {
                            var func = getNative(Object, "defineProperty");
                            return func({}, "", {}),
                            func
                        } catch (e) {}
                    }()
                      , ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout
                      , ctxNow = Date && Date.now !== root.Date.now && Date.now
                      , ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout
                      , nativeCeil = Math.ceil
                      , nativeFloor = Math.floor
                      , nativeGetSymbols = Object.getOwnPropertySymbols
                      , nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined
                      , nativeIsFinite = context.isFinite
                      , nativeJoin = arrayProto.join
                      , nativeKeys = overArg(Object.keys, Object)
                      , nativeMax = Math.max
                      , nativeMin = Math.min
                      , nativeNow = Date.now
                      , nativeParseInt = context.parseInt
                      , nativeRandom = Math.random
                      , nativeReverse = arrayProto.reverse
                      , DataView = getNative(context, "DataView")
                      , Map = getNative(context, "Map")
                      , Promise = getNative(context, "Promise")
                      , Set = getNative(context, "Set")
                      , WeakMap = getNative(context, "WeakMap")
                      , nativeCreate = getNative(Object, "create")
                      , metaMap = WeakMap && new WeakMap
                      , realNames = {}
                      , dataViewCtorString = toSource(DataView)
                      , mapCtorString = toSource(Map)
                      , promiseCtorString = toSource(Promise)
                      , setCtorString = toSource(Set)
                      , weakMapCtorString = toSource(WeakMap)
                      , symbolProto = Symbol ? Symbol.prototype : undefined
                      , symbolValueOf = symbolProto ? symbolProto.valueOf : undefined
                      , symbolToString = symbolProto ? symbolProto.toString : undefined
                      , baseCreate = function() {
                        function object() {}
                        return function(proto) {
                            if (!isObject(proto))
                                return {};
                            if (objectCreate)
                                return objectCreate(proto);
                            object.prototype = proto;
                            var result = new object;
                            return object.prototype = undefined,
                            result
                        }
                    }();
                    lodash.templateSettings = {
                        escape: reEscape,
                        evaluate: reEvaluate,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    },
                    lodash.prototype = baseLodash.prototype,
                    lodash.prototype.constructor = lodash,
                    LodashWrapper.prototype = baseCreate(baseLodash.prototype),
                    LodashWrapper.prototype.constructor = LodashWrapper,
                    LazyWrapper.prototype = baseCreate(baseLodash.prototype),
                    LazyWrapper.prototype.constructor = LazyWrapper,
                    Hash.prototype.clear = function() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {},
                        this.size = 0
                    }
                    ,
                    Hash.prototype.delete = function(key) {
                        var result = this.has(key) && delete this.__data__[key];
                        return this.size -= result ? 1 : 0,
                        result
                    }
                    ,
                    Hash.prototype.get = function(key) {
                        var data = this.__data__;
                        if (nativeCreate) {
                            var result = data[key];
                            return result === HASH_UNDEFINED ? undefined : result
                        }
                        return hasOwnProperty.call(data, key) ? data[key] : undefined
                    }
                    ,
                    Hash.prototype.has = function(key) {
                        var data = this.__data__;
                        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
                    }
                    ,
                    Hash.prototype.set = function(key, value) {
                        var data = this.__data__;
                        return this.size += this.has(key) ? 0 : 1,
                        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value,
                        this
                    }
                    ,
                    ListCache.prototype.clear = function() {
                        this.__data__ = [],
                        this.size = 0
                    }
                    ,
                    ListCache.prototype.delete = function(key) {
                        var data = this.__data__
                          , index = assocIndexOf(data, key);
                        return !(index < 0 || (index == data.length - 1 ? data.pop() : splice.call(data, index, 1),
                        --this.size,
                        0))
                    }
                    ,
                    ListCache.prototype.get = function(key) {
                        var data = this.__data__
                          , index = assocIndexOf(data, key);
                        return index < 0 ? undefined : data[index][1]
                    }
                    ,
                    ListCache.prototype.has = function(key) {
                        return assocIndexOf(this.__data__, key) > -1
                    }
                    ,
                    ListCache.prototype.set = function(key, value) {
                        var data = this.__data__
                          , index = assocIndexOf(data, key);
                        return index < 0 ? (++this.size,
                        data.push([key, value])) : data[index][1] = value,
                        this
                    }
                    ,
                    MapCache.prototype.clear = function() {
                        this.size = 0,
                        this.__data__ = {
                            hash: new Hash,
                            map: new (Map || ListCache),
                            string: new Hash
                        }
                    }
                    ,
                    MapCache.prototype.delete = function(key) {
                        var result = getMapData(this, key).delete(key);
                        return this.size -= result ? 1 : 0,
                        result
                    }
                    ,
                    MapCache.prototype.get = function(key) {
                        return getMapData(this, key).get(key)
                    }
                    ,
                    MapCache.prototype.has = function(key) {
                        return getMapData(this, key).has(key)
                    }
                    ,
                    MapCache.prototype.set = function(key, value) {
                        var data = getMapData(this, key)
                          , size = data.size;
                        return data.set(key, value),
                        this.size += data.size == size ? 0 : 1,
                        this
                    }
                    ,
                    SetCache.prototype.add = SetCache.prototype.push = function(value) {
                        return this.__data__.set(value, HASH_UNDEFINED),
                        this
                    }
                    ,
                    SetCache.prototype.has = function(value) {
                        return this.__data__.has(value)
                    }
                    ,
                    Stack.prototype.clear = function() {
                        this.__data__ = new ListCache,
                        this.size = 0
                    }
                    ,
                    Stack.prototype.delete = function(key) {
                        var data = this.__data__
                          , result = data.delete(key);
                        return this.size = data.size,
                        result
                    }
                    ,
                    Stack.prototype.get = function(key) {
                        return this.__data__.get(key)
                    }
                    ,
                    Stack.prototype.has = function(key) {
                        return this.__data__.has(key)
                    }
                    ,
                    Stack.prototype.set = function(key, value) {
                        var data = this.__data__;
                        if (data instanceof ListCache) {
                            var pairs = data.__data__;
                            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1)
                                return pairs.push([key, value]),
                                this.size = ++data.size,
                                this;
                            data = this.__data__ = new MapCache(pairs)
                        }
                        return data.set(key, value),
                        this.size = data.size,
                        this
                    }
                    ;
                    var baseEach = createBaseEach(baseForOwn)
                      , baseEachRight = createBaseEach(baseForOwnRight, !0)
                      , baseFor = createBaseFor()
                      , baseForRight = createBaseFor(!0)
                      , baseSetData = metaMap ? function(func, data) {
                        return metaMap.set(func, data),
                        func
                    }
                    : identity
                      , baseSetToString = defineProperty ? function(func, string) {
                        return defineProperty(func, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: constant(string),
                            writable: !0
                        })
                    }
                    : identity
                      , castRest = baseRest
                      , clearTimeout = ctxClearTimeout || function(id) {
                        return root.clearTimeout(id)
                    }
                      , createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function(values) {
                        return new Set(values)
                    }
                    : noop
                      , getData = metaMap ? function(func) {
                        return metaMap.get(func)
                    }
                    : noop
                      , getSymbols = nativeGetSymbols ? function(object) {
                        return null == object ? [] : (object = Object(object),
                        arrayFilter(nativeGetSymbols(object), function(symbol) {
                            return propertyIsEnumerable.call(object, symbol)
                        }))
                    }
                    : stubArray
                      , getSymbolsIn = nativeGetSymbols ? function(object) {
                        for (var result = []; object; )
                            arrayPush(result, getSymbols(object)),
                            object = getPrototype(object);
                        return result
                    }
                    : stubArray
                      , getTag = baseGetTag;
                    (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && "[object Promise]" != getTag(Promise.resolve()) || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function(value) {
                        var result = baseGetTag(value)
                          , Ctor = result == objectTag ? value.constructor : undefined
                          , ctorString = Ctor ? toSource(Ctor) : "";
                        if (ctorString)
                            switch (ctorString) {
                            case dataViewCtorString:
                                return dataViewTag;
                            case mapCtorString:
                                return mapTag;
                            case promiseCtorString:
                                return "[object Promise]";
                            case setCtorString:
                                return setTag;
                            case weakMapCtorString:
                                return weakMapTag
                            }
                        return result
                    }
                    );
                    var isMaskable = coreJsData ? isFunction : stubFalse
                      , setData = shortOut(baseSetData)
                      , setTimeout = ctxSetTimeout || function(func, wait) {
                        return root.setTimeout(func, wait)
                    }
                      , setToString = shortOut(baseSetToString)
                      , stringToPath = function(func) {
                        var result = memoize(func, function(key) {
                            return cache.size === MAX_MEMOIZE_SIZE && cache.clear(),
                            key
                        })
                          , cache = result.cache;
                        return result
                    }(function(string) {
                        var result = [];
                        return 46 === string.charCodeAt(0) && result.push(""),
                        string.replace(rePropName, function(match, number, quote, subString) {
                            result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match)
                        }),
                        result
                    })
                      , difference = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : []
                    })
                      , differenceBy = baseRest(function(array, values) {
                        var iteratee = last(values);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined),
                        isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : []
                    })
                      , differenceWith = baseRest(function(array, values) {
                        var comparator = last(values);
                        return isArrayLikeObject(comparator) && (comparator = undefined),
                        isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : []
                    })
                      , intersection = baseRest(function(arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
                    })
                      , intersectionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays)
                          , mapped = arrayMap(arrays, castArrayLikeObject);
                        return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(),
                        mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
                    })
                      , intersectionWith = baseRest(function(arrays) {
                        var comparator = last(arrays)
                          , mapped = arrayMap(arrays, castArrayLikeObject);
                        return (comparator = "function" == typeof comparator ? comparator : undefined) && mapped.pop(),
                        mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
                    })
                      , pull = baseRest(pullAll)
                      , pullAt = flatRest(function(array, indexes) {
                        var length = null == array ? 0 : array.length
                          , result = baseAt(array, indexes);
                        return basePullAt(array, arrayMap(indexes, function(index) {
                            return isIndex(index, length) ? +index : index
                        }).sort(compareAscending)),
                        result
                    })
                      , union = baseRest(function(arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0))
                    })
                      , unionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined),
                        baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2))
                    })
                      , unionWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        return comparator = "function" == typeof comparator ? comparator : undefined,
                        baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator)
                    })
                      , without = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, values) : []
                    })
                      , xor = baseRest(function(arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject))
                    })
                      , xorBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined),
                        baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
                    })
                      , xorWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        return comparator = "function" == typeof comparator ? comparator : undefined,
                        baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
                    })
                      , zip = baseRest(unzip)
                      , zipWith = baseRest(function(arrays) {
                        var length = arrays.length
                          , iteratee = length > 1 ? arrays[length - 1] : undefined;
                        return iteratee = "function" == typeof iteratee ? (arrays.pop(),
                        iteratee) : undefined,
                        unzipWith(arrays, iteratee)
                    })
                      , wrapperAt = flatRest(function(paths) {
                        var length = paths.length
                          , start = length ? paths[0] : 0
                          , value = this.__wrapped__
                          , interceptor = function(object) {
                            return baseAt(object, paths)
                        };
                        return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? ((value = value.slice(start, +start + (length ? 1 : 0))).__actions__.push({
                            func: thru,
                            args: [interceptor],
                            thisArg: undefined
                        }),
                        new LodashWrapper(value,this.__chain__).thru(function(array) {
                            return length && !array.length && array.push(undefined),
                            array
                        })) : this.thru(interceptor)
                    })
                      , countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1)
                    })
                      , find = createFind(findIndex)
                      , findLast = createFind(findLastIndex)
                      , groupBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value])
                    })
                      , invokeMap = baseRest(function(collection, path, args) {
                        var index = -1
                          , isFunc = "function" == typeof path
                          , result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function(value) {
                            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
                        }),
                        result
                    })
                      , keyBy = createAggregator(function(result, value, key) {
                        baseAssignValue(result, key, value)
                    })
                      , partition = createAggregator(function(result, value, key) {
                        result[key ? 0 : 1].push(value)
                    }, function() {
                        return [[], []]
                    })
                      , sortBy = baseRest(function(collection, iteratees) {
                        if (null == collection)
                            return [];
                        var length = iteratees.length;
                        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]),
                        baseOrderBy(collection, baseFlatten(iteratees, 1), [])
                    })
                      , now = ctxNow || function() {
                        return root.Date.now()
                    }
                      , bind = baseRest(function(func, thisArg, partials) {
                        var bitmask = WRAP_BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bind));
                            bitmask |= WRAP_PARTIAL_FLAG
                        }
                        return createWrap(func, bitmask, thisArg, partials, holders)
                    })
                      , bindKey = baseRest(function(object, key, partials) {
                        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bindKey));
                            bitmask |= WRAP_PARTIAL_FLAG
                        }
                        return createWrap(key, bitmask, object, partials, holders)
                    })
                      , defer = baseRest(function(func, args) {
                        return baseDelay(func, 1, args)
                    })
                      , delay = baseRest(function(func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args)
                    });
                    memoize.Cache = MapCache;
                    var overArgs = castRest(function(func, transforms) {
                        var funcsLength = (transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()))).length;
                        return baseRest(function(args) {
                            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
                                args[index] = transforms[index].call(this, args[index]);
                            return apply(func, this, args)
                        })
                    })
                      , partial = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders)
                    })
                      , partialRight = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders)
                    })
                      , rearg = flatRest(function(func, indexes) {
                        return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes)
                    })
                      , gt = createRelationalOperation(baseGt)
                      , gte = createRelationalOperation(function(value, other) {
                        return value >= other
                    })
                      , isArguments = baseIsArguments(function() {
                        return arguments
                    }()) ? baseIsArguments : function(value) {
                        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
                    }
                      , isArray = Array.isArray
                      , isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : function(value) {
                        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
                    }
                      , isBuffer = nativeIsBuffer || stubFalse
                      , isDate = nodeIsDate ? baseUnary(nodeIsDate) : function(value) {
                        return isObjectLike(value) && baseGetTag(value) == dateTag
                    }
                      , isMap = nodeIsMap ? baseUnary(nodeIsMap) : function(value) {
                        return isObjectLike(value) && getTag(value) == mapTag
                    }
                      , isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : function(value) {
                        return isObjectLike(value) && baseGetTag(value) == regexpTag
                    }
                      , isSet = nodeIsSet ? baseUnary(nodeIsSet) : function(value) {
                        return isObjectLike(value) && getTag(value) == setTag
                    }
                      , isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : function(value) {
                        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
                    }
                      , lt = createRelationalOperation(baseLt)
                      , lte = createRelationalOperation(function(value, other) {
                        return value <= other
                    })
                      , assign = createAssigner(function(object, source) {
                        if (isPrototype(source) || isArrayLike(source))
                            copyObject(source, keys(source), object);
                        else
                            for (var key in source)
                                hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
                    })
                      , assignIn = createAssigner(function(object, source) {
                        copyObject(source, keysIn(source), object)
                    })
                      , assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer)
                    })
                      , assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer)
                    })
                      , at = flatRest(baseAt)
                      , defaults = baseRest(function(object, sources) {
                        object = Object(object);
                        var index = -1
                          , length = sources.length
                          , guard = length > 2 ? sources[2] : undefined;
                        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
                            for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
                                var key = props[propsIndex]
                                  , value = object[key];
                                (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key])
                            }
                        return object
                    })
                      , defaultsDeep = baseRest(function(args) {
                        return args.push(undefined, customDefaultsMerge),
                        apply(mergeWith, undefined, args)
                    })
                      , invert = createInverter(function(result, value, key) {
                        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)),
                        result[value] = key
                    }, constant(identity))
                      , invertBy = createInverter(function(result, value, key) {
                        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)),
                        hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key]
                    }, getIteratee)
                      , invoke = baseRest(baseInvoke)
                      , merge = createAssigner(function(object, source, srcIndex) {
                        baseMerge(object, source, srcIndex)
                    })
                      , mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer)
                    })
                      , omit = flatRest(function(object, paths) {
                        var result = {};
                        if (null == object)
                            return result;
                        var isDeep = !1;
                        paths = arrayMap(paths, function(path) {
                            return path = castPath(path, object),
                            isDeep || (isDeep = path.length > 1),
                            path
                        }),
                        copyObject(object, getAllKeysIn(object), result),
                        isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
                        for (var length = paths.length; length--; )
                            baseUnset(result, paths[length]);
                        return result
                    })
                      , pick = flatRest(function(object, paths) {
                        return null == object ? {} : basePick(object, paths)
                    })
                      , toPairs = createToPairs(keys)
                      , toPairsIn = createToPairs(keysIn)
                      , camelCase = createCompounder(function(result, word, index) {
                        return word = word.toLowerCase(),
                        result + (index ? capitalize(word) : word)
                    })
                      , kebabCase = createCompounder(function(result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase()
                    })
                      , lowerCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + word.toLowerCase()
                    })
                      , lowerFirst = createCaseFirst("toLowerCase")
                      , snakeCase = createCompounder(function(result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase()
                    })
                      , startCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + upperFirst(word)
                    })
                      , upperCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + word.toUpperCase()
                    })
                      , upperFirst = createCaseFirst("toUpperCase")
                      , attempt = baseRest(function(func, args) {
                        try {
                            return apply(func, undefined, args)
                        } catch (e) {
                            return isError(e) ? e : new Error(e)
                        }
                    })
                      , bindAll = flatRest(function(object, methodNames) {
                        return arrayEach(methodNames, function(key) {
                            key = toKey(key),
                            baseAssignValue(object, key, bind(object[key], object))
                        }),
                        object
                    })
                      , flow = createFlow()
                      , flowRight = createFlow(!0)
                      , method = baseRest(function(path, args) {
                        return function(object) {
                            return baseInvoke(object, path, args)
                        }
                    })
                      , methodOf = baseRest(function(object, args) {
                        return function(path) {
                            return baseInvoke(object, path, args)
                        }
                    })
                      , over = createOver(arrayMap)
                      , overEvery = createOver(arrayEvery)
                      , overSome = createOver(arraySome)
                      , range = createRange()
                      , rangeRight = createRange(!0)
                      , add = createMathOperation(function(augend, addend) {
                        return augend + addend
                    }, 0)
                      , ceil = createRound("ceil")
                      , divide = createMathOperation(function(dividend, divisor) {
                        return dividend / divisor
                    }, 1)
                      , floor = createRound("floor")
                      , multiply = createMathOperation(function(multiplier, multiplicand) {
                        return multiplier * multiplicand
                    }, 1)
                      , round = createRound("round")
                      , subtract = createMathOperation(function(minuend, subtrahend) {
                        return minuend - subtrahend
                    }, 0);
                    return lodash.after = function(n, func) {
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return n = toInteger(n),
                        function() {
                            if (--n < 1)
                                return func.apply(this, arguments)
                        }
                    }
                    ,
                    lodash.ary = ary,
                    lodash.assign = assign,
                    lodash.assignIn = assignIn,
                    lodash.assignInWith = assignInWith,
                    lodash.assignWith = assignWith,
                    lodash.at = at,
                    lodash.before = before,
                    lodash.bind = bind,
                    lodash.bindAll = bindAll,
                    lodash.bindKey = bindKey,
                    lodash.castArray = function() {
                        if (!arguments.length)
                            return [];
                        var value = arguments[0];
                        return isArray(value) ? value : [value]
                    }
                    ,
                    lodash.chain = chain,
                    lodash.chunk = function(array, size, guard) {
                        size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
                        var length = null == array ? 0 : array.length;
                        if (!length || size < 1)
                            return [];
                        for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length; )
                            result[resIndex++] = baseSlice(array, index, index += size);
                        return result
                    }
                    ,
                    lodash.compact = function(array) {
                        for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
                            var value = array[index];
                            value && (result[resIndex++] = value)
                        }
                        return result
                    }
                    ,
                    lodash.concat = function() {
                        var length = arguments.length;
                        if (!length)
                            return [];
                        for (var args = Array(length - 1), array = arguments[0], index = length; index--; )
                            args[index - 1] = arguments[index];
                        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
                    }
                    ,
                    lodash.cond = function(pairs) {
                        var length = null == pairs ? 0 : pairs.length
                          , toIteratee = getIteratee();
                        return pairs = length ? arrayMap(pairs, function(pair) {
                            if ("function" != typeof pair[1])
                                throw new TypeError(FUNC_ERROR_TEXT);
                            return [toIteratee(pair[0]), pair[1]]
                        }) : [],
                        baseRest(function(args) {
                            for (var index = -1; ++index < length; ) {
                                var pair = pairs[index];
                                if (apply(pair[0], this, args))
                                    return apply(pair[1], this, args)
                            }
                        })
                    }
                    ,
                    lodash.conforms = function(source) {
                        return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
                    }
                    ,
                    lodash.constant = constant,
                    lodash.countBy = countBy,
                    lodash.create = function(prototype, properties) {
                        var result = baseCreate(prototype);
                        return null == properties ? result : baseAssign(result, properties)
                    }
                    ,
                    lodash.curry = curry,
                    lodash.curryRight = curryRight,
                    lodash.debounce = debounce,
                    lodash.defaults = defaults,
                    lodash.defaultsDeep = defaultsDeep,
                    lodash.defer = defer,
                    lodash.delay = delay,
                    lodash.difference = difference,
                    lodash.differenceBy = differenceBy,
                    lodash.differenceWith = differenceWith,
                    lodash.drop = function(array, n, guard) {
                        var length = null == array ? 0 : array.length;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n),
                        baseSlice(array, n < 0 ? 0 : n, length)) : []
                    }
                    ,
                    lodash.dropRight = function(array, n, guard) {
                        var length = null == array ? 0 : array.length;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n),
                        n = length - n,
                        baseSlice(array, 0, n < 0 ? 0 : n)) : []
                    }
                    ,
                    lodash.dropRightWhile = function(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : []
                    }
                    ,
                    lodash.dropWhile = function(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : []
                    }
                    ,
                    lodash.fill = function(array, value, start, end) {
                        var length = null == array ? 0 : array.length;
                        return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0,
                        end = length),
                        baseFill(array, value, start, end)) : []
                    }
                    ,
                    lodash.filter = function(collection, predicate) {
                        return (isArray(collection) ? arrayFilter : baseFilter)(collection, getIteratee(predicate, 3))
                    }
                    ,
                    lodash.flatMap = function(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), 1)
                    }
                    ,
                    lodash.flatMapDeep = function(collection, iteratee) {
                        return baseFlatten(map(collection, iteratee), INFINITY)
                    }
                    ,
                    lodash.flatMapDepth = function(collection, iteratee, depth) {
                        return depth = depth === undefined ? 1 : toInteger(depth),
                        baseFlatten(map(collection, iteratee), depth)
                    }
                    ,
                    lodash.flatten = flatten,
                    lodash.flattenDeep = function(array) {
                        return (null == array ? 0 : array.length) ? baseFlatten(array, INFINITY) : []
                    }
                    ,
                    lodash.flattenDepth = function(array, depth) {
                        return (null == array ? 0 : array.length) ? (depth = depth === undefined ? 1 : toInteger(depth),
                        baseFlatten(array, depth)) : []
                    }
                    ,
                    lodash.flip = function(func) {
                        return createWrap(func, WRAP_FLIP_FLAG)
                    }
                    ,
                    lodash.flow = flow,
                    lodash.flowRight = flowRight,
                    lodash.fromPairs = function(pairs) {
                        for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length; ) {
                            var pair = pairs[index];
                            result[pair[0]] = pair[1]
                        }
                        return result
                    }
                    ,
                    lodash.functions = function(object) {
                        return null == object ? [] : baseFunctions(object, keys(object))
                    }
                    ,
                    lodash.functionsIn = function(object) {
                        return null == object ? [] : baseFunctions(object, keysIn(object))
                    }
                    ,
                    lodash.groupBy = groupBy,
                    lodash.initial = function(array) {
                        return (null == array ? 0 : array.length) ? baseSlice(array, 0, -1) : []
                    }
                    ,
                    lodash.intersection = intersection,
                    lodash.intersectionBy = intersectionBy,
                    lodash.intersectionWith = intersectionWith,
                    lodash.invert = invert,
                    lodash.invertBy = invertBy,
                    lodash.invokeMap = invokeMap,
                    lodash.iteratee = iteratee,
                    lodash.keyBy = keyBy,
                    lodash.keys = keys,
                    lodash.keysIn = keysIn,
                    lodash.map = map,
                    lodash.mapKeys = function(object, iteratee) {
                        var result = {};
                        return iteratee = getIteratee(iteratee, 3),
                        baseForOwn(object, function(value, key, object) {
                            baseAssignValue(result, iteratee(value, key, object), value)
                        }),
                        result
                    }
                    ,
                    lodash.mapValues = function(object, iteratee) {
                        var result = {};
                        return iteratee = getIteratee(iteratee, 3),
                        baseForOwn(object, function(value, key, object) {
                            baseAssignValue(result, key, iteratee(value, key, object))
                        }),
                        result
                    }
                    ,
                    lodash.matches = function(source) {
                        return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
                    }
                    ,
                    lodash.matchesProperty = function(path, srcValue) {
                        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
                    }
                    ,
                    lodash.memoize = memoize,
                    lodash.merge = merge,
                    lodash.mergeWith = mergeWith,
                    lodash.method = method,
                    lodash.methodOf = methodOf,
                    lodash.mixin = mixin,
                    lodash.negate = negate,
                    lodash.nthArg = function(n) {
                        return n = toInteger(n),
                        baseRest(function(args) {
                            return baseNth(args, n)
                        })
                    }
                    ,
                    lodash.omit = omit,
                    lodash.omitBy = function(object, predicate) {
                        return pickBy(object, negate(getIteratee(predicate)))
                    }
                    ,
                    lodash.once = function(func) {
                        return before(2, func)
                    }
                    ,
                    lodash.orderBy = function(collection, iteratees, orders, guard) {
                        return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]),
                        orders = guard ? undefined : orders,
                        isArray(orders) || (orders = null == orders ? [] : [orders]),
                        baseOrderBy(collection, iteratees, orders))
                    }
                    ,
                    lodash.over = over,
                    lodash.overArgs = overArgs,
                    lodash.overEvery = overEvery,
                    lodash.overSome = overSome,
                    lodash.partial = partial,
                    lodash.partialRight = partialRight,
                    lodash.partition = partition,
                    lodash.pick = pick,
                    lodash.pickBy = pickBy,
                    lodash.property = property,
                    lodash.propertyOf = function(object) {
                        return function(path) {
                            return null == object ? undefined : baseGet(object, path)
                        }
                    }
                    ,
                    lodash.pull = pull,
                    lodash.pullAll = pullAll,
                    lodash.pullAllBy = function(array, values, iteratee) {
                        return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array
                    }
                    ,
                    lodash.pullAllWith = function(array, values, comparator) {
                        return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
                    }
                    ,
                    lodash.pullAt = pullAt,
                    lodash.range = range,
                    lodash.rangeRight = rangeRight,
                    lodash.rearg = rearg,
                    lodash.reject = function(collection, predicate) {
                        return (isArray(collection) ? arrayFilter : baseFilter)(collection, negate(getIteratee(predicate, 3)))
                    }
                    ,
                    lodash.remove = function(array, predicate) {
                        var result = [];
                        if (!array || !array.length)
                            return result;
                        var index = -1
                          , indexes = []
                          , length = array.length;
                        for (predicate = getIteratee(predicate, 3); ++index < length; ) {
                            var value = array[index];
                            predicate(value, index, array) && (result.push(value),
                            indexes.push(index))
                        }
                        return basePullAt(array, indexes),
                        result
                    }
                    ,
                    lodash.rest = function(func, start) {
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return start = start === undefined ? start : toInteger(start),
                        baseRest(func, start)
                    }
                    ,
                    lodash.reverse = reverse,
                    lodash.sampleSize = function(collection, n, guard) {
                        return n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n),
                        (isArray(collection) ? arraySampleSize : baseSampleSize)(collection, n)
                    }
                    ,
                    lodash.set = function(object, path, value) {
                        return null == object ? object : baseSet(object, path, value)
                    }
                    ,
                    lodash.setWith = function(object, path, value, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined,
                        null == object ? object : baseSet(object, path, value, customizer)
                    }
                    ,
                    lodash.shuffle = function(collection) {
                        return (isArray(collection) ? arrayShuffle : baseShuffle)(collection)
                    }
                    ,
                    lodash.slice = function(array, start, end) {
                        var length = null == array ? 0 : array.length;
                        return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0,
                        end = length) : (start = null == start ? 0 : toInteger(start),
                        end = end === undefined ? length : toInteger(end)),
                        baseSlice(array, start, end)) : []
                    }
                    ,
                    lodash.sortBy = sortBy,
                    lodash.sortedUniq = function(array) {
                        return array && array.length ? baseSortedUniq(array) : []
                    }
                    ,
                    lodash.sortedUniqBy = function(array, iteratee) {
                        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
                    }
                    ,
                    lodash.split = function(string, separator, limit) {
                        return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined),
                        (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string)) && ("string" == typeof separator || null != separator && !isRegExp(separator)) && !(separator = baseToString(separator)) && hasUnicode(string) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit) : []
                    }
                    ,
                    lodash.spread = function(func, start) {
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return start = null == start ? 0 : nativeMax(toInteger(start), 0),
                        baseRest(function(args) {
                            var array = args[start]
                              , otherArgs = castSlice(args, 0, start);
                            return array && arrayPush(otherArgs, array),
                            apply(func, this, otherArgs)
                        })
                    }
                    ,
                    lodash.tail = function(array) {
                        var length = null == array ? 0 : array.length;
                        return length ? baseSlice(array, 1, length) : []
                    }
                    ,
                    lodash.take = function(array, n, guard) {
                        return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n),
                        baseSlice(array, 0, n < 0 ? 0 : n)) : []
                    }
                    ,
                    lodash.takeRight = function(array, n, guard) {
                        var length = null == array ? 0 : array.length;
                        return length ? (n = guard || n === undefined ? 1 : toInteger(n),
                        n = length - n,
                        baseSlice(array, n < 0 ? 0 : n, length)) : []
                    }
                    ,
                    lodash.takeRightWhile = function(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : []
                    }
                    ,
                    lodash.takeWhile = function(array, predicate) {
                        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
                    }
                    ,
                    lodash.tap = function(value, interceptor) {
                        return interceptor(value),
                        value
                    }
                    ,
                    lodash.throttle = function(func, wait, options) {
                        var leading = !0
                          , trailing = !0;
                        if ("function" != typeof func)
                            throw new TypeError(FUNC_ERROR_TEXT);
                        return isObject(options) && (leading = "leading"in options ? !!options.leading : leading,
                        trailing = "trailing"in options ? !!options.trailing : trailing),
                        debounce(func, wait, {
                            leading: leading,
                            maxWait: wait,
                            trailing: trailing
                        })
                    }
                    ,
                    lodash.thru = thru,
                    lodash.toArray = toArray,
                    lodash.toPairs = toPairs,
                    lodash.toPairsIn = toPairsIn,
                    lodash.toPath = function(value) {
                        return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)))
                    }
                    ,
                    lodash.toPlainObject = toPlainObject,
                    lodash.transform = function(object, iteratee, accumulator) {
                        var isArr = isArray(object)
                          , isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                        if (iteratee = getIteratee(iteratee, 4),
                        null == accumulator) {
                            var Ctor = object && object.constructor;
                            accumulator = isArrLike ? isArr ? new Ctor : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
                        }
                        return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                            return iteratee(accumulator, value, index, object)
                        }),
                        accumulator
                    }
                    ,
                    lodash.unary = function(func) {
                        return ary(func, 1)
                    }
                    ,
                    lodash.union = union,
                    lodash.unionBy = unionBy,
                    lodash.unionWith = unionWith,
                    lodash.uniq = function(array) {
                        return array && array.length ? baseUniq(array) : []
                    }
                    ,
                    lodash.uniqBy = function(array, iteratee) {
                        return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
                    }
                    ,
                    lodash.uniqWith = function(array, comparator) {
                        return comparator = "function" == typeof comparator ? comparator : undefined,
                        array && array.length ? baseUniq(array, undefined, comparator) : []
                    }
                    ,
                    lodash.unset = function(object, path) {
                        return null == object || baseUnset(object, path)
                    }
                    ,
                    lodash.unzip = unzip,
                    lodash.unzipWith = unzipWith,
                    lodash.update = function(object, path, updater) {
                        return null == object ? object : baseUpdate(object, path, castFunction(updater))
                    }
                    ,
                    lodash.updateWith = function(object, path, updater, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined,
                        null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
                    }
                    ,
                    lodash.values = values,
                    lodash.valuesIn = function(object) {
                        return null == object ? [] : baseValues(object, keysIn(object))
                    }
                    ,
                    lodash.without = without,
                    lodash.words = words,
                    lodash.wrap = function(value, wrapper) {
                        return partial(castFunction(wrapper), value)
                    }
                    ,
                    lodash.xor = xor,
                    lodash.xorBy = xorBy,
                    lodash.xorWith = xorWith,
                    lodash.zip = zip,
                    lodash.zipObject = function(props, values) {
                        return baseZipObject(props || [], values || [], assignValue)
                    }
                    ,
                    lodash.zipObjectDeep = function(props, values) {
                        return baseZipObject(props || [], values || [], baseSet)
                    }
                    ,
                    lodash.zipWith = zipWith,
                    lodash.entries = toPairs,
                    lodash.entriesIn = toPairsIn,
                    lodash.extend = assignIn,
                    lodash.extendWith = assignInWith,
                    mixin(lodash, lodash),
                    lodash.add = add,
                    lodash.attempt = attempt,
                    lodash.camelCase = camelCase,
                    lodash.capitalize = capitalize,
                    lodash.ceil = ceil,
                    lodash.clamp = function(number, lower, upper) {
                        return upper === undefined && (upper = lower,
                        lower = undefined),
                        upper !== undefined && (upper = (upper = toNumber(upper)) === upper ? upper : 0),
                        lower !== undefined && (lower = (lower = toNumber(lower)) === lower ? lower : 0),
                        baseClamp(toNumber(number), lower, upper)
                    }
                    ,
                    lodash.clone = function(value) {
                        return baseClone(value, CLONE_SYMBOLS_FLAG)
                    }
                    ,
                    lodash.cloneDeep = function(value) {
                        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
                    }
                    ,
                    lodash.cloneDeepWith = function(value, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined,
                        baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)
                    }
                    ,
                    lodash.cloneWith = function(value, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined,
                        baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
                    }
                    ,
                    lodash.conformsTo = function(object, source) {
                        return null == source || baseConformsTo(object, source, keys(source))
                    }
                    ,
                    lodash.deburr = deburr,
                    lodash.defaultTo = function(value, defaultValue) {
                        return null == value || value !== value ? defaultValue : value
                    }
                    ,
                    lodash.divide = divide,
                    lodash.endsWith = function(string, target, position) {
                        string = toString(string),
                        target = baseToString(target);
                        var length = string.length
                          , end = position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                        return (position -= target.length) >= 0 && string.slice(position, end) == target
                    }
                    ,
                    lodash.eq = eq,
                    lodash.escape = function(string) {
                        return (string = toString(string)) && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
                    }
                    ,
                    lodash.escapeRegExp = function(string) {
                        return (string = toString(string)) && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
                    }
                    ,
                    lodash.every = function(collection, predicate, guard) {
                        var func = isArray(collection) ? arrayEvery : baseEvery;
                        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
                        func(collection, getIteratee(predicate, 3))
                    }
                    ,
                    lodash.find = find,
                    lodash.findIndex = findIndex,
                    lodash.findKey = function(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
                    }
                    ,
                    lodash.findLast = findLast,
                    lodash.findLastIndex = findLastIndex,
                    lodash.findLastKey = function(object, predicate) {
                        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
                    }
                    ,
                    lodash.floor = floor,
                    lodash.forEach = forEach,
                    lodash.forEachRight = forEachRight,
                    lodash.forIn = function(object, iteratee) {
                        return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
                    }
                    ,
                    lodash.forInRight = function(object, iteratee) {
                        return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
                    }
                    ,
                    lodash.forOwn = function(object, iteratee) {
                        return object && baseForOwn(object, getIteratee(iteratee, 3))
                    }
                    ,
                    lodash.forOwnRight = function(object, iteratee) {
                        return object && baseForOwnRight(object, getIteratee(iteratee, 3))
                    }
                    ,
                    lodash.get = get,
                    lodash.gt = gt,
                    lodash.gte = gte,
                    lodash.has = function(object, path) {
                        return null != object && hasPath(object, path, baseHas)
                    }
                    ,
                    lodash.hasIn = hasIn,
                    lodash.head = head,
                    lodash.identity = identity,
                    lodash.includes = function(collection, value, fromIndex, guard) {
                        collection = isArrayLike(collection) ? collection : values(collection),
                        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                        var length = collection.length;
                        return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)),
                        isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
                    }
                    ,
                    lodash.indexOf = function(array, value, fromIndex) {
                        var length = null == array ? 0 : array.length;
                        if (!length)
                            return -1;
                        var index = null == fromIndex ? 0 : toInteger(fromIndex);
                        return index < 0 && (index = nativeMax(length + index, 0)),
                        baseIndexOf(array, value, index)
                    }
                    ,
                    lodash.inRange = function(number, start, end) {
                        return start = toFinite(start),
                        end === undefined ? (end = start,
                        start = 0) : end = toFinite(end),
                        number = toNumber(number),
                        baseInRange(number, start, end)
                    }
                    ,
                    lodash.invoke = invoke,
                    lodash.isArguments = isArguments,
                    lodash.isArray = isArray,
                    lodash.isArrayBuffer = isArrayBuffer,
                    lodash.isArrayLike = isArrayLike,
                    lodash.isArrayLikeObject = isArrayLikeObject,
                    lodash.isBoolean = function(value) {
                        return !0 === value || !1 === value || isObjectLike(value) && baseGetTag(value) == boolTag
                    }
                    ,
                    lodash.isBuffer = isBuffer,
                    lodash.isDate = isDate,
                    lodash.isElement = function(value) {
                        return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value)
                    }
                    ,
                    lodash.isEmpty = function(value) {
                        if (null == value)
                            return !0;
                        if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value)))
                            return !value.length;
                        var tag = getTag(value);
                        if (tag == mapTag || tag == setTag)
                            return !value.size;
                        if (isPrototype(value))
                            return !baseKeys(value).length;
                        for (var key in value)
                            if (hasOwnProperty.call(value, key))
                                return !1;
                        return !0
                    }
                    ,
                    lodash.isEqual = function(value, other) {
                        return baseIsEqual(value, other)
                    }
                    ,
                    lodash.isEqualWith = function(value, other, customizer) {
                        var result = (customizer = "function" == typeof customizer ? customizer : undefined) ? customizer(value, other) : undefined;
                        return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
                    }
                    ,
                    lodash.isError = isError,
                    lodash.isFinite = function(value) {
                        return "number" == typeof value && nativeIsFinite(value)
                    }
                    ,
                    lodash.isFunction = isFunction,
                    lodash.isInteger = isInteger,
                    lodash.isLength = isLength,
                    lodash.isMap = isMap,
                    lodash.isMatch = function(object, source) {
                        return object === source || baseIsMatch(object, source, getMatchData(source))
                    }
                    ,
                    lodash.isMatchWith = function(object, source, customizer) {
                        return customizer = "function" == typeof customizer ? customizer : undefined,
                        baseIsMatch(object, source, getMatchData(source), customizer)
                    }
                    ,
                    lodash.isNaN = function(value) {
                        return isNumber(value) && value != +value
                    }
                    ,
                    lodash.isNative = function(value) {
                        if (isMaskable(value))
                            throw new Error(CORE_ERROR_TEXT);
                        return baseIsNative(value)
                    }
                    ,
                    lodash.isNil = function(value) {
                        return null == value
                    }
                    ,
                    lodash.isNull = function(value) {
                        return null === value
                    }
                    ,
                    lodash.isNumber = isNumber,
                    lodash.isObject = isObject,
                    lodash.isObjectLike = isObjectLike,
                    lodash.isPlainObject = isPlainObject,
                    lodash.isRegExp = isRegExp,
                    lodash.isSafeInteger = function(value) {
                        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER
                    }
                    ,
                    lodash.isSet = isSet,
                    lodash.isString = isString,
                    lodash.isSymbol = isSymbol,
                    lodash.isTypedArray = isTypedArray,
                    lodash.isUndefined = function(value) {
                        return value === undefined
                    }
                    ,
                    lodash.isWeakMap = function(value) {
                        return isObjectLike(value) && getTag(value) == weakMapTag
                    }
                    ,
                    lodash.isWeakSet = function(value) {
                        return isObjectLike(value) && baseGetTag(value) == weakSetTag
                    }
                    ,
                    lodash.join = function(array, separator) {
                        return null == array ? "" : nativeJoin.call(array, separator)
                    }
                    ,
                    lodash.kebabCase = kebabCase,
                    lodash.last = last,
                    lodash.lastIndexOf = function(array, value, fromIndex) {
                        var length = null == array ? 0 : array.length;
                        if (!length)
                            return -1;
                        var index = length;
                        return fromIndex !== undefined && (index = (index = toInteger(fromIndex)) < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)),
                        value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0)
                    }
                    ,
                    lodash.lowerCase = lowerCase,
                    lodash.lowerFirst = lowerFirst,
                    lodash.lt = lt,
                    lodash.lte = lte,
                    lodash.max = function(array) {
                        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
                    }
                    ,
                    lodash.maxBy = function(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
                    }
                    ,
                    lodash.mean = function(array) {
                        return baseMean(array, identity)
                    }
                    ,
                    lodash.meanBy = function(array, iteratee) {
                        return baseMean(array, getIteratee(iteratee, 2))
                    }
                    ,
                    lodash.min = function(array) {
                        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
                    }
                    ,
                    lodash.minBy = function(array, iteratee) {
                        return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
                    }
                    ,
                    lodash.stubArray = stubArray,
                    lodash.stubFalse = stubFalse,
                    lodash.stubObject = function() {
                        return {}
                    }
                    ,
                    lodash.stubString = function() {
                        return ""
                    }
                    ,
                    lodash.stubTrue = function() {
                        return !0
                    }
                    ,
                    lodash.multiply = multiply,
                    lodash.nth = function(array, n) {
                        return array && array.length ? baseNth(array, toInteger(n)) : undefined
                    }
                    ,
                    lodash.noConflict = function() {
                        return root._ === this && (root._ = oldDash),
                        this
                    }
                    ,
                    lodash.noop = noop,
                    lodash.now = now,
                    lodash.pad = function(string, length, chars) {
                        string = toString(string);
                        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
                        if (!length || strLength >= length)
                            return string;
                        var mid = (length - strLength) / 2;
                        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
                    }
                    ,
                    lodash.padEnd = function(string, length, chars) {
                        string = toString(string);
                        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
                        return length && strLength < length ? string + createPadding(length - strLength, chars) : string
                    }
                    ,
                    lodash.padStart = function(string, length, chars) {
                        string = toString(string);
                        var strLength = (length = toInteger(length)) ? stringSize(string) : 0;
                        return length && strLength < length ? createPadding(length - strLength, chars) + string : string
                    }
                    ,
                    lodash.parseInt = function(string, radix, guard) {
                        return guard || null == radix ? radix = 0 : radix && (radix = +radix),
                        nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0)
                    }
                    ,
                    lodash.random = function(lower, upper, floating) {
                        if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined),
                        floating === undefined && ("boolean" == typeof upper ? (floating = upper,
                        upper = undefined) : "boolean" == typeof lower && (floating = lower,
                        lower = undefined)),
                        lower === undefined && upper === undefined ? (lower = 0,
                        upper = 1) : (lower = toFinite(lower),
                        upper === undefined ? (upper = lower,
                        lower = 0) : upper = toFinite(upper)),
                        lower > upper) {
                            var temp = lower;
                            lower = upper,
                            upper = temp
                        }
                        if (floating || lower % 1 || upper % 1) {
                            var rand = nativeRandom();
                            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
                        }
                        return baseRandom(lower, upper)
                    }
                    ,
                    lodash.reduce = function(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduce : baseReduce
                          , initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
                    }
                    ,
                    lodash.reduceRight = function(collection, iteratee, accumulator) {
                        var func = isArray(collection) ? arrayReduceRight : baseReduce
                          , initAccum = arguments.length < 3;
                        return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
                    }
                    ,
                    lodash.repeat = function(string, n, guard) {
                        return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n),
                        baseRepeat(toString(string), n)
                    }
                    ,
                    lodash.replace = function() {
                        var args = arguments
                          , string = toString(args[0]);
                        return args.length < 3 ? string : string.replace(args[1], args[2])
                    }
                    ,
                    lodash.result = function(object, path, defaultValue) {
                        var index = -1
                          , length = (path = castPath(path, object)).length;
                        for (length || (length = 1,
                        object = undefined); ++index < length; ) {
                            var value = null == object ? undefined : object[toKey(path[index])];
                            value === undefined && (index = length,
                            value = defaultValue),
                            object = isFunction(value) ? value.call(object) : value
                        }
                        return object
                    }
                    ,
                    lodash.round = round,
                    lodash.runInContext = runInContext,
                    lodash.sample = function(collection) {
                        return (isArray(collection) ? arraySample : baseSample)(collection)
                    }
                    ,
                    lodash.size = function(collection) {
                        if (null == collection)
                            return 0;
                        if (isArrayLike(collection))
                            return isString(collection) ? stringSize(collection) : collection.length;
                        var tag = getTag(collection);
                        return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length
                    }
                    ,
                    lodash.snakeCase = snakeCase,
                    lodash.some = function(collection, predicate, guard) {
                        var func = isArray(collection) ? arraySome : baseSome;
                        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined),
                        func(collection, getIteratee(predicate, 3))
                    }
                    ,
                    lodash.sortedIndex = function(array, value) {
                        return baseSortedIndex(array, value)
                    }
                    ,
                    lodash.sortedIndexBy = function(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
                    }
                    ,
                    lodash.sortedIndexOf = function(array, value) {
                        var length = null == array ? 0 : array.length;
                        if (length) {
                            var index = baseSortedIndex(array, value);
                            if (index < length && eq(array[index], value))
                                return index
                        }
                        return -1
                    }
                    ,
                    lodash.sortedLastIndex = function(array, value) {
                        return baseSortedIndex(array, value, !0)
                    }
                    ,
                    lodash.sortedLastIndexBy = function(array, value, iteratee) {
                        return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0)
                    }
                    ,
                    lodash.sortedLastIndexOf = function(array, value) {
                        if (null == array ? 0 : array.length) {
                            var index = baseSortedIndex(array, value, !0) - 1;
                            if (eq(array[index], value))
                                return index
                        }
                        return -1
                    }
                    ,
                    lodash.startCase = startCase,
                    lodash.startsWith = function(string, target, position) {
                        return string = toString(string),
                        position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length),
                        target = baseToString(target),
                        string.slice(position, position + target.length) == target
                    }
                    ,
                    lodash.subtract = subtract,
                    lodash.sum = function(array) {
                        return array && array.length ? baseSum(array, identity) : 0
                    }
                    ,
                    lodash.sumBy = function(array, iteratee) {
                        return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
                    }
                    ,
                    lodash.template = function(string, options, guard) {
                        var settings = lodash.templateSettings;
                        guard && isIterateeCall(string, options, guard) && (options = undefined),
                        string = toString(string),
                        options = assignInWith({}, options, settings, customDefaultsAssignIn);
                        var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"), sourceURL = "//# sourceURL=" + ("sourceURL"in options ? options.sourceURL : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            return interpolateValue || (interpolateValue = esTemplateValue),
                            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar),
                            escapeValue && (isEscaping = !0,
                            source += "' +\n__e(" + escapeValue + ") +\n'"),
                            evaluateValue && (isEvaluating = !0,
                            source += "';\n" + evaluateValue + ";\n__p += '"),
                            interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"),
                            index = offset + match.length,
                            match
                        }),
                        source += "';\n";
                        var variable = options.variable;
                        variable || (source = "with (obj) {\n" + source + "\n}\n"),
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"),
                        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var result = attempt(function() {
                            return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
                        });
                        if (result.source = source,
                        isError(result))
                            throw result;
                        return result
                    }
                    ,
                    lodash.times = function(n, iteratee) {
                        if ((n = toInteger(n)) < 1 || n > MAX_SAFE_INTEGER)
                            return [];
                        var index = MAX_ARRAY_LENGTH
                          , length = nativeMin(n, MAX_ARRAY_LENGTH);
                        iteratee = getIteratee(iteratee),
                        n -= MAX_ARRAY_LENGTH;
                        for (var result = baseTimes(length, iteratee); ++index < n; )
                            iteratee(index);
                        return result
                    }
                    ,
                    lodash.toFinite = toFinite,
                    lodash.toInteger = toInteger,
                    lodash.toLength = toLength,
                    lodash.toLower = function(value) {
                        return toString(value).toLowerCase()
                    }
                    ,
                    lodash.toNumber = toNumber,
                    lodash.toSafeInteger = function(value) {
                        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0
                    }
                    ,
                    lodash.toString = toString,
                    lodash.toUpper = function(value) {
                        return toString(value).toUpperCase()
                    }
                    ,
                    lodash.trim = function(string, chars, guard) {
                        if ((string = toString(string)) && (guard || chars === undefined))
                            return string.replace(reTrim, "");
                        if (!string || !(chars = baseToString(chars)))
                            return string;
                        var strSymbols = stringToArray(string)
                          , chrSymbols = stringToArray(chars);
                        return castSlice(strSymbols, charsStartIndex(strSymbols, chrSymbols), charsEndIndex(strSymbols, chrSymbols) + 1).join("")
                    }
                    ,
                    lodash.trimEnd = function(string, chars, guard) {
                        if ((string = toString(string)) && (guard || chars === undefined))
                            return string.replace(reTrimEnd, "");
                        if (!string || !(chars = baseToString(chars)))
                            return string;
                        var strSymbols = stringToArray(string);
                        return castSlice(strSymbols, 0, charsEndIndex(strSymbols, stringToArray(chars)) + 1).join("")
                    }
                    ,
                    lodash.trimStart = function(string, chars, guard) {
                        if ((string = toString(string)) && (guard || chars === undefined))
                            return string.replace(reTrimStart, "");
                        if (!string || !(chars = baseToString(chars)))
                            return string;
                        var strSymbols = stringToArray(string);
                        return castSlice(strSymbols, charsStartIndex(strSymbols, stringToArray(chars))).join("")
                    }
                    ,
                    lodash.truncate = function(string, options) {
                        var length = DEFAULT_TRUNC_LENGTH
                          , omission = DEFAULT_TRUNC_OMISSION;
                        if (isObject(options)) {
                            var separator = "separator"in options ? options.separator : separator;
                            length = "length"in options ? toInteger(options.length) : length,
                            omission = "omission"in options ? baseToString(options.omission) : omission
                        }
                        var strLength = (string = toString(string)).length;
                        if (hasUnicode(string)) {
                            var strSymbols = stringToArray(string);
                            strLength = strSymbols.length
                        }
                        if (length >= strLength)
                            return string;
                        var end = length - stringSize(omission);
                        if (end < 1)
                            return omission;
                        var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                        if (separator === undefined)
                            return result + omission;
                        if (strSymbols && (end += result.length - end),
                        isRegExp(separator)) {
                            if (string.slice(end).search(separator)) {
                                var match, substring = result;
                                for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")),
                                separator.lastIndex = 0; match = separator.exec(substring); )
                                    var newEnd = match.index;
                                result = result.slice(0, newEnd === undefined ? end : newEnd)
                            }
                        } else if (string.indexOf(baseToString(separator), end) != end) {
                            var index = result.lastIndexOf(separator);
                            index > -1 && (result = result.slice(0, index))
                        }
                        return result + omission
                    }
                    ,
                    lodash.unescape = function(string) {
                        return (string = toString(string)) && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
                    }
                    ,
                    lodash.uniqueId = function(prefix) {
                        var id = ++idCounter;
                        return toString(prefix) + id
                    }
                    ,
                    lodash.upperCase = upperCase,
                    lodash.upperFirst = upperFirst,
                    lodash.each = forEach,
                    lodash.eachRight = forEachRight,
                    lodash.first = head,
                    mixin(lodash, function() {
                        var source = {};
                        return baseForOwn(lodash, function(func, methodName) {
                            hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
                        }),
                        source
                    }(), {
                        chain: !1
                    }),
                    lodash.VERSION = "4.17.11",
                    arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                        lodash[methodName].placeholder = lodash
                    }),
                    arrayEach(["drop", "take"], function(methodName, index) {
                        LazyWrapper.prototype[methodName] = function(n) {
                            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                            var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                            return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                                size: nativeMin(n, MAX_ARRAY_LENGTH),
                                type: methodName + (result.__dir__ < 0 ? "Right" : "")
                            }),
                            result
                        }
                        ,
                        LazyWrapper.prototype[methodName + "Right"] = function(n) {
                            return this.reverse()[methodName](n).reverse()
                        }
                    }),
                    arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                        var type = index + 1
                          , isFilter = type == LAZY_FILTER_FLAG || 3 == type;
                        LazyWrapper.prototype[methodName] = function(iteratee) {
                            var result = this.clone();
                            return result.__iteratees__.push({
                                iteratee: getIteratee(iteratee, 3),
                                type: type
                            }),
                            result.__filtered__ = result.__filtered__ || isFilter,
                            result
                        }
                    }),
                    arrayEach(["head", "last"], function(methodName, index) {
                        var takeName = "take" + (index ? "Right" : "");
                        LazyWrapper.prototype[methodName] = function() {
                            return this[takeName](1).value()[0]
                        }
                    }),
                    arrayEach(["initial", "tail"], function(methodName, index) {
                        var dropName = "drop" + (index ? "" : "Right");
                        LazyWrapper.prototype[methodName] = function() {
                            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                        }
                    }),
                    LazyWrapper.prototype.compact = function() {
                        return this.filter(identity)
                    }
                    ,
                    LazyWrapper.prototype.find = function(predicate) {
                        return this.filter(predicate).head()
                    }
                    ,
                    LazyWrapper.prototype.findLast = function(predicate) {
                        return this.reverse().find(predicate)
                    }
                    ,
                    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                        return "function" == typeof path ? new LazyWrapper(this) : this.map(function(value) {
                            return baseInvoke(value, path, args)
                        })
                    }),
                    LazyWrapper.prototype.reject = function(predicate) {
                        return this.filter(negate(getIteratee(predicate)))
                    }
                    ,
                    LazyWrapper.prototype.slice = function(start, end) {
                        start = toInteger(start);
                        var result = this;
                        return result.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)),
                        end !== undefined && (result = (end = toInteger(end)) < 0 ? result.dropRight(-end) : result.take(end - start)),
                        result)
                    }
                    ,
                    LazyWrapper.prototype.takeRightWhile = function(predicate) {
                        return this.reverse().takeWhile(predicate).reverse()
                    }
                    ,
                    LazyWrapper.prototype.toArray = function() {
                        return this.take(MAX_ARRAY_LENGTH)
                    }
                    ,
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName)
                          , isTaker = /^(?:head|last)$/.test(methodName)
                          , lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName]
                          , retUnwrapped = isTaker || /^find/.test(methodName);
                        lodashFunc && (lodash.prototype[methodName] = function() {
                            var value = this.__wrapped__
                              , args = isTaker ? [1] : arguments
                              , isLazy = value instanceof LazyWrapper
                              , iteratee = args[0]
                              , useLazy = isLazy || isArray(value)
                              , interceptor = function(value) {
                                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                return isTaker && chainAll ? result[0] : result
                            };
                            useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                            var chainAll = this.__chain__
                              , isHybrid = !!this.__actions__.length
                              , isUnwrapped = retUnwrapped && !chainAll
                              , onlyLazy = isLazy && !isHybrid;
                            if (!retUnwrapped && useLazy) {
                                value = onlyLazy ? value : new LazyWrapper(this);
                                var result = func.apply(value, args);
                                return result.__actions__.push({
                                    func: thru,
                                    args: [interceptor],
                                    thisArg: undefined
                                }),
                                new LodashWrapper(result,chainAll)
                            }
                            return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor),
                            isUnwrapped ? isTaker ? result.value()[0] : result.value() : result)
                        }
                        )
                    }),
                    arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                        var func = arrayProto[methodName]
                          , chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru"
                          , retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                        lodash.prototype[methodName] = function() {
                            var args = arguments;
                            if (retUnwrapped && !this.__chain__) {
                                var value = this.value();
                                return func.apply(isArray(value) ? value : [], args)
                            }
                            return this[chainName](function(value) {
                                return func.apply(isArray(value) ? value : [], args)
                            })
                        }
                    }),
                    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                        var lodashFunc = lodash[methodName];
                        if (lodashFunc) {
                            var key = lodashFunc.name + "";
                            (realNames[key] || (realNames[key] = [])).push({
                                name: methodName,
                                func: lodashFunc
                            })
                        }
                    }),
                    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                        name: "wrapper",
                        func: undefined
                    }],
                    LazyWrapper.prototype.clone = function() {
                        var result = new LazyWrapper(this.__wrapped__);
                        return result.__actions__ = copyArray(this.__actions__),
                        result.__dir__ = this.__dir__,
                        result.__filtered__ = this.__filtered__,
                        result.__iteratees__ = copyArray(this.__iteratees__),
                        result.__takeCount__ = this.__takeCount__,
                        result.__views__ = copyArray(this.__views__),
                        result
                    }
                    ,
                    LazyWrapper.prototype.reverse = function() {
                        if (this.__filtered__) {
                            var result = new LazyWrapper(this);
                            result.__dir__ = -1,
                            result.__filtered__ = !0
                        } else
                            (result = this.clone()).__dir__ *= -1;
                        return result
                    }
                    ,
                    LazyWrapper.prototype.value = function() {
                        var array = this.__wrapped__.value()
                          , dir = this.__dir__
                          , isArr = isArray(array)
                          , isRight = dir < 0
                          , arrLength = isArr ? array.length : 0
                          , view = getView(0, arrLength, this.__views__)
                          , start = view.start
                          , end = view.end
                          , length = end - start
                          , index = isRight ? end : start - 1
                          , iteratees = this.__iteratees__
                          , iterLength = iteratees.length
                          , resIndex = 0
                          , takeCount = nativeMin(length, this.__takeCount__);
                        if (!isArr || !isRight && arrLength == length && takeCount == length)
                            return baseWrapperValue(array, this.__actions__);
                        var result = [];
                        outer: for (; length-- && resIndex < takeCount; ) {
                            for (var iterIndex = -1, value = array[index += dir]; ++iterIndex < iterLength; ) {
                                var data = iteratees[iterIndex]
                                  , iteratee = data.iteratee
                                  , type = data.type
                                  , computed = iteratee(value);
                                if (type == LAZY_MAP_FLAG)
                                    value = computed;
                                else if (!computed) {
                                    if (type == LAZY_FILTER_FLAG)
                                        continue outer;
                                    break outer
                                }
                            }
                            result[resIndex++] = value
                        }
                        return result
                    }
                    ,
                    lodash.prototype.at = wrapperAt,
                    lodash.prototype.chain = function() {
                        return chain(this)
                    }
                    ,
                    lodash.prototype.commit = function() {
                        return new LodashWrapper(this.value(),this.__chain__)
                    }
                    ,
                    lodash.prototype.next = function() {
                        this.__values__ === undefined && (this.__values__ = toArray(this.value()));
                        var done = this.__index__ >= this.__values__.length;
                        return {
                            done: done,
                            value: done ? undefined : this.__values__[this.__index__++]
                        }
                    }
                    ,
                    lodash.prototype.plant = function(value) {
                        for (var result, parent = this; parent instanceof baseLodash; ) {
                            var clone = wrapperClone(parent);
                            clone.__index__ = 0,
                            clone.__values__ = undefined,
                            result ? previous.__wrapped__ = clone : result = clone;
                            var previous = clone;
                            parent = parent.__wrapped__
                        }
                        return previous.__wrapped__ = value,
                        result
                    }
                    ,
                    lodash.prototype.reverse = function() {
                        var value = this.__wrapped__;
                        if (value instanceof LazyWrapper) {
                            var wrapped = value;
                            return this.__actions__.length && (wrapped = new LazyWrapper(this)),
                            (wrapped = wrapped.reverse()).__actions__.push({
                                func: thru,
                                args: [reverse],
                                thisArg: undefined
                            }),
                            new LodashWrapper(wrapped,this.__chain__)
                        }
                        return this.thru(reverse)
                    }
                    ,
                    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = function() {
                        return baseWrapperValue(this.__wrapped__, this.__actions__)
                    }
                    ,
                    lodash.prototype.first = lodash.prototype.head,
                    symIterator && (lodash.prototype[symIterator] = function() {
                        return this
                    }
                    ),
                    lodash
                }();
                "function" == typeof define && "object" == typeof define.amd && define.amd ? (root._ = _,
                define(function() {
                    return _
                })) : freeModule ? ((freeModule.exports = _)._ = _,
                freeExports._ = _) : root._ = _
            }
            ).call(this)
        }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    , {}],
    16: [function(require, module, exports) {
        var Mailcheck = {
            domainThreshold: 2,
            secondLevelThreshold: 2,
            topLevelThreshold: 2,
            defaultDomains: ["msn.com", "bellsouth.net", "telus.net", "comcast.net", "optusnet.com.au", "earthlink.net", "qq.com", "sky.com", "icloud.com", "mac.com", "sympatico.ca", "googlemail.com", "att.net", "xtra.co.nz", "web.de", "cox.net", "gmail.com", "ymail.com", "aim.com", "rogers.com", "verizon.net", "rocketmail.com", "google.com", "optonline.net", "sbcglobal.net", "aol.com", "me.com", "btinternet.com", "charter.net", "shaw.ca"],
            defaultSecondLevelDomains: ["yahoo", "hotmail", "mail", "live", "outlook", "gmx"],
            defaultTopLevelDomains: ["com", "com.au", "com.tw", "ca", "co.nz", "co.uk", "de", "fr", "it", "ru", "net", "org", "edu", "gov", "jp", "nl", "kr", "se", "eu", "ie", "co.il", "us", "at", "be", "dk", "hk", "es", "gr", "ch", "no", "cz", "in", "net", "net.au", "info", "biz", "mil", "co.jp", "sg", "hu", "uk"],
            run: function(opts) {
                opts.domains = opts.domains || Mailcheck.defaultDomains,
                opts.secondLevelDomains = opts.secondLevelDomains || Mailcheck.defaultSecondLevelDomains,
                opts.topLevelDomains = opts.topLevelDomains || Mailcheck.defaultTopLevelDomains,
                opts.distanceFunction = opts.distanceFunction || Mailcheck.sift3Distance;
                var defaultCallback = function(result) {
                    return result
                }
                  , suggestedCallback = opts.suggested || defaultCallback
                  , emptyCallback = opts.empty || defaultCallback
                  , result = Mailcheck.suggest(Mailcheck.encodeEmail(opts.email), opts.domains, opts.secondLevelDomains, opts.topLevelDomains, opts.distanceFunction);
                return result ? suggestedCallback(result) : emptyCallback()
            },
            suggest: function(email, domains, secondLevelDomains, topLevelDomains, distanceFunction) {
                email = email.toLowerCase();
                var emailParts = this.splitEmail(email);
                if (secondLevelDomains && topLevelDomains && -1 !== secondLevelDomains.indexOf(emailParts.secondLevelDomain) && -1 !== topLevelDomains.indexOf(emailParts.topLevelDomain))
                    return !1;
                if (closestDomain = this.findClosestDomain(emailParts.domain, domains, distanceFunction, this.domainThreshold))
                    return closestDomain != emailParts.domain && {
                        address: emailParts.address,
                        domain: closestDomain,
                        full: emailParts.address + "@" + closestDomain
                    };
                var closestSecondLevelDomain = this.findClosestDomain(emailParts.secondLevelDomain, secondLevelDomains, distanceFunction, this.secondLevelThreshold)
                  , closestTopLevelDomain = this.findClosestDomain(emailParts.topLevelDomain, topLevelDomains, distanceFunction, this.topLevelThreshold);
                if (emailParts.domain) {
                    var closestDomain = emailParts.domain
                      , rtrn = !1;
                    if (closestSecondLevelDomain && closestSecondLevelDomain != emailParts.secondLevelDomain && (closestDomain = closestDomain.replace(emailParts.secondLevelDomain, closestSecondLevelDomain),
                    rtrn = !0),
                    closestTopLevelDomain && closestTopLevelDomain != emailParts.topLevelDomain && (closestDomain = closestDomain.replace(new RegExp(emailParts.topLevelDomain + "$"), closestTopLevelDomain),
                    rtrn = !0),
                    1 == rtrn)
                        return {
                            address: emailParts.address,
                            domain: closestDomain,
                            full: emailParts.address + "@" + closestDomain
                        }
                }
                return !1
            },
            findClosestDomain: function(domain, domains, distanceFunction, threshold) {
                threshold = threshold || this.topLevelThreshold;
                var dist, minDist = 1 / 0, closestDomain = null;
                if (!domain || !domains)
                    return !1;
                distanceFunction || (distanceFunction = this.sift3Distance);
                for (var i = 0; i < domains.length; i++) {
                    if (domain === domains[i])
                        return domain;
                    (dist = distanceFunction(domain, domains[i])) < minDist && (minDist = dist,
                    closestDomain = domains[i])
                }
                return minDist <= threshold && null !== closestDomain && closestDomain
            },
            sift3Distance: function(s1, s2) {
                if (null == s1 || 0 === s1.length)
                    return null == s2 || 0 === s2.length ? 0 : s2.length;
                if (null == s2 || 0 === s2.length)
                    return s1.length;
                for (var c = 0, offset1 = 0, offset2 = 0, lcs = 0; c + offset1 < s1.length && c + offset2 < s2.length; ) {
                    if (s1.charAt(c + offset1) == s2.charAt(c + offset2))
                        lcs++;
                    else {
                        offset1 = 0,
                        offset2 = 0;
                        for (var i = 0; i < 5; i++) {
                            if (c + i < s1.length && s1.charAt(c + i) == s2.charAt(c)) {
                                offset1 = i;
                                break
                            }
                            if (c + i < s2.length && s1.charAt(c) == s2.charAt(c + i)) {
                                offset2 = i;
                                break
                            }
                        }
                    }
                    c++
                }
                return (s1.length + s2.length) / 2 - lcs
            },
            splitEmail: function(email) {
                var parts = email.trim().split("@");
                if (parts.length < 2)
                    return !1;
                for (i = 0; i < parts.length; i++)
                    if ("" === parts[i])
                        return !1;
                var domain = parts.pop()
                  , domainParts = domain.split(".")
                  , sld = ""
                  , tld = "";
                if (0 == domainParts.length)
                    return !1;
                if (1 == domainParts.length)
                    tld = domainParts[0];
                else {
                    sld = domainParts[0];
                    for (var i = 1; i < domainParts.length; i++)
                        tld += domainParts[i] + ".";
                    tld = tld.substring(0, tld.length - 1)
                }
                return {
                    topLevelDomain: tld,
                    secondLevelDomain: sld,
                    domain: domain,
                    address: parts.join("@")
                }
            },
            encodeEmail: function(email) {
                var result = encodeURI(email);
                return result = result.replace("%20", " ").replace("%25", "%").replace("%5E", "^").replace("%60", "`").replace("%7B", "{").replace("%7C", "|").replace("%7D", "}")
            }
        };
        void 0 !== module && module.exports && (module.exports = Mailcheck),
        "function" == typeof define && define.amd && define("mailcheck", [], function() {
            return Mailcheck
        }),
        "undefined" != typeof window && window.jQuery && (jQuery.fn.mailcheck = function(opts) {
            var self = this;
            if (opts.suggested) {
                var oldSuggested = opts.suggested;
                opts.suggested = function(result) {
                    oldSuggested(self, result)
                }
            }
            if (opts.empty) {
                var oldEmpty = opts.empty;
                opts.empty = function() {
                    oldEmpty.call(null, self)
                }
            }
            opts.email = this.val(),
            Mailcheck.run(opts)
        }
        )
    }
    , {}],
    17: [function(require, module, exports) {
        !function(window, document, undefined) {
            function is(obj, type) {
                return typeof obj === type
            }
            function setClasses(classes) {
                var className = docElement.className
                  , classPrefix = Modernizr._config.classPrefix || "";
                if (isSVG && (className = className.baseVal),
                Modernizr._config.enableJSClass) {
                    var reJS = new RegExp("(^|\\s)" + classPrefix + "no-js(\\s|$)");
                    className = className.replace(reJS, "$1" + classPrefix + "js$2")
                }
                Modernizr._config.enableClasses && (className += " " + classPrefix + classes.join(" " + classPrefix),
                isSVG ? docElement.className.baseVal = className : docElement.className = className)
            }
            function addTest(feature, test) {
                if ("object" == typeof feature)
                    for (var key in feature)
                        hasOwnProp(feature, key) && addTest(key, feature[key]);
                else {
                    var featureNameSplit = (feature = feature.toLowerCase()).split(".")
                      , last = Modernizr[featureNameSplit[0]];
                    if (2 == featureNameSplit.length && (last = last[featureNameSplit[1]]),
                    void 0 !== last)
                        return Modernizr;
                    test = "function" == typeof test ? test() : test,
                    1 == featureNameSplit.length ? Modernizr[featureNameSplit[0]] = test : (!Modernizr[featureNameSplit[0]] || Modernizr[featureNameSplit[0]]instanceof Boolean || (Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]])),
                    Modernizr[featureNameSplit[0]][featureNameSplit[1]] = test),
                    setClasses([(test && 0 != test ? "" : "no-") + featureNameSplit.join("-")]),
                    Modernizr._trigger(feature, test)
                }
                return Modernizr
            }
            function contains(str, substr) {
                return !!~("" + str).indexOf(substr)
            }
            function createElement() {
                return "function" != typeof document.createElement ? document.createElement(arguments[0]) : isSVG ? document.createElementNS.call(document, "http://www.w3.org/2000/svg", arguments[0]) : document.createElement.apply(document, arguments)
            }
            function getBody() {
                var body = document.body;
                return body || ((body = createElement(isSVG ? "svg" : "body")).fake = !0),
                body
            }
            function injectElementWithStyles(rule, callback, nodes, testnames) {
                var style, ret, node, docOverflow, mod = "modernizr", div = createElement("div"), body = getBody();
                if (parseInt(nodes, 10))
                    for (; nodes--; )
                        (node = createElement("div")).id = testnames ? testnames[nodes] : mod + (nodes + 1),
                        div.appendChild(node);
                return style = createElement("style"),
                style.type = "text/css",
                style.id = "s" + mod,
                (body.fake ? body : div).appendChild(style),
                body.appendChild(div),
                style.styleSheet ? style.styleSheet.cssText = rule : style.appendChild(document.createTextNode(rule)),
                div.id = mod,
                body.fake && (body.style.background = "",
                body.style.overflow = "hidden",
                docOverflow = docElement.style.overflow,
                docElement.style.overflow = "hidden",
                docElement.appendChild(body)),
                ret = callback(div, rule),
                body.fake ? (body.parentNode.removeChild(body),
                docElement.style.overflow = docOverflow,
                docElement.offsetHeight) : div.parentNode.removeChild(div),
                !!ret
            }
            function domToCSS(name) {
                return name.replace(/([A-Z])/g, function(str, m1) {
                    return "-" + m1.toLowerCase()
                }).replace(/^ms-/, "-ms-")
            }
            function computedStyle(elem, pseudo, prop) {
                var result;
                if ("getComputedStyle"in window) {
                    result = getComputedStyle.call(window, elem, pseudo);
                    var console = window.console;
                    null !== result ? prop && (result = result.getPropertyValue(prop)) : console && console[console.error ? "error" : "log"].call(console, "getComputedStyle returning null, its possible modernizr test results are inaccurate")
                } else
                    result = !pseudo && elem.currentStyle && elem.currentStyle[prop];
                return result
            }
            function nativeTestProps(props, value) {
                var i = props.length;
                if ("CSS"in window && "supports"in window.CSS) {
                    for (; i--; )
                        if (window.CSS.supports(domToCSS(props[i]), value))
                            return !0;
                    return !1
                }
                if ("CSSSupportsRule"in window) {
                    for (var conditionText = []; i--; )
                        conditionText.push("(" + domToCSS(props[i]) + ":" + value + ")");
                    return conditionText = conditionText.join(" or "),
                    injectElementWithStyles("@supports (" + conditionText + ") { #modernizr { position: absolute; } }", function(node) {
                        return "absolute" == computedStyle(node, null, "position")
                    })
                }
                return undefined
            }
            function cssToDOM(name) {
                return name.replace(/([a-z])-([a-z])/g, function(str, m1, m2) {
                    return m1 + m2.toUpperCase()
                }).replace(/^-/, "")
            }
            function testProps(props, prefixed, value, skipValueTest) {
                function cleanElems() {
                    afterInit && (delete mStyle.style,
                    delete mStyle.modElem)
                }
                if (skipValueTest = !is(skipValueTest, "undefined") && skipValueTest,
                !is(value, "undefined")) {
                    var result = nativeTestProps(props, value);
                    if (!is(result, "undefined"))
                        return result
                }
                for (var afterInit, i, propsLength, prop, before, elems = ["modernizr", "tspan", "samp"]; !mStyle.style && elems.length; )
                    afterInit = !0,
                    mStyle.modElem = createElement(elems.shift()),
                    mStyle.style = mStyle.modElem.style;
                for (propsLength = props.length,
                i = 0; i < propsLength; i++)
                    if (prop = props[i],
                    before = mStyle.style[prop],
                    contains(prop, "-") && (prop = cssToDOM(prop)),
                    mStyle.style[prop] !== undefined) {
                        if (skipValueTest || is(value, "undefined"))
                            return cleanElems(),
                            "pfx" != prefixed || prop;
                        try {
                            mStyle.style[prop] = value
                        } catch (e) {}
                        if (mStyle.style[prop] != before)
                            return cleanElems(),
                            "pfx" != prefixed || prop
                    }
                return cleanElems(),
                !1
            }
            function fnBind(fn, that) {
                return function() {
                    return fn.apply(that, arguments)
                }
            }
            function testDOMProps(props, obj, elem) {
                var item;
                for (var i in props)
                    if (props[i]in obj)
                        return !1 === elem ? props[i] : (item = obj[props[i]],
                        is(item, "function") ? fnBind(item, elem || obj) : item);
                return !1
            }
            function testPropsAll(prop, prefixed, elem, value, skipValueTest) {
                var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1)
                  , props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
                return is(prefixed, "string") || is(prefixed, "undefined") ? testProps(props, prefixed, value, skipValueTest) : (props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" "),
                testDOMProps(props, prefixed, elem))
            }
            function testAllProps(prop, value, skipValueTest) {
                return testPropsAll(prop, undefined, undefined, value, skipValueTest)
            }
            var tests = []
              , ModernizrProto = {
                _version: "3.5.0",
                _config: {
                    classPrefix: "",
                    enableClasses: !0,
                    enableJSClass: !0,
                    usePrefixes: !0
                },
                _q: [],
                on: function(test, cb) {
                    var self = this;
                    setTimeout(function() {
                        cb(self[test])
                    }, 0)
                },
                addTest: function(name, fn, options) {
                    tests.push({
                        name: name,
                        fn: fn,
                        options: options
                    })
                },
                addAsyncTest: function(fn) {
                    tests.push({
                        name: null,
                        fn: fn
                    })
                }
            }
              , Modernizr = function() {};
            Modernizr.prototype = ModernizrProto,
            Modernizr = new Modernizr;
            var hasOwnProp, classes = [], docElement = document.documentElement, isSVG = "svg" === docElement.nodeName.toLowerCase();
            !function() {
                var _hasOwnProperty = {}.hasOwnProperty;
                hasOwnProp = is(_hasOwnProperty, "undefined") || is(_hasOwnProperty.call, "undefined") ? function(object, property) {
                    return property in object && is(object.constructor.prototype[property], "undefined")
                }
                : function(object, property) {
                    return _hasOwnProperty.call(object, property)
                }
            }(),
            ModernizrProto._l = {},
            ModernizrProto.on = function(feature, cb) {
                this._l[feature] || (this._l[feature] = []),
                this._l[feature].push(cb),
                Modernizr.hasOwnProperty(feature) && setTimeout(function() {
                    Modernizr._trigger(feature, Modernizr[feature])
                }, 0)
            }
            ,
            ModernizrProto._trigger = function(feature, res) {
                if (this._l[feature]) {
                    var cbs = this._l[feature];
                    setTimeout(function() {
                        var i;
                        for (i = 0; i < cbs.length; i++)
                            (0,
                            cbs[i])(res)
                    }, 0),
                    delete this._l[feature]
                }
            }
            ,
            Modernizr._q.push(function() {
                ModernizrProto.addTest = addTest
            });
            var cssomPrefixes = ModernizrProto._config.usePrefixes ? "Moz O ms Webkit".split(" ") : [];
            ModernizrProto._cssomPrefixes = cssomPrefixes;
            var modElem = {
                elem: createElement("modernizr")
            };
            Modernizr._q.push(function() {
                delete modElem.elem
            });
            var mStyle = {
                style: modElem.elem.style
            };
            Modernizr._q.unshift(function() {
                delete mStyle.style
            });
            var domPrefixes = ModernizrProto._config.usePrefixes ? "Moz O ms Webkit".toLowerCase().split(" ") : [];
            ModernizrProto._domPrefixes = domPrefixes,
            ModernizrProto.testAllProps = testPropsAll,
            ModernizrProto.testAllProps = testAllProps,
            Modernizr.addTest("bgsizecover", testAllProps("backgroundSize", "cover"));
            var prefixes = ModernizrProto._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];
            ModernizrProto._prefixes = prefixes;
            var testStyles = ModernizrProto.testStyles = injectElementWithStyles;
            Modernizr.addTest("touchevents", function() {
                var bool;
                if ("ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch)
                    bool = !0;
                else {
                    var query = ["@media (", prefixes.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");
                    testStyles(query, function(node) {
                        bool = 9 === node.offsetTop
                    })
                }
                return bool
            });
            var inputElem = createElement("input")
              , inputtypes = "search tel url email datetime date month week time datetime-local number range color".split(" ")
              , inputs = {};
            Modernizr.inputtypes = function(props) {
                for (var inputElemType, defaultView, bool, len = props.length, i = 0; i < len; i++)
                    inputElem.setAttribute("type", inputElemType = props[i]),
                    (bool = "text" !== inputElem.type && "style"in inputElem) && (inputElem.value = "1)",
                    inputElem.style.cssText = "position:absolute;visibility:hidden;",
                    /^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined ? (docElement.appendChild(inputElem),
                    bool = (defaultView = document.defaultView).getComputedStyle && "textfield" !== defaultView.getComputedStyle(inputElem, null).WebkitAppearance && 0 !== inputElem.offsetHeight,
                    docElement.removeChild(inputElem)) : /^(search|tel)$/.test(inputElemType) || (bool = /^(url|email)$/.test(inputElemType) ? inputElem.checkValidity && !1 === inputElem.checkValidity() : "1)" != inputElem.value)),
                    inputs[props[i]] = !!bool;
                return inputs
            }(inputtypes),
            Modernizr.addTest("cssgridlegacy", testAllProps("grid-columns", "10px", !0)),
            Modernizr.addTest("cssgrid", testAllProps("grid-template-rows", "none", !0)),
            Modernizr.addTest("flexbox", testAllProps("flexBasis", "1px", !0));
            var atRule = function(prop) {
                var rule, length = prefixes.length, cssrule = window.CSSRule;
                if (void 0 === cssrule)
                    return undefined;
                if (!prop)
                    return !1;
                if (prop = prop.replace(/^@/, ""),
                (rule = prop.replace(/-/g, "_").toUpperCase() + "_RULE")in cssrule)
                    return "@" + prop;
                for (var i = 0; i < length; i++) {
                    var prefix = prefixes[i];
                    if (prefix.toUpperCase() + "_" + rule in cssrule)
                        return "@-" + prefix.toLowerCase() + "-" + prop
                }
                return !1
            };
            ModernizrProto.atRule = atRule;
            var prefixed = ModernizrProto.prefixed = function(prop, obj, elem) {
                return 0 === prop.indexOf("@") ? atRule(prop) : (-1 != prop.indexOf("-") && (prop = cssToDOM(prop)),
                obj ? testPropsAll(prop, obj, elem) : testPropsAll(prop, "pfx"))
            }
            ;
            Modernizr.addTest("objectfit", !!prefixed("objectFit"), {
                aliases: ["object-fit"]
            }),
            Modernizr.addTest("csstransitions", testAllProps("transition", "all", !0)),
            Modernizr.addTest("formvalidation", function() {
                var form = createElement("form");
                if (!("checkValidity"in form && "addEventListener"in form))
                    return !1;
                if ("reportValidity"in form)
                    return !0;
                var input, invalidFired = !1;
                return Modernizr.formvalidationapi = !0,
                form.addEventListener("submit", function(e) {
                    window.opera && !window.operamini || e.preventDefault(),
                    e.stopPropagation()
                }, !1),
                form.innerHTML = '<input name="modTest" required="required" /><button></button>',
                testStyles("#modernizr form{position:absolute;top:-99999em}", function(node) {
                    node.appendChild(form),
                    (input = form.getElementsByTagName("input")[0]).addEventListener("invalid", function(e) {
                        invalidFired = !0,
                        e.preventDefault(),
                        e.stopPropagation()
                    }, !1),
                    Modernizr.formvalidationmessage = !!input.validationMessage,
                    form.getElementsByTagName("button")[0].click()
                }),
                invalidFired
            }),
            Modernizr.addTest("picture", "HTMLPictureElement"in window),
            Modernizr.addTest("hiddenscroll", function() {
                return testStyles("#modernizr {width:100px;height:100px;overflow:scroll}", function(elem) {
                    return elem.offsetWidth === elem.clientWidth
                })
            }),
            function() {
                var featureNames, feature, aliasIdx, result, nameIdx, featureNameSplit;
                for (var featureIdx in tests)
                    if (tests.hasOwnProperty(featureIdx)) {
                        if (featureNames = [],
                        (feature = tests[featureIdx]).name && (featureNames.push(feature.name.toLowerCase()),
                        feature.options && feature.options.aliases && feature.options.aliases.length))
                            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++)
                                featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
                        for (result = is(feature.fn, "function") ? feature.fn() : feature.fn,
                        nameIdx = 0; nameIdx < featureNames.length; nameIdx++)
                            1 === (featureNameSplit = featureNames[nameIdx].split(".")).length ? Modernizr[featureNameSplit[0]] = result : (!Modernizr[featureNameSplit[0]] || Modernizr[featureNameSplit[0]]instanceof Boolean || (Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]])),
                            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result),
                            classes.push((result ? "" : "no-") + featureNameSplit.join("-"))
                    }
            }(),
            setClasses(classes),
            delete ModernizrProto.addTest,
            delete ModernizrProto.addAsyncTest;
            for (var i = 0; i < Modernizr._q.length; i++)
                Modernizr._q[i]();
            window.Modernizr = Modernizr
        }(window, document)
    }
    , {}],
    18: [function(require, module, exports) {
        !function(factory) {
            "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? module.exports = factory() : window.noUiSlider = factory()
        }(function() {
            "use strict";
            function isValidFormatter(entry) {
                return "object" == typeof entry && "function" == typeof entry.to && "function" == typeof entry.from
            }
            function removeElement(el) {
                el.parentElement.removeChild(el)
            }
            function preventDefault(e) {
                e.preventDefault()
            }
            function unique(array) {
                return array.filter(function(a) {
                    return !this[a] && (this[a] = !0)
                }, {})
            }
            function closest(value, to) {
                return Math.round(value / to) * to
            }
            function offset(elem, orientation) {
                var rect = elem.getBoundingClientRect()
                  , doc = elem.ownerDocument
                  , docElem = doc.documentElement
                  , pageOffset = getPageOffset(doc);
                return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (pageOffset.x = 0),
                orientation ? rect.top + pageOffset.y - docElem.clientTop : rect.left + pageOffset.x - docElem.clientLeft
            }
            function isNumeric(a) {
                return "number" == typeof a && !isNaN(a) && isFinite(a)
            }
            function addClassFor(element, className, duration) {
                duration > 0 && (addClass(element, className),
                setTimeout(function() {
                    removeClass(element, className)
                }, duration))
            }
            function limit(a) {
                return Math.max(Math.min(a, 100), 0)
            }
            function asArray(a) {
                return Array.isArray(a) ? a : [a]
            }
            function countDecimals(numStr) {
                var pieces = (numStr = String(numStr)).split(".");
                return pieces.length > 1 ? pieces[1].length : 0
            }
            function addClass(el, className) {
                el.classList ? el.classList.add(className) : el.className += " " + className
            }
            function removeClass(el, className) {
                el.classList ? el.classList.remove(className) : el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)","gi"), " ")
            }
            function hasClass(el, className) {
                return el.classList ? el.classList.contains(className) : new RegExp("\\b" + className + "\\b").test(el.className)
            }
            function getPageOffset(doc) {
                var supportPageOffset = void 0 !== window.pageXOffset
                  , isCSS1Compat = "CSS1Compat" === (doc.compatMode || "");
                return {
                    x: supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft,
                    y: supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop
                }
            }
            function getActions() {
                return window.navigator.pointerEnabled ? {
                    start: "pointerdown",
                    move: "pointermove",
                    end: "pointerup"
                } : window.navigator.msPointerEnabled ? {
                    start: "MSPointerDown",
                    move: "MSPointerMove",
                    end: "MSPointerUp"
                } : {
                    start: "mousedown touchstart",
                    move: "mousemove touchmove",
                    end: "mouseup touchend"
                }
            }
            function getSupportsPassive() {
                var supportsPassive = !1;
                try {
                    var opts = Object.defineProperty({}, "passive", {
                        get: function() {
                            supportsPassive = !0
                        }
                    });
                    window.addEventListener("test", null, opts)
                } catch (e) {}
                return supportsPassive
            }
            function getSupportsTouchActionNone() {
                return window.CSS && CSS.supports && CSS.supports("touch-action", "none")
            }
            function subRangeRatio(pa, pb) {
                return 100 / (pb - pa)
            }
            function fromPercentage(range, value) {
                return 100 * value / (range[1] - range[0])
            }
            function toPercentage(range, value) {
                return fromPercentage(range, range[0] < 0 ? value + Math.abs(range[0]) : value - range[0])
            }
            function isPercentage(range, value) {
                return value * (range[1] - range[0]) / 100 + range[0]
            }
            function getJ(value, arr) {
                for (var j = 1; value >= arr[j]; )
                    j += 1;
                return j
            }
            function toStepping(xVal, xPct, value) {
                if (value >= xVal.slice(-1)[0])
                    return 100;
                var va, vb, pa, pb, j = getJ(value, xVal);
                return va = xVal[j - 1],
                vb = xVal[j],
                pa = xPct[j - 1],
                pb = xPct[j],
                pa + toPercentage([va, vb], value) / subRangeRatio(pa, pb)
            }
            function fromStepping(xVal, xPct, value) {
                if (value >= 100)
                    return xVal.slice(-1)[0];
                var va, vb, pa, pb, j = getJ(value, xPct);
                return va = xVal[j - 1],
                vb = xVal[j],
                pa = xPct[j - 1],
                pb = xPct[j],
                isPercentage([va, vb], (value - pa) * subRangeRatio(pa, pb))
            }
            function getStep(xPct, xSteps, snap, value) {
                if (100 === value)
                    return value;
                var a, b, j = getJ(value, xPct);
                return snap ? (a = xPct[j - 1],
                b = xPct[j],
                value - a > (b - a) / 2 ? b : a) : xSteps[j - 1] ? xPct[j - 1] + closest(value - xPct[j - 1], xSteps[j - 1]) : value
            }
            function handleEntryPoint(index, value, that) {
                var percentage;
                if ("number" == typeof value && (value = [value]),
                "[object Array]" !== Object.prototype.toString.call(value))
                    throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
                if (percentage = "min" === index ? 0 : "max" === index ? 100 : parseFloat(index),
                !isNumeric(percentage) || !isNumeric(value[0]))
                    throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
                that.xPct.push(percentage),
                that.xVal.push(value[0]),
                percentage ? that.xSteps.push(!isNaN(value[1]) && value[1]) : isNaN(value[1]) || (that.xSteps[0] = value[1]),
                that.xHighestCompleteStep.push(0)
            }
            function handleStepPoint(i, n, that) {
                if (!n)
                    return !0;
                that.xSteps[i] = fromPercentage([that.xVal[i], that.xVal[i + 1]], n) / subRangeRatio(that.xPct[i], that.xPct[i + 1]);
                var totalSteps = (that.xVal[i + 1] - that.xVal[i]) / that.xNumSteps[i]
                  , highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1)
                  , step = that.xVal[i] + that.xNumSteps[i] * highestStep;
                that.xHighestCompleteStep[i] = step
            }
            function Spectrum(entry, snap, singleStep) {
                this.xPct = [],
                this.xVal = [],
                this.xSteps = [singleStep || !1],
                this.xNumSteps = [!1],
                this.xHighestCompleteStep = [],
                this.snap = snap;
                var index, ordered = [];
                for (index in entry)
                    entry.hasOwnProperty(index) && ordered.push([entry[index], index]);
                for (ordered.length && "object" == typeof ordered[0][0] ? ordered.sort(function(a, b) {
                    return a[0][0] - b[0][0]
                }) : ordered.sort(function(a, b) {
                    return a[0] - b[0]
                }),
                index = 0; index < ordered.length; index++)
                    handleEntryPoint(ordered[index][1], ordered[index][0], this);
                for (this.xNumSteps = this.xSteps.slice(0),
                index = 0; index < this.xNumSteps.length; index++)
                    handleStepPoint(index, this.xNumSteps[index], this)
            }
            function validateFormat(entry) {
                if (isValidFormatter(entry))
                    return !0;
                throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.")
            }
            function testStep(parsed, entry) {
                if (!isNumeric(entry))
                    throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
                parsed.singleStep = entry
            }
            function testRange(parsed, entry) {
                if ("object" != typeof entry || Array.isArray(entry))
                    throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
                if (void 0 === entry.min || void 0 === entry.max)
                    throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
                if (entry.min === entry.max)
                    throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
                parsed.spectrum = new Spectrum(entry,parsed.snap,parsed.singleStep)
            }
            function testStart(parsed, entry) {
                if (entry = asArray(entry),
                !Array.isArray(entry) || !entry.length)
                    throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
                parsed.handles = entry.length,
                parsed.start = entry
            }
            function testSnap(parsed, entry) {
                if (parsed.snap = entry,
                "boolean" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.")
            }
            function testAnimate(parsed, entry) {
                if (parsed.animate = entry,
                "boolean" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.")
            }
            function testAnimationDuration(parsed, entry) {
                if (parsed.animationDuration = entry,
                "number" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.")
            }
            function testConnect(parsed, entry) {
                var i, connect = [!1];
                if ("lower" === entry ? entry = [!0, !1] : "upper" === entry && (entry = [!1, !0]),
                !0 === entry || !1 === entry) {
                    for (i = 1; i < parsed.handles; i++)
                        connect.push(entry);
                    connect.push(!1)
                } else {
                    if (!Array.isArray(entry) || !entry.length || entry.length !== parsed.handles + 1)
                        throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
                    connect = entry
                }
                parsed.connect = connect
            }
            function testOrientation(parsed, entry) {
                switch (entry) {
                case "horizontal":
                    parsed.ort = 0;
                    break;
                case "vertical":
                    parsed.ort = 1;
                    break;
                default:
                    throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.")
                }
            }
            function testMargin(parsed, entry) {
                if (!isNumeric(entry))
                    throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
                if (0 !== entry && (parsed.margin = parsed.spectrum.getMargin(entry),
                !parsed.margin))
                    throw new Error("noUiSlider (" + VERSION + "): 'margin' option is only supported on linear sliders.")
            }
            function testLimit(parsed, entry) {
                if (!isNumeric(entry))
                    throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
                if (parsed.limit = parsed.spectrum.getMargin(entry),
                !parsed.limit || parsed.handles < 2)
                    throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.")
            }
            function testPadding(parsed, entry) {
                if (!isNumeric(entry))
                    throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric.");
                if (0 !== entry) {
                    if (parsed.padding = parsed.spectrum.getMargin(entry),
                    !parsed.padding)
                        throw new Error("noUiSlider (" + VERSION + "): 'padding' option is only supported on linear sliders.");
                    if (parsed.padding < 0)
                        throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number.");
                    if (parsed.padding >= 50)
                        throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be less than half the range.")
                }
            }
            function testDirection(parsed, entry) {
                switch (entry) {
                case "ltr":
                    parsed.dir = 0;
                    break;
                case "rtl":
                    parsed.dir = 1;
                    break;
                default:
                    throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.")
                }
            }
            function testBehaviour(parsed, entry) {
                if ("string" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
                var tap = entry.indexOf("tap") >= 0
                  , drag = entry.indexOf("drag") >= 0
                  , fixed = entry.indexOf("fixed") >= 0
                  , snap = entry.indexOf("snap") >= 0
                  , hover = entry.indexOf("hover") >= 0;
                if (fixed) {
                    if (2 !== parsed.handles)
                        throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
                    testMargin(parsed, parsed.start[1] - parsed.start[0])
                }
                parsed.events = {
                    tap: tap || snap,
                    drag: drag,
                    fixed: fixed,
                    snap: snap,
                    hover: hover
                }
            }
            function testMultitouch(parsed, entry) {
                if (parsed.multitouch = entry,
                "boolean" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'multitouch' option must be a boolean.")
            }
            function testTooltips(parsed, entry) {
                if (!1 !== entry)
                    if (!0 === entry) {
                        parsed.tooltips = [];
                        for (var i = 0; i < parsed.handles; i++)
                            parsed.tooltips.push(!0)
                    } else {
                        if (parsed.tooltips = asArray(entry),
                        parsed.tooltips.length !== parsed.handles)
                            throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
                        parsed.tooltips.forEach(function(formatter) {
                            if ("boolean" != typeof formatter && ("object" != typeof formatter || "function" != typeof formatter.to))
                                throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.")
                        })
                    }
            }
            function testAriaFormat(parsed, entry) {
                parsed.ariaFormat = entry,
                validateFormat(entry)
            }
            function testFormat(parsed, entry) {
                parsed.format = entry,
                validateFormat(entry)
            }
            function testCssPrefix(parsed, entry) {
                if (void 0 !== entry && "string" != typeof entry && !1 !== entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
                parsed.cssPrefix = entry
            }
            function testCssClasses(parsed, entry) {
                if (void 0 !== entry && "object" != typeof entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
                if ("string" == typeof parsed.cssPrefix) {
                    parsed.cssClasses = {};
                    for (var key in entry)
                        entry.hasOwnProperty(key) && (parsed.cssClasses[key] = parsed.cssPrefix + entry[key])
                } else
                    parsed.cssClasses = entry
            }
            function testUseRaf(parsed, entry) {
                if (!0 !== entry && !1 !== entry)
                    throw new Error("noUiSlider (" + VERSION + "): 'useRequestAnimationFrame' option should be true (default) or false.");
                parsed.useRequestAnimationFrame = entry
            }
            function testOptions(options) {
                var parsed = {
                    margin: 0,
                    limit: 0,
                    padding: 0,
                    animate: !0,
                    animationDuration: 300,
                    ariaFormat: defaultFormatter,
                    format: defaultFormatter
                }
                  , tests = {
                    step: {
                        r: !1,
                        t: testStep
                    },
                    start: {
                        r: !0,
                        t: testStart
                    },
                    connect: {
                        r: !0,
                        t: testConnect
                    },
                    direction: {
                        r: !0,
                        t: testDirection
                    },
                    snap: {
                        r: !1,
                        t: testSnap
                    },
                    animate: {
                        r: !1,
                        t: testAnimate
                    },
                    animationDuration: {
                        r: !1,
                        t: testAnimationDuration
                    },
                    range: {
                        r: !0,
                        t: testRange
                    },
                    orientation: {
                        r: !1,
                        t: testOrientation
                    },
                    margin: {
                        r: !1,
                        t: testMargin
                    },
                    limit: {
                        r: !1,
                        t: testLimit
                    },
                    padding: {
                        r: !1,
                        t: testPadding
                    },
                    behaviour: {
                        r: !0,
                        t: testBehaviour
                    },
                    multitouch: {
                        r: !0,
                        t: testMultitouch
                    },
                    ariaFormat: {
                        r: !1,
                        t: testAriaFormat
                    },
                    format: {
                        r: !1,
                        t: testFormat
                    },
                    tooltips: {
                        r: !1,
                        t: testTooltips
                    },
                    cssPrefix: {
                        r: !1,
                        t: testCssPrefix
                    },
                    cssClasses: {
                        r: !1,
                        t: testCssClasses
                    },
                    useRequestAnimationFrame: {
                        r: !1,
                        t: testUseRaf
                    }
                }
                  , defaults = {
                    connect: !1,
                    direction: "ltr",
                    behaviour: "tap",
                    multitouch: !1,
                    orientation: "horizontal",
                    cssPrefix: "noUi-",
                    cssClasses: {
                        target: "target",
                        base: "base",
                        origin: "origin",
                        handle: "handle",
                        handleLower: "handle-lower",
                        handleUpper: "handle-upper",
                        horizontal: "horizontal",
                        vertical: "vertical",
                        background: "background",
                        connect: "connect",
                        ltr: "ltr",
                        rtl: "rtl",
                        draggable: "draggable",
                        drag: "state-drag",
                        tap: "state-tap",
                        active: "active",
                        tooltip: "tooltip",
                        pips: "pips",
                        pipsHorizontal: "pips-horizontal",
                        pipsVertical: "pips-vertical",
                        marker: "marker",
                        markerHorizontal: "marker-horizontal",
                        markerVertical: "marker-vertical",
                        markerNormal: "marker-normal",
                        markerLarge: "marker-large",
                        markerSub: "marker-sub",
                        value: "value",
                        valueHorizontal: "value-horizontal",
                        valueVertical: "value-vertical",
                        valueNormal: "value-normal",
                        valueLarge: "value-large",
                        valueSub: "value-sub"
                    },
                    useRequestAnimationFrame: !0
                };
                options.format && !options.ariaFormat && (options.ariaFormat = options.format),
                Object.keys(tests).forEach(function(name) {
                    if (void 0 === options[name] && void 0 === defaults[name]) {
                        if (tests[name].r)
                            throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
                        return !0
                    }
                    tests[name].t(parsed, void 0 === options[name] ? defaults[name] : options[name])
                }),
                parsed.pips = options.pips;
                var styles = [["left", "top"], ["right", "bottom"]];
                return parsed.style = styles[parsed.dir][parsed.ort],
                parsed.styleOposite = styles[parsed.dir ? 0 : 1][parsed.ort],
                parsed
            }
            function closure(target, options, originalOptions) {
                function addNodeTo(target, className) {
                    var div = scope_Document.createElement("div");
                    return className && addClass(div, className),
                    target.appendChild(div),
                    div
                }
                function addOrigin(base, handleNumber) {
                    var origin = addNodeTo(base, options.cssClasses.origin)
                      , handle = addNodeTo(origin, options.cssClasses.handle);
                    return handle.setAttribute("data-handle", handleNumber),
                    handle.setAttribute("tabindex", "0"),
                    handle.setAttribute("role", "slider"),
                    handle.setAttribute("aria-orientation", options.ort ? "vertical" : "horizontal"),
                    0 === handleNumber ? addClass(handle, options.cssClasses.handleLower) : handleNumber === options.handles - 1 && addClass(handle, options.cssClasses.handleUpper),
                    origin
                }
                function addConnect(base, add) {
                    return !!add && addNodeTo(base, options.cssClasses.connect)
                }
                function addTooltip(handle, handleNumber) {
                    return !!options.tooltips[handleNumber] && addNodeTo(handle.firstChild, options.cssClasses.tooltip)
                }
                function getGroup(mode, values, stepped) {
                    if ("range" === mode || "steps" === mode)
                        return scope_Spectrum.xVal;
                    if ("count" === mode) {
                        if (!values)
                            throw new Error("noUiSlider (" + VERSION + "): 'values' required for mode 'count'.");
                        var v, spread = 100 / (values - 1), i = 0;
                        for (values = []; (v = i++ * spread) <= 100; )
                            values.push(v);
                        mode = "positions"
                    }
                    return "positions" === mode ? values.map(function(value) {
                        return scope_Spectrum.fromStepping(stepped ? scope_Spectrum.getStep(value) : value)
                    }) : "values" === mode ? stepped ? values.map(function(value) {
                        return scope_Spectrum.fromStepping(scope_Spectrum.getStep(scope_Spectrum.toStepping(value)))
                    }) : values : void 0
                }
                function generateSpread(density, mode, group) {
                    function safeIncrement(value, increment) {
                        return (value + increment).toFixed(7) / 1
                    }
                    var indexes = {}
                      , firstInRange = scope_Spectrum.xVal[0]
                      , lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length - 1]
                      , ignoreFirst = !1
                      , ignoreLast = !1
                      , prevPct = 0;
                    return (group = unique(group.slice().sort(function(a, b) {
                        return a - b
                    })))[0] !== firstInRange && (group.unshift(firstInRange),
                    ignoreFirst = !0),
                    group[group.length - 1] !== lastInRange && (group.push(lastInRange),
                    ignoreLast = !0),
                    group.forEach(function(current, index) {
                        var step, i, q, newPct, pctDifference, type, steps, realSteps, stepsize, low = current, high = group[index + 1];
                        if ("steps" === mode && (step = scope_Spectrum.xNumSteps[index]),
                        step || (step = high - low),
                        !1 !== low && void 0 !== high)
                            for (step = Math.max(step, 1e-7),
                            i = low; i <= high; i = safeIncrement(i, step)) {
                                for (steps = (pctDifference = (newPct = scope_Spectrum.toStepping(i)) - prevPct) / density,
                                stepsize = pctDifference / (realSteps = Math.round(steps)),
                                q = 1; q <= realSteps; q += 1)
                                    indexes[(prevPct + q * stepsize).toFixed(5)] = ["x", 0];
                                type = group.indexOf(i) > -1 ? 1 : "steps" === mode ? 2 : 0,
                                !index && ignoreFirst && (type = 0),
                                i === high && ignoreLast || (indexes[newPct.toFixed(5)] = [i, type]),
                                prevPct = newPct
                            }
                    }),
                    indexes
                }
                function addMarking(spread, filterFunc, formatter) {
                    function getClasses(type, source) {
                        var a = source === options.cssClasses.value
                          , orientationClasses = a ? valueOrientationClasses : markerOrientationClasses
                          , sizeClasses = a ? valueSizeClasses : markerSizeClasses;
                        return source + " " + orientationClasses[options.ort] + " " + sizeClasses[type]
                    }
                    function addSpread(offset, values) {
                        values[1] = values[1] && filterFunc ? filterFunc(values[0], values[1]) : values[1];
                        var node = addNodeTo(element, !1);
                        node.className = getClasses(values[1], options.cssClasses.marker),
                        node.style[options.style] = offset + "%",
                        values[1] && ((node = addNodeTo(element, !1)).className = getClasses(values[1], options.cssClasses.value),
                        node.style[options.style] = offset + "%",
                        node.innerText = formatter.to(values[0]))
                    }
                    var element = scope_Document.createElement("div")
                      , valueSizeClasses = [options.cssClasses.valueNormal, options.cssClasses.valueLarge, options.cssClasses.valueSub]
                      , markerSizeClasses = [options.cssClasses.markerNormal, options.cssClasses.markerLarge, options.cssClasses.markerSub]
                      , valueOrientationClasses = [options.cssClasses.valueHorizontal, options.cssClasses.valueVertical]
                      , markerOrientationClasses = [options.cssClasses.markerHorizontal, options.cssClasses.markerVertical];
                    return addClass(element, options.cssClasses.pips),
                    addClass(element, 0 === options.ort ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical),
                    Object.keys(spread).forEach(function(a) {
                        addSpread(a, spread[a])
                    }),
                    element
                }
                function removePips() {
                    scope_Pips && (removeElement(scope_Pips),
                    scope_Pips = null)
                }
                function pips(grid) {
                    removePips();
                    var mode = grid.mode
                      , density = grid.density || 1
                      , filter = grid.filter || !1
                      , spread = generateSpread(density, mode, getGroup(mode, grid.values || !1, grid.stepped || !1))
                      , format = grid.format || {
                        to: Math.round
                    };
                    return scope_Pips = scope_Target.appendChild(addMarking(spread, filter, format))
                }
                function baseSize() {
                    var rect = scope_Base.getBoundingClientRect()
                      , alt = "offset" + ["Width", "Height"][options.ort];
                    return 0 === options.ort ? rect.width || scope_Base[alt] : rect.height || scope_Base[alt]
                }
                function attachEvent(events, element, callback, data) {
                    var method = function(e) {
                        return !scope_Target.hasAttribute("disabled") && (!hasClass(scope_Target, options.cssClasses.tap) && (!!(e = fixEvent(e, data.pageOffset, data.target || element)) && (!(events === actions.start && void 0 !== e.buttons && e.buttons > 1) && ((!data.hover || !e.buttons) && (supportsPassive || e.preventDefault(),
                        e.calcPoint = e.points[options.ort],
                        void callback(e, data))))))
                    }
                      , methods = [];
                    return events.split(" ").forEach(function(eventName) {
                        element.addEventListener(eventName, method, !!supportsPassive && {
                            passive: !0
                        }),
                        methods.push([eventName, method])
                    }),
                    methods
                }
                function fixEvent(e, pageOffset, target) {
                    var x, y, touch = 0 === e.type.indexOf("touch"), mouse = 0 === e.type.indexOf("mouse"), pointer = 0 === e.type.indexOf("pointer");
                    if (0 === e.type.indexOf("MSPointer") && (pointer = !0),
                    touch && options.multitouch) {
                        var isTouchOnTarget = function(touch) {
                            return touch.target === target || target.contains(touch.target)
                        };
                        if ("touchstart" === e.type) {
                            var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
                            if (targetTouches.length > 1)
                                return !1;
                            x = targetTouches[0].pageX,
                            y = targetTouches[0].pageY
                        } else {
                            var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
                            if (!targetTouch)
                                return !1;
                            x = targetTouch.pageX,
                            y = targetTouch.pageY
                        }
                    } else if (touch) {
                        if (e.touches.length > 1)
                            return !1;
                        x = e.changedTouches[0].pageX,
                        y = e.changedTouches[0].pageY
                    }
                    return pageOffset = pageOffset || getPageOffset(scope_Document),
                    (mouse || pointer) && (x = e.clientX + pageOffset.x,
                    y = e.clientY + pageOffset.y),
                    e.pageOffset = pageOffset,
                    e.points = [x, y],
                    e.cursor = mouse || pointer,
                    e
                }
                function calcPointToPercentage(calcPoint) {
                    var proposal = 100 * (calcPoint - offset(scope_Base, options.ort)) / baseSize();
                    return options.dir ? 100 - proposal : proposal
                }
                function getClosestHandle(proposal) {
                    var closest = 100
                      , handleNumber = !1;
                    return scope_Handles.forEach(function(handle, index) {
                        if (!handle.hasAttribute("disabled")) {
                            var pos = Math.abs(scope_Locations[index] - proposal);
                            pos < closest && (handleNumber = index,
                            closest = pos)
                        }
                    }),
                    handleNumber
                }
                function moveHandles(upward, proposal, locations, handleNumbers) {
                    var proposals = locations.slice()
                      , b = [!upward, upward]
                      , f = [upward, !upward];
                    handleNumbers = handleNumbers.slice(),
                    upward && handleNumbers.reverse(),
                    handleNumbers.length > 1 ? handleNumbers.forEach(function(handleNumber, o) {
                        var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], !1);
                        !1 === to ? proposal = 0 : (proposal = to - proposals[handleNumber],
                        proposals[handleNumber] = to)
                    }) : b = f = [!0];
                    var state = !1;
                    handleNumbers.forEach(function(handleNumber, o) {
                        state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state
                    }),
                    state && handleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber),
                        fireEvent("slide", handleNumber)
                    })
                }
                function fireEvent(eventName, handleNumber, tap) {
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        var eventType = targetEvent.split(".")[0];
                        eventName === eventType && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, scope_Values.map(options.format.to), handleNumber, scope_Values.slice(), tap || !1, scope_Locations.slice())
                        })
                    })
                }
                function documentLeave(event, data) {
                    "mouseout" === event.type && "HTML" === event.target.nodeName && null === event.relatedTarget && eventEnd(event, data)
                }
                function eventMove(event, data) {
                    if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === event.buttons && 0 !== data.buttonsProperty)
                        return eventEnd(event, data);
                    var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
                    moveHandles(movement > 0, 100 * movement / data.baseSize, data.locations, data.handleNumbers)
                }
                function eventEnd(event, data) {
                    data.handle && (removeClass(data.handle, options.cssClasses.active),
                    scope_ActiveHandlesCount -= 1),
                    data.listeners.forEach(function(c) {
                        scope_DocumentElement.removeEventListener(c[0], c[1])
                    }),
                    0 === scope_ActiveHandlesCount && (removeClass(scope_Target, options.cssClasses.drag),
                    setZindex(),
                    event.cursor && (scope_Body.style.cursor = "",
                    scope_Body.removeEventListener("selectstart", preventDefault))),
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("change", handleNumber),
                        fireEvent("set", handleNumber),
                        fireEvent("end", handleNumber)
                    })
                }
                function eventStart(event, data) {
                    var handle;
                    if (1 === data.handleNumbers.length) {
                        var handleOrigin = scope_Handles[data.handleNumbers[0]];
                        if (handleOrigin.hasAttribute("disabled"))
                            return !1;
                        handle = handleOrigin.children[0],
                        scope_ActiveHandlesCount += 1,
                        addClass(handle, options.cssClasses.active)
                    }
                    event.stopPropagation();
                    var listeners = []
                      , moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
                        target: event.target,
                        handle: handle,
                        listeners: listeners,
                        startCalcPoint: event.calcPoint,
                        baseSize: baseSize(),
                        pageOffset: event.pageOffset,
                        handleNumbers: data.handleNumbers,
                        buttonsProperty: event.buttons,
                        locations: scope_Locations.slice()
                    })
                      , endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
                        target: event.target,
                        handle: handle,
                        listeners: listeners,
                        handleNumbers: data.handleNumbers
                    })
                      , outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
                        target: event.target,
                        handle: handle,
                        listeners: listeners,
                        handleNumbers: data.handleNumbers
                    });
                    listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent)),
                    event.cursor && (scope_Body.style.cursor = getComputedStyle(event.target).cursor,
                    scope_Handles.length > 1 && addClass(scope_Target, options.cssClasses.drag),
                    scope_Body.addEventListener("selectstart", preventDefault, !1)),
                    data.handleNumbers.forEach(function(handleNumber) {
                        fireEvent("start", handleNumber)
                    })
                }
                function eventTap(event) {
                    event.stopPropagation();
                    var proposal = calcPointToPercentage(event.calcPoint)
                      , handleNumber = getClosestHandle(proposal);
                    if (!1 === handleNumber)
                        return !1;
                    options.events.snap || addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration),
                    setHandle(handleNumber, proposal, !0, !0),
                    setZindex(),
                    fireEvent("slide", handleNumber, !0),
                    fireEvent("update", handleNumber, !0),
                    fireEvent("change", handleNumber, !0),
                    fireEvent("set", handleNumber, !0),
                    options.events.snap && eventStart(event, {
                        handleNumbers: [handleNumber]
                    })
                }
                function eventHover(event) {
                    var proposal = calcPointToPercentage(event.calcPoint)
                      , to = scope_Spectrum.getStep(proposal)
                      , value = scope_Spectrum.fromStepping(to);
                    Object.keys(scope_Events).forEach(function(targetEvent) {
                        "hover" === targetEvent.split(".")[0] && scope_Events[targetEvent].forEach(function(callback) {
                            callback.call(scope_Self, value)
                        })
                    })
                }
                function checkHandlePosition(reference, handleNumber, to, lookBackward, lookForward, getValue) {
                    return scope_Handles.length > 1 && (lookBackward && handleNumber > 0 && (to = Math.max(to, reference[handleNumber - 1] + options.margin)),
                    lookForward && handleNumber < scope_Handles.length - 1 && (to = Math.min(to, reference[handleNumber + 1] - options.margin))),
                    scope_Handles.length > 1 && options.limit && (lookBackward && handleNumber > 0 && (to = Math.min(to, reference[handleNumber - 1] + options.limit)),
                    lookForward && handleNumber < scope_Handles.length - 1 && (to = Math.max(to, reference[handleNumber + 1] - options.limit))),
                    options.padding && (0 === handleNumber && (to = Math.max(to, options.padding)),
                    handleNumber === scope_Handles.length - 1 && (to = Math.min(to, 100 - options.padding))),
                    to = scope_Spectrum.getStep(to),
                    !((to = limit(to)) === reference[handleNumber] && !getValue) && to
                }
                function toPct(pct) {
                    return pct + "%"
                }
                function updateHandlePosition(handleNumber, to) {
                    scope_Locations[handleNumber] = to,
                    scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
                    var stateUpdate = function() {
                        scope_Handles[handleNumber].style[options.style] = toPct(to),
                        updateConnect(handleNumber),
                        updateConnect(handleNumber + 1)
                    };
                    window.requestAnimationFrame && options.useRequestAnimationFrame ? window.requestAnimationFrame(stateUpdate) : stateUpdate()
                }
                function setZindex() {
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        var dir = scope_Locations[handleNumber] > 50 ? -1 : 1
                          , zIndex = 3 + (scope_Handles.length + dir * handleNumber);
                        scope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex
                    })
                }
                function setHandle(handleNumber, to, lookBackward, lookForward) {
                    return !1 !== (to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, !1)) && (updateHandlePosition(handleNumber, to),
                    !0)
                }
                function updateConnect(index) {
                    if (scope_Connects[index]) {
                        var l = 0
                          , h = 100;
                        0 !== index && (l = scope_Locations[index - 1]),
                        index !== scope_Connects.length - 1 && (h = scope_Locations[index]),
                        scope_Connects[index].style[options.style] = toPct(l),
                        scope_Connects[index].style[options.styleOposite] = toPct(100 - h)
                    }
                }
                function setValue(to, handleNumber) {
                    null !== to && !1 !== to && ("number" == typeof to && (to = String(to)),
                    !1 === (to = options.format.from(to)) || isNaN(to) || setHandle(handleNumber, scope_Spectrum.toStepping(to), !1, !1))
                }
                function valueSet(input, fireSetEvent) {
                    var values = asArray(input)
                      , isInit = void 0 === scope_Locations[0];
                    fireSetEvent = void 0 === fireSetEvent || !!fireSetEvent,
                    values.forEach(setValue),
                    options.animate && !isInit && addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration),
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        setHandle(handleNumber, scope_Locations[handleNumber], !0, !1)
                    }),
                    setZindex(),
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        fireEvent("update", handleNumber),
                        null !== values[handleNumber] && fireSetEvent && fireEvent("set", handleNumber)
                    })
                }
                function valueGet() {
                    var values = scope_Values.map(options.format.to);
                    return 1 === values.length ? values[0] : values
                }
                function bindEvent(namespacedEvent, callback) {
                    scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [],
                    scope_Events[namespacedEvent].push(callback),
                    "update" === namespacedEvent.split(".")[0] && scope_Handles.forEach(function(a, index) {
                        fireEvent("update", index)
                    })
                }
                var scope_Base, scope_Handles, scope_Connects, scope_Self, scope_Pips, actions = getActions(), supportsPassive = getSupportsTouchActionNone() && getSupportsPassive(), scope_Target = target, scope_Locations = [], scope_HandleNumbers = [], scope_ActiveHandlesCount = 0, scope_Spectrum = options.spectrum, scope_Values = [], scope_Events = {}, scope_Document = target.ownerDocument, scope_DocumentElement = scope_Document.documentElement, scope_Body = scope_Document.body;
                if (scope_Target.noUiSlider)
                    throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
                return function(target) {
                    addClass(target, options.cssClasses.target),
                    0 === options.dir ? addClass(target, options.cssClasses.ltr) : addClass(target, options.cssClasses.rtl),
                    0 === options.ort ? addClass(target, options.cssClasses.horizontal) : addClass(target, options.cssClasses.vertical),
                    scope_Base = addNodeTo(target, options.cssClasses.base)
                }(scope_Target),
                function(connectOptions, base) {
                    scope_Handles = [],
                    (scope_Connects = []).push(addConnect(base, connectOptions[0]));
                    for (var i = 0; i < options.handles; i++)
                        scope_Handles.push(addOrigin(base, i)),
                        scope_HandleNumbers[i] = i,
                        scope_Connects.push(addConnect(base, connectOptions[i + 1]))
                }(options.connect, scope_Base),
                scope_Self = {
                    destroy: function() {
                        for (var key in options.cssClasses)
                            options.cssClasses.hasOwnProperty(key) && removeClass(scope_Target, options.cssClasses[key]);
                        for (; scope_Target.firstChild; )
                            scope_Target.removeChild(scope_Target.firstChild);
                        delete scope_Target.noUiSlider
                    },
                    steps: function() {
                        return scope_Locations.map(function(location, index) {
                            var nearbySteps = scope_Spectrum.getNearbySteps(location)
                              , value = scope_Values[index]
                              , increment = nearbySteps.thisStep.step
                              , decrement = null;
                            !1 !== increment && value + increment > nearbySteps.stepAfter.startValue && (increment = nearbySteps.stepAfter.startValue - value),
                            decrement = value > nearbySteps.thisStep.startValue ? nearbySteps.thisStep.step : !1 !== nearbySteps.stepBefore.step && value - nearbySteps.stepBefore.highestStep,
                            100 === location ? increment = null : 0 === location && (decrement = null);
                            var stepDecimals = scope_Spectrum.countStepDecimals();
                            return null !== increment && !1 !== increment && (increment = Number(increment.toFixed(stepDecimals))),
                            null !== decrement && !1 !== decrement && (decrement = Number(decrement.toFixed(stepDecimals))),
                            [decrement, increment]
                        })
                    },
                    on: bindEvent,
                    off: function(namespacedEvent) {
                        var event = namespacedEvent && namespacedEvent.split(".")[0]
                          , namespace = event && namespacedEvent.substring(event.length);
                        Object.keys(scope_Events).forEach(function(bind) {
                            var tEvent = bind.split(".")[0]
                              , tNamespace = bind.substring(tEvent.length);
                            event && event !== tEvent || namespace && namespace !== tNamespace || delete scope_Events[bind]
                        })
                    },
                    get: valueGet,
                    set: valueSet,
                    reset: function(fireSetEvent) {
                        valueSet(options.start, fireSetEvent)
                    },
                    __moveHandles: function(a, b, c) {
                        moveHandles(a, b, scope_Locations, c)
                    },
                    options: originalOptions,
                    updateOptions: function(optionsToUpdate, fireSetEvent) {
                        var v = valueGet()
                          , updateAble = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format"];
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (originalOptions[name] = optionsToUpdate[name])
                        });
                        var newOptions = testOptions(originalOptions);
                        updateAble.forEach(function(name) {
                            void 0 !== optionsToUpdate[name] && (options[name] = newOptions[name])
                        }),
                        scope_Spectrum = newOptions.spectrum,
                        options.margin = newOptions.margin,
                        options.limit = newOptions.limit,
                        options.padding = newOptions.padding,
                        options.pips && pips(options.pips),
                        scope_Locations = [],
                        valueSet(optionsToUpdate.start || v, fireSetEvent)
                    },
                    target: scope_Target,
                    removePips: removePips,
                    pips: pips
                },
                function(behaviour) {
                    behaviour.fixed || scope_Handles.forEach(function(handle, index) {
                        attachEvent(actions.start, handle.children[0], eventStart, {
                            handleNumbers: [index]
                        })
                    }),
                    behaviour.tap && attachEvent(actions.start, scope_Base, eventTap, {}),
                    behaviour.hover && attachEvent(actions.move, scope_Base, eventHover, {
                        hover: !0
                    }),
                    behaviour.drag && scope_Connects.forEach(function(connect, index) {
                        if (!1 !== connect && 0 !== index && index !== scope_Connects.length - 1) {
                            var handleBefore = scope_Handles[index - 1]
                              , handleAfter = scope_Handles[index]
                              , eventHolders = [connect];
                            addClass(connect, options.cssClasses.draggable),
                            behaviour.fixed && (eventHolders.push(handleBefore.children[0]),
                            eventHolders.push(handleAfter.children[0])),
                            eventHolders.forEach(function(eventHolder) {
                                attachEvent(actions.start, eventHolder, eventStart, {
                                    handles: [handleBefore, handleAfter],
                                    handleNumbers: [index - 1, index]
                                })
                            })
                        }
                    })
                }(options.events),
                valueSet(options.start),
                options.pips && pips(options.pips),
                options.tooltips && function() {
                    var tips = scope_Handles.map(addTooltip);
                    bindEvent("update", function(values, handleNumber, unencoded) {
                        if (tips[handleNumber]) {
                            var formattedValue = values[handleNumber];
                            !0 !== options.tooltips[handleNumber] && (formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber])),
                            tips[handleNumber].innerHTML = formattedValue
                        }
                    })
                }(),
                bindEvent("update", function(values, handleNumber, unencoded, tap, positions) {
                    scope_HandleNumbers.forEach(function(handleNumber) {
                        var handle = scope_Handles[handleNumber]
                          , min = checkHandlePosition(scope_Locations, handleNumber, 0, !0, !0, !0)
                          , max = checkHandlePosition(scope_Locations, handleNumber, 100, !0, !0, !0)
                          , now = positions[handleNumber]
                          , text = options.ariaFormat.to(unencoded[handleNumber]);
                        handle.children[0].setAttribute("aria-valuemin", min.toFixed(1)),
                        handle.children[0].setAttribute("aria-valuemax", max.toFixed(1)),
                        handle.children[0].setAttribute("aria-valuenow", now.toFixed(1)),
                        handle.children[0].setAttribute("aria-valuetext", text)
                    })
                }),
                scope_Self
            }
            var VERSION = "10.1.0";
            Spectrum.prototype.getMargin = function(value) {
                var step = this.xNumSteps[0];
                if (step && value / step % 1 != 0)
                    throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' must be divisible by step.");
                return 2 === this.xPct.length && fromPercentage(this.xVal, value)
            }
            ,
            Spectrum.prototype.toStepping = function(value) {
                return value = toStepping(this.xVal, this.xPct, value)
            }
            ,
            Spectrum.prototype.fromStepping = function(value) {
                return fromStepping(this.xVal, this.xPct, value)
            }
            ,
            Spectrum.prototype.getStep = function(value) {
                return value = getStep(this.xPct, this.xSteps, this.snap, value)
            }
            ,
            Spectrum.prototype.getNearbySteps = function(value) {
                var j = getJ(value, this.xPct);
                return {
                    stepBefore: {
                        startValue: this.xVal[j - 2],
                        step: this.xNumSteps[j - 2],
                        highestStep: this.xHighestCompleteStep[j - 2]
                    },
                    thisStep: {
                        startValue: this.xVal[j - 1],
                        step: this.xNumSteps[j - 1],
                        highestStep: this.xHighestCompleteStep[j - 1]
                    },
                    stepAfter: {
                        startValue: this.xVal[j - 0],
                        step: this.xNumSteps[j - 0],
                        highestStep: this.xHighestCompleteStep[j - 0]
                    }
                }
            }
            ,
            Spectrum.prototype.countStepDecimals = function() {
                var stepDecimals = this.xNumSteps.map(countDecimals);
                return Math.max.apply(null, stepDecimals)
            }
            ,
            Spectrum.prototype.convert = function(value) {
                return this.getStep(this.toStepping(value))
            }
            ;
            var defaultFormatter = {
                to: function(value) {
                    return void 0 !== value && value.toFixed(2)
                },
                from: Number
            };
            return {
                version: VERSION,
                create: function(target, originalOptions) {
                    if (!target || !target.nodeName)
                        throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
                    var api = closure(target, testOptions(originalOptions, target), originalOptions);
                    return target.noUiSlider = api,
                    api
                }
            }
        })
    }
    , {}],
    19: [function(require, module, exports) {
        !function(window) {
            var ua = navigator.userAgent;
            window.HTMLPictureElement && /ecko/.test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 < 45 && addEventListener("resize", function() {
                var timer, dummySrc = document.createElement("source"), fixRespimg = function(img) {
                    var source, sizes, picture = img.parentNode;
                    "PICTURE" === picture.nodeName.toUpperCase() ? (source = dummySrc.cloneNode(),
                    picture.insertBefore(source, picture.firstElementChild),
                    setTimeout(function() {
                        picture.removeChild(source)
                    })) : (!img._pfLastSize || img.offsetWidth > img._pfLastSize) && (img._pfLastSize = img.offsetWidth,
                    sizes = img.sizes,
                    img.sizes += ",100vw",
                    setTimeout(function() {
                        img.sizes = sizes
                    }))
                }, findPictureImgs = function() {
                    var i, imgs = document.querySelectorAll("picture > img, img[srcset][sizes]");
                    for (i = 0; i < imgs.length; i++)
                        fixRespimg(imgs[i])
                }, onResize = function() {
                    clearTimeout(timer),
                    timer = setTimeout(findPictureImgs, 99)
                }, mq = window.matchMedia && matchMedia("(orientation: landscape)"), init = function() {
                    onResize(),
                    mq && mq.addListener && mq.addListener(onResize)
                };
                return dummySrc.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                /^[c|i]|d$/.test(document.readyState || "") ? init() : document.addEventListener("DOMContentLoaded", init),
                onResize
            }())
        }(window),
        function(window, document, undefined) {
            "use strict";
            function isSpace(c) {
                return " " === c || "\t" === c || "\n" === c || "\f" === c || "\r" === c
            }
            function updateMetrics() {
                isVwDirty = !1,
                DPR = window.devicePixelRatio,
                cssCache = {},
                sizeLengthCache = {},
                pf.DPR = DPR || 1,
                units.width = Math.max(window.innerWidth || 0, docElem.clientWidth),
                units.height = Math.max(window.innerHeight || 0, docElem.clientHeight),
                units.vw = units.width / 100,
                units.vh = units.height / 100,
                evalId = [units.height, units.width, DPR].join("-"),
                units.em = pf.getEmValue(),
                units.rem = units.em
            }
            function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {
                var bonusFactor, bonus, meanDensity;
                return "saveData" === cfg.algorithm ? lowerValue > 2.7 ? meanDensity = dprValue + 1 : (bonus = (higherValue - dprValue) * (bonusFactor = Math.pow(lowerValue - .6, 1.5)),
                isCached && (bonus += .1 * bonusFactor),
                meanDensity = lowerValue + bonus) : meanDensity = dprValue > 1 ? Math.sqrt(lowerValue * higherValue) : lowerValue,
                meanDensity > dprValue
            }
            function applyBestCandidate(img) {
                var srcSetCandidates, matchingSet = pf.getSet(img), evaluated = !1;
                "pending" !== matchingSet && (evaluated = evalId,
                matchingSet && (srcSetCandidates = pf.setRes(matchingSet),
                pf.applySetCandidate(srcSetCandidates, img))),
                img[pf.ns].evaled = evaluated
            }
            function ascendingSort(a, b) {
                return a.res - b.res
            }
            function setSrcToCur(img, src, set) {
                var candidate;
                return !set && src && (set = (set = img[pf.ns].sets) && set[set.length - 1]),
                (candidate = getCandidateForSrc(src, set)) && (src = pf.makeUrl(src),
                img[pf.ns].curSrc = src,
                img[pf.ns].curCan = candidate,
                candidate.res || setResolution(candidate, candidate.set.sizes)),
                candidate
            }
            function getCandidateForSrc(src, set) {
                var i, candidate, candidates;
                if (src && set)
                    for (candidates = pf.parseSet(set),
                    src = pf.makeUrl(src),
                    i = 0; i < candidates.length; i++)
                        if (src === pf.makeUrl(candidates[i].url)) {
                            candidate = candidates[i];
                            break
                        }
                return candidate
            }
            function getAllSourceElements(picture, candidates) {
                var i, len, source, srcset, sources = picture.getElementsByTagName("source");
                for (i = 0,
                len = sources.length; i < len; i++)
                    (source = sources[i])[pf.ns] = !0,
                    (srcset = source.getAttribute("srcset")) && candidates.push({
                        srcset: srcset,
                        media: source.getAttribute("media"),
                        type: source.getAttribute("type"),
                        sizes: source.getAttribute("sizes")
                    })
            }
            function parseSrcset(input, set) {
                function collectCharacters(regEx) {
                    var chars, match = regEx.exec(input.substring(pos));
                    if (match)
                        return chars = match[0],
                        pos += chars.length,
                        chars
                }
                function parseDescriptors() {
                    var w, d, h, i, desc, lastChar, value, intVal, floatVal, pError = !1, candidate = {};
                    for (i = 0; i < descriptors.length; i++)
                        lastChar = (desc = descriptors[i])[desc.length - 1],
                        value = desc.substring(0, desc.length - 1),
                        intVal = parseInt(value, 10),
                        floatVal = parseFloat(value),
                        regexNonNegativeInteger.test(value) && "w" === lastChar ? ((w || d) && (pError = !0),
                        0 === intVal ? pError = !0 : w = intVal) : regexFloatingPoint.test(value) && "x" === lastChar ? ((w || d || h) && (pError = !0),
                        floatVal < 0 ? pError = !0 : d = floatVal) : regexNonNegativeInteger.test(value) && "h" === lastChar ? ((h || d) && (pError = !0),
                        0 === intVal ? pError = !0 : h = intVal) : pError = !0;
                    pError || (candidate.url = url,
                    w && (candidate.w = w),
                    d && (candidate.d = d),
                    h && (candidate.h = h),
                    h || d || w || (candidate.d = 1),
                    1 === candidate.d && (set.has1x = !0),
                    candidate.set = set,
                    candidates.push(candidate))
                }
                for (var url, descriptors, currentDescriptor, state, c, inputLength = input.length, pos = 0, candidates = []; ; ) {
                    if (collectCharacters(regexLeadingCommasOrSpaces),
                    pos >= inputLength)
                        return candidates;
                    url = collectCharacters(regexLeadingNotSpaces),
                    descriptors = [],
                    "," === url.slice(-1) ? (url = url.replace(regexTrailingCommas, ""),
                    parseDescriptors()) : function() {
                        for (collectCharacters(regexLeadingSpaces),
                        currentDescriptor = "",
                        state = "in descriptor"; ; ) {
                            if (c = input.charAt(pos),
                            "in descriptor" === state)
                                if (isSpace(c))
                                    currentDescriptor && (descriptors.push(currentDescriptor),
                                    currentDescriptor = "",
                                    state = "after descriptor");
                                else {
                                    if ("," === c)
                                        return pos += 1,
                                        currentDescriptor && descriptors.push(currentDescriptor),
                                        void parseDescriptors();
                                    if ("(" === c)
                                        currentDescriptor += c,
                                        state = "in parens";
                                    else {
                                        if ("" === c)
                                            return currentDescriptor && descriptors.push(currentDescriptor),
                                            void parseDescriptors();
                                        currentDescriptor += c
                                    }
                                }
                            else if ("in parens" === state)
                                if (")" === c)
                                    currentDescriptor += c,
                                    state = "in descriptor";
                                else {
                                    if ("" === c)
                                        return descriptors.push(currentDescriptor),
                                        void parseDescriptors();
                                    currentDescriptor += c
                                }
                            else if ("after descriptor" === state)
                                if (isSpace(c))
                                    ;
                                else {
                                    if ("" === c)
                                        return void parseDescriptors();
                                    state = "in descriptor",
                                    pos -= 1
                                }
                            pos += 1
                        }
                    }()
                }
            }
            function parseSizes(strValue) {
                var i, unparsedSizesList, unparsedSizesListLength, unparsedSize, lastComponentValue, size, regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i, regexCssCalc = /^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;
                for (unparsedSizesListLength = (unparsedSizesList = function(str) {
                    function pushComponent() {
                        component && (componentArray.push(component),
                        component = "")
                    }
                    function pushComponentArray() {
                        componentArray[0] && (listArray.push(componentArray),
                        componentArray = [])
                    }
                    for (var chrctr, component = "", componentArray = [], listArray = [], parenDepth = 0, pos = 0, inComment = !1; ; ) {
                        if ("" === (chrctr = str.charAt(pos)))
                            return pushComponent(),
                            pushComponentArray(),
                            listArray;
                        if (inComment) {
                            if ("*" === chrctr && "/" === str[pos + 1]) {
                                inComment = !1,
                                pos += 2,
                                pushComponent();
                                continue
                            }
                            pos += 1
                        } else {
                            if (isSpace(chrctr)) {
                                if (str.charAt(pos - 1) && isSpace(str.charAt(pos - 1)) || !component) {
                                    pos += 1;
                                    continue
                                }
                                if (0 === parenDepth) {
                                    pushComponent(),
                                    pos += 1;
                                    continue
                                }
                                chrctr = " "
                            } else if ("(" === chrctr)
                                parenDepth += 1;
                            else if (")" === chrctr)
                                parenDepth -= 1;
                            else {
                                if ("," === chrctr) {
                                    pushComponent(),
                                    pushComponentArray(),
                                    pos += 1;
                                    continue
                                }
                                if ("/" === chrctr && "*" === str.charAt(pos + 1)) {
                                    inComment = !0,
                                    pos += 2;
                                    continue
                                }
                            }
                            component += chrctr,
                            pos += 1
                        }
                    }
                }(strValue)).length,
                i = 0; i < unparsedSizesListLength; i++)
                    if (unparsedSize = unparsedSizesList[i],
                    lastComponentValue = unparsedSize[unparsedSize.length - 1],
                    function(s) {
                        return !!(regexCssLengthWithUnits.test(s) && parseFloat(s) >= 0) || !!regexCssCalc.test(s) || "0" === s || "-0" === s || "+0" === s
                    }(lastComponentValue)) {
                        if (size = lastComponentValue,
                        unparsedSize.pop(),
                        0 === unparsedSize.length)
                            return size;
                        if (unparsedSize = unparsedSize.join(" "),
                        pf.matchesMedia(unparsedSize))
                            return size
                    }
                return "100vw"
            }
            document.createElement("picture");
            var eminpx, alwaysCheckWDescriptor, evalId, pf = {}, isSupportTestReady = !1, noop = function() {}, image = document.createElement("img"), getImgAttr = image.getAttribute, setImgAttr = image.setAttribute, removeImgAttr = image.removeAttribute, docElem = document.documentElement, types = {}, cfg = {
                algorithm: ""
            }, ua = navigator.userAgent, supportAbort = /rident/.test(ua) || /ecko/.test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 > 35, curSrcProp = "currentSrc", regWDesc = /\s+\+?\d+(e\d+)?w/, regSize = /(\([^)]+\))?\s*(.+)/, setOptions = window.picturefillCFG, fsCss = "font-size:100%!important;", isVwDirty = !0, cssCache = {}, sizeLengthCache = {}, DPR = window.devicePixelRatio, units = {
                px: 1,
                in: 96
            }, anchor = document.createElement("a"), alreadyRun = !1, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, on = function(obj, evt, fn, capture) {
                obj.addEventListener ? obj.addEventListener(evt, fn, capture || !1) : obj.attachEvent && obj.attachEvent("on" + evt, fn)
            }, memoize = function(fn) {
                var cache = {};
                return function(input) {
                    return input in cache || (cache[input] = fn(input)),
                    cache[input]
                }
            }, evalCSS = function() {
                var regLength = /^([\d\.]+)(em|vw|px)$/
                  , replace = function() {
                    for (var args = arguments, index = 0, string = args[0]; ++index in args; )
                        string = string.replace(args[index], args[++index]);
                    return string
                }
                  , buildStr = memoize(function(css) {
                    return "return " + replace((css || "").toLowerCase(), /\band\b/g, "&&", /,/g, "||", /min-([a-z-\s]+):/g, "e.$1>=", /max-([a-z-\s]+):/g, "e.$1<=", /calc([^)]+)/g, "($1)", /(\d+[\.]*[\d]*)([a-z]+)/g, "($1 * e.$2)", /^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/gi, "") + ";"
                });
                return function(css, length) {
                    var parsedLength;
                    if (!(css in cssCache))
                        if (cssCache[css] = !1,
                        length && (parsedLength = css.match(regLength)))
                            cssCache[css] = parsedLength[1] * units[parsedLength[2]];
                        else
                            try {
                                cssCache[css] = new Function("e",buildStr(css))(units)
                            } catch (e) {}
                    return cssCache[css]
                }
            }(), setResolution = function(candidate, sizesattr) {
                return candidate.w ? (candidate.cWidth = pf.calcListLength(sizesattr || "100vw"),
                candidate.res = candidate.w / candidate.cWidth) : candidate.res = candidate.d,
                candidate
            }, picturefill = function(opt) {
                if (isSupportTestReady) {
                    var elements, i, plen, options = opt || {};
                    if (options.elements && 1 === options.elements.nodeType && ("IMG" === options.elements.nodeName.toUpperCase() ? options.elements = [options.elements] : (options.context = options.elements,
                    options.elements = null)),
                    elements = options.elements || pf.qsa(options.context || document, options.reevaluate || options.reselect ? pf.sel : pf.selShort),
                    plen = elements.length) {
                        for (pf.setupRun(options),
                        alreadyRun = !0,
                        i = 0; i < plen; i++)
                            pf.fillImg(elements[i], options);
                        pf.teardownRun(options)
                    }
                }
            };
            window.console && console.warn,
            curSrcProp in image || (curSrcProp = "src"),
            types["image/jpeg"] = !0,
            types["image/gif"] = !0,
            types["image/png"] = !0,
            types["image/svg+xml"] = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1"),
            pf.ns = ("pf" + (new Date).getTime()).substr(0, 9),
            pf.supSrcset = "srcset"in image,
            pf.supSizes = "sizes"in image,
            pf.supPicture = !!window.HTMLPictureElement,
            pf.supSrcset && pf.supPicture && !pf.supSizes && function(image2) {
                image.srcset = "data:,a",
                image2.src = "data:,a",
                pf.supSrcset = image.complete === image2.complete,
                pf.supPicture = pf.supSrcset && pf.supPicture
            }(document.createElement("img")),
            pf.supSrcset && !pf.supSizes ? function() {
                var width1 = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                  , img = document.createElement("img")
                  , test = function() {
                    2 === img.width && (pf.supSizes = !0),
                    alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes,
                    isSupportTestReady = !0,
                    setTimeout(picturefill)
                };
                img.onload = test,
                img.onerror = test,
                img.setAttribute("sizes", "9px"),
                img.srcset = width1 + " 1w,data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw== 9w",
                img.src = width1
            }() : isSupportTestReady = !0,
            pf.selShort = "picture>img,img[srcset]",
            pf.sel = pf.selShort,
            pf.cfg = cfg,
            pf.DPR = DPR || 1,
            pf.u = units,
            pf.types = types,
            pf.setSize = noop,
            pf.makeUrl = memoize(function(src) {
                return anchor.href = src,
                anchor.href
            }),
            pf.qsa = function(context, sel) {
                return "querySelector"in context ? context.querySelectorAll(sel) : []
            }
            ,
            pf.matchesMedia = function() {
                return window.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches ? pf.matchesMedia = function(media) {
                    return !media || matchMedia(media).matches
                }
                : pf.matchesMedia = pf.mMQ,
                pf.matchesMedia.apply(this, arguments)
            }
            ,
            pf.mMQ = function(media) {
                return !media || evalCSS(media)
            }
            ,
            pf.calcLength = function(sourceSizeValue) {
                var value = evalCSS(sourceSizeValue, !0) || !1;
                return value < 0 && (value = !1),
                value
            }
            ,
            pf.supportsType = function(type) {
                return !type || types[type]
            }
            ,
            pf.parseSize = memoize(function(sourceSizeStr) {
                var match = (sourceSizeStr || "").match(regSize);
                return {
                    media: match && match[1],
                    length: match && match[2]
                }
            }),
            pf.parseSet = function(set) {
                return set.cands || (set.cands = parseSrcset(set.srcset, set)),
                set.cands
            }
            ,
            pf.getEmValue = function() {
                var body;
                if (!eminpx && (body = document.body)) {
                    var div = document.createElement("div")
                      , originalHTMLCSS = docElem.style.cssText
                      , originalBodyCSS = body.style.cssText;
                    div.style.cssText = "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)",
                    docElem.style.cssText = fsCss,
                    body.style.cssText = fsCss,
                    body.appendChild(div),
                    eminpx = div.offsetWidth,
                    body.removeChild(div),
                    eminpx = parseFloat(eminpx, 10),
                    docElem.style.cssText = originalHTMLCSS,
                    body.style.cssText = originalBodyCSS
                }
                return eminpx || 16
            }
            ,
            pf.calcListLength = function(sourceSizeListStr) {
                if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {
                    var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));
                    sizeLengthCache[sourceSizeListStr] = winningLength || units.width
                }
                return sizeLengthCache[sourceSizeListStr]
            }
            ,
            pf.setRes = function(set) {
                var candidates;
                if (set)
                    for (var i = 0, len = (candidates = pf.parseSet(set)).length; i < len; i++)
                        setResolution(candidates[i], set.sizes);
                return candidates
            }
            ,
            pf.setRes.res = setResolution,
            pf.applySetCandidate = function(candidates, img) {
                if (candidates.length) {
                    var candidate, i, j, length, bestCandidate, curSrc, curCan, candidateSrc, abortCurSrc, imageData = img[pf.ns], dpr = pf.DPR;
                    if (curSrc = imageData.curSrc || img[curSrcProp],
                    (curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set)) && curCan.set === candidates[0].set && ((abortCurSrc = supportAbort && !img.complete && curCan.res - .1 > dpr) || (curCan.cached = !0,
                    curCan.res >= dpr && (bestCandidate = curCan))),
                    !bestCandidate)
                        for (candidates.sort(ascendingSort),
                        bestCandidate = candidates[(length = candidates.length) - 1],
                        i = 0; i < length; i++)
                            if ((candidate = candidates[i]).res >= dpr) {
                                bestCandidate = candidates[j = i - 1] && (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) && chooseLowRes(candidates[j].res, candidate.res, dpr, candidates[j].cached) ? candidates[j] : candidate;
                                break
                            }
                    bestCandidate && (candidateSrc = pf.makeUrl(bestCandidate.url),
                    imageData.curSrc = candidateSrc,
                    imageData.curCan = bestCandidate,
                    candidateSrc !== curSrc && pf.setSrc(img, bestCandidate),
                    pf.setSize(img))
                }
            }
            ,
            pf.setSrc = function(img, bestCandidate) {
                var origWidth;
                img.src = bestCandidate.url,
                "image/svg+xml" === bestCandidate.set.type && (origWidth = img.style.width,
                img.style.width = img.offsetWidth + 1 + "px",
                img.offsetWidth + 1 && (img.style.width = origWidth))
            }
            ,
            pf.getSet = function(img) {
                var i, set, supportsType, match = !1, sets = img[pf.ns].sets;
                for (i = 0; i < sets.length && !match; i++)
                    if ((set = sets[i]).srcset && pf.matchesMedia(set.media) && (supportsType = pf.supportsType(set.type))) {
                        "pending" === supportsType && (set = supportsType),
                        match = set;
                        break
                    }
                return match
            }
            ,
            pf.parseSets = function(element, parent, options) {
                var srcsetAttribute, imageSet, isWDescripor, srcsetParsed, hasPicture = parent && "PICTURE" === parent.nodeName.toUpperCase(), imageData = element[pf.ns];
                (void 0 === imageData.src || options.src) && (imageData.src = getImgAttr.call(element, "src"),
                imageData.src ? setImgAttr.call(element, "data-pfsrc", imageData.src) : removeImgAttr.call(element, "data-pfsrc")),
                (void 0 === imageData.srcset || options.srcset || !pf.supSrcset || element.srcset) && (srcsetAttribute = getImgAttr.call(element, "srcset"),
                imageData.srcset = srcsetAttribute,
                srcsetParsed = !0),
                imageData.sets = [],
                hasPicture && (imageData.pic = !0,
                getAllSourceElements(parent, imageData.sets)),
                imageData.srcset ? (imageSet = {
                    srcset: imageData.srcset,
                    sizes: getImgAttr.call(element, "sizes")
                },
                imageData.sets.push(imageSet),
                (isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || "")) || !imageData.src || getCandidateForSrc(imageData.src, imageSet) || imageSet.has1x || (imageSet.srcset += ", " + imageData.src,
                imageSet.cands.push({
                    url: imageData.src,
                    d: 1,
                    set: imageSet
                }))) : imageData.src && imageData.sets.push({
                    srcset: imageData.src,
                    sizes: null
                }),
                imageData.curCan = null,
                imageData.curSrc = void 0,
                imageData.supported = !(hasPicture || imageSet && !pf.supSrcset || isWDescripor && !pf.supSizes),
                srcsetParsed && pf.supSrcset && !imageData.supported && (srcsetAttribute ? (setImgAttr.call(element, "data-pfsrcset", srcsetAttribute),
                element.srcset = "") : removeImgAttr.call(element, "data-pfsrcset")),
                imageData.supported && !imageData.srcset && (!imageData.src && element.src || element.src !== pf.makeUrl(imageData.src)) && (null === imageData.src ? element.removeAttribute("src") : element.src = imageData.src),
                imageData.parsed = !0
            }
            ,
            pf.fillImg = function(element, options) {
                var imageData, extreme = options.reselect || options.reevaluate;
                element[pf.ns] || (element[pf.ns] = {}),
                imageData = element[pf.ns],
                (extreme || imageData.evaled !== evalId) && (imageData.parsed && !options.reevaluate || pf.parseSets(element, element.parentNode, options),
                imageData.supported ? imageData.evaled = evalId : applyBestCandidate(element))
            }
            ,
            pf.setupRun = function() {
                alreadyRun && !isVwDirty && DPR === window.devicePixelRatio || updateMetrics()
            }
            ,
            pf.supPicture ? (picturefill = noop,
            pf.fillImg = noop) : function() {
                var isDomReady, regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/, run = function() {
                    var readyState = document.readyState || "";
                    timerId = setTimeout(run, "loading" === readyState ? 200 : 999),
                    document.body && (pf.fillImgs(),
                    (isDomReady = isDomReady || regReady.test(readyState)) && clearTimeout(timerId))
                }, timerId = setTimeout(run, document.body ? 9 : 99), lastClientWidth = docElem.clientHeight;
                on(window, "resize", function(func, wait) {
                    var timeout, timestamp, later = function() {
                        var last = new Date - timestamp;
                        last < wait ? timeout = setTimeout(later, wait - last) : (timeout = null,
                        func())
                    };
                    return function() {
                        timestamp = new Date,
                        timeout || (timeout = setTimeout(later, wait))
                    }
                }(function() {
                    isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth,
                    lastClientWidth = docElem.clientHeight,
                    isVwDirty && pf.fillImgs()
                }, 99)),
                on(document, "readystatechange", run)
            }(),
            pf.picturefill = picturefill,
            pf.fillImgs = picturefill,
            pf.teardownRun = noop,
            picturefill._ = pf,
            window.picturefillCFG = {
                pf: pf,
                push: function(args) {
                    var name = args.shift();
                    "function" == typeof pf[name] ? pf[name].apply(pf, args) : (cfg[name] = args[0],
                    alreadyRun && pf.fillImgs({
                        reselect: !0
                    }))
                }
            };
            for (; setOptions && setOptions.length; )
                window.picturefillCFG.push(setOptions.shift());
            window.picturefill = picturefill,
            "object" == typeof module && "object" == typeof module.exports ? module.exports = picturefill : "function" == typeof define && define.amd && define("picturefill", function() {
                return picturefill
            }),
            pf.supPicture || (types["image/webp"] = function(type, typeUri) {
                var image = new window.Image;
                return image.onerror = function() {
                    types[type] = !1,
                    picturefill()
                }
                ,
                image.onload = function() {
                    types[type] = 1 === image.width,
                    picturefill()
                }
                ,
                image.src = typeUri,
                "pending"
            }("image/webp", "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA=="))
        }(window, document)
    }
    , {}],
    20: [function(require, module, exports) {
        !function(factory) {
            "use strict";
            "function" == typeof define && define.amd ? define(["jquery"], factory) : void 0 !== exports ? module.exports = factory(require("jquery")) : factory(jQuery)
        }(function($) {
            "use strict";
            var Slick = window.Slick || {};
            (Slick = function() {
                var instanceUid = 0;
                return function(element, settings) {
                    var dataSettings, _ = this;
                    _.defaults = {
                        accessibility: !0,
                        adaptiveHeight: !1,
                        appendArrows: $(element),
                        appendDots: $(element),
                        arrows: !0,
                        asNavFor: null,
                        prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
                        nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
                        autoplay: !1,
                        autoplaySpeed: 3e3,
                        centerMode: !1,
                        centerPadding: "50px",
                        cssEase: "ease",
                        customPaging: function(slider, i) {
                            return $('<button type="button" />').text(i + 1)
                        },
                        dots: !1,
                        dotsClass: "slick-dots",
                        draggable: !0,
                        easing: "linear",
                        edgeFriction: .35,
                        fade: !1,
                        focusOnSelect: !1,
                        focusOnChange: !1,
                        infinite: !0,
                        initialSlide: 0,
                        lazyLoad: "ondemand",
                        mobileFirst: !1,
                        pauseOnHover: !0,
                        pauseOnFocus: !0,
                        pauseOnDotsHover: !1,
                        respondTo: "window",
                        responsive: null,
                        rows: 1,
                        rtl: !1,
                        slide: "",
                        slidesPerRow: 1,
                        slidesToShow: 1,
                        slidesToScroll: 1,
                        speed: 500,
                        swipe: !0,
                        swipeToSlide: !1,
                        touchMove: !0,
                        touchThreshold: 5,
                        useCSS: !0,
                        useTransform: !0,
                        variableWidth: !1,
                        vertical: !1,
                        verticalSwiping: !1,
                        waitForAnimate: !0,
                        zIndex: 1e3
                    },
                    _.initials = {
                        animating: !1,
                        dragging: !1,
                        autoPlayTimer: null,
                        currentDirection: 0,
                        currentLeft: null,
                        currentSlide: 0,
                        direction: 1,
                        $dots: null,
                        listWidth: null,
                        listHeight: null,
                        loadIndex: 0,
                        $nextArrow: null,
                        $prevArrow: null,
                        scrolling: !1,
                        slideCount: null,
                        slideWidth: null,
                        $slideTrack: null,
                        $slides: null,
                        sliding: !1,
                        slideOffset: 0,
                        swipeLeft: null,
                        swiping: !1,
                        $list: null,
                        touchObject: {},
                        transformsEnabled: !1,
                        unslicked: !1
                    },
                    $.extend(_, _.initials),
                    _.activeBreakpoint = null,
                    _.animType = null,
                    _.animProp = null,
                    _.breakpoints = [],
                    _.breakpointSettings = [],
                    _.cssTransitions = !1,
                    _.focussed = !1,
                    _.interrupted = !1,
                    _.hidden = "hidden",
                    _.paused = !0,
                    _.positionProp = null,
                    _.respondTo = null,
                    _.rowCount = 1,
                    _.shouldClick = !0,
                    _.$slider = $(element),
                    _.$slidesCache = null,
                    _.transformType = null,
                    _.transitionType = null,
                    _.visibilityChange = "visibilitychange",
                    _.windowWidth = 0,
                    _.windowTimer = null,
                    dataSettings = $(element).data("slick") || {},
                    _.options = $.extend({}, _.defaults, settings, dataSettings),
                    _.currentSlide = _.options.initialSlide,
                    _.originalSettings = _.options,
                    void 0 !== document.mozHidden ? (_.hidden = "mozHidden",
                    _.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (_.hidden = "webkitHidden",
                    _.visibilityChange = "webkitvisibilitychange"),
                    _.autoPlay = $.proxy(_.autoPlay, _),
                    _.autoPlayClear = $.proxy(_.autoPlayClear, _),
                    _.autoPlayIterator = $.proxy(_.autoPlayIterator, _),
                    _.changeSlide = $.proxy(_.changeSlide, _),
                    _.clickHandler = $.proxy(_.clickHandler, _),
                    _.selectHandler = $.proxy(_.selectHandler, _),
                    _.setPosition = $.proxy(_.setPosition, _),
                    _.swipeHandler = $.proxy(_.swipeHandler, _),
                    _.dragHandler = $.proxy(_.dragHandler, _),
                    _.keyHandler = $.proxy(_.keyHandler, _),
                    _.instanceUid = instanceUid++,
                    _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/,
                    _.registerBreakpoints(),
                    _.init(!0)
                }
            }()).prototype.activateADA = function() {
                this.$slideTrack.find(".slick-active").attr({
                    "aria-hidden": "false"
                }).find("a, input, button, select").attr({
                    tabindex: "0"
                })
            }
            ,
            Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {
                var _ = this;
                if ("boolean" == typeof index)
                    addBefore = index,
                    index = null;
                else if (index < 0 || index >= _.slideCount)
                    return !1;
                _.unload(),
                "number" == typeof index ? 0 === index && 0 === _.$slides.length ? $(markup).appendTo(_.$slideTrack) : addBefore ? $(markup).insertBefore(_.$slides.eq(index)) : $(markup).insertAfter(_.$slides.eq(index)) : !0 === addBefore ? $(markup).prependTo(_.$slideTrack) : $(markup).appendTo(_.$slideTrack),
                _.$slides = _.$slideTrack.children(this.options.slide),
                _.$slideTrack.children(this.options.slide).detach(),
                _.$slideTrack.append(_.$slides),
                _.$slides.each(function(index, element) {
                    $(element).attr("data-slick-index", index)
                }),
                _.$slidesCache = _.$slides,
                _.reinit()
            }
            ,
            Slick.prototype.animateHeight = function() {
                var _ = this;
                if (1 === _.options.slidesToShow && !0 === _.options.adaptiveHeight && !1 === _.options.vertical) {
                    var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
                    _.$list.animate({
                        height: targetHeight
                    }, _.options.speed)
                }
            }
            ,
            Slick.prototype.animateSlide = function(targetLeft, callback) {
                var animProps = {}
                  , _ = this;
                _.animateHeight(),
                !0 === _.options.rtl && !1 === _.options.vertical && (targetLeft = -targetLeft),
                !1 === _.transformsEnabled ? !1 === _.options.vertical ? _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback) : _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback) : !1 === _.cssTransitions ? (!0 === _.options.rtl && (_.currentLeft = -_.currentLeft),
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now),
                        !1 === _.options.vertical ? (animProps[_.animType] = "translate(" + now + "px, 0px)",
                        _.$slideTrack.css(animProps)) : (animProps[_.animType] = "translate(0px," + now + "px)",
                        _.$slideTrack.css(animProps))
                    },
                    complete: function() {
                        callback && callback.call()
                    }
                })) : (_.applyTransition(),
                targetLeft = Math.ceil(targetLeft),
                !1 === _.options.vertical ? animProps[_.animType] = "translate3d(" + targetLeft + "px, 0px, 0px)" : animProps[_.animType] = "translate3d(0px," + targetLeft + "px, 0px)",
                _.$slideTrack.css(animProps),
                callback && setTimeout(function() {
                    _.disableTransition(),
                    callback.call()
                }, _.options.speed))
            }
            ,
            Slick.prototype.getNavTarget = function() {
                var _ = this
                  , asNavFor = _.options.asNavFor;
                return asNavFor && null !== asNavFor && (asNavFor = $(asNavFor).not(_.$slider)),
                asNavFor
            }
            ,
            Slick.prototype.asNavFor = function(index) {
                var asNavFor = this.getNavTarget();
                null !== asNavFor && "object" == typeof asNavFor && asNavFor.each(function() {
                    var target = $(this).slick("getSlick");
                    target.unslicked || target.slideHandler(index, !0)
                })
            }
            ,
            Slick.prototype.applyTransition = function(slide) {
                var _ = this
                  , transition = {};
                !1 === _.options.fade ? transition[_.transitionType] = _.transformType + " " + _.options.speed + "ms " + _.options.cssEase : transition[_.transitionType] = "opacity " + _.options.speed + "ms " + _.options.cssEase,
                !1 === _.options.fade ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition)
            }
            ,
            Slick.prototype.autoPlay = function() {
                var _ = this;
                _.autoPlayClear(),
                _.slideCount > _.options.slidesToShow && (_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed))
            }
            ,
            Slick.prototype.autoPlayClear = function() {
                var _ = this;
                _.autoPlayTimer && clearInterval(_.autoPlayTimer)
            }
            ,
            Slick.prototype.autoPlayIterator = function() {
                var _ = this
                  , slideTo = _.currentSlide + _.options.slidesToScroll;
                _.paused || _.interrupted || _.focussed || (!1 === _.options.infinite && (1 === _.direction && _.currentSlide + 1 === _.slideCount - 1 ? _.direction = 0 : 0 === _.direction && (slideTo = _.currentSlide - _.options.slidesToScroll,
                _.currentSlide - 1 == 0 && (_.direction = 1))),
                _.slideHandler(slideTo))
            }
            ,
            Slick.prototype.buildArrows = function() {
                var _ = this;
                !0 === _.options.arrows && (_.$prevArrow = $(_.options.prevArrow).addClass("slick-arrow"),
                _.$nextArrow = $(_.options.nextArrow).addClass("slick-arrow"),
                _.slideCount > _.options.slidesToShow ? (_.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),
                _.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"),
                _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.prependTo(_.options.appendArrows),
                _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.appendTo(_.options.appendArrows),
                !0 !== _.options.infinite && _.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : _.$prevArrow.add(_.$nextArrow).addClass("slick-hidden").attr({
                    "aria-disabled": "true",
                    tabindex: "-1"
                }))
            }
            ,
            Slick.prototype.buildDots = function() {
                var i, dot, _ = this;
                if (!0 === _.options.dots && _.slideCount > _.options.slidesToShow) {
                    for (_.$slider.addClass("slick-dotted"),
                    dot = $("<ul />").addClass(_.options.dotsClass),
                    i = 0; i <= _.getDotCount(); i += 1)
                        dot.append($("<li />").append(_.options.customPaging.call(this, _, i)));
                    _.$dots = dot.appendTo(_.options.appendDots),
                    _.$dots.find("li").first().addClass("slick-active")
                }
            }
            ,
            Slick.prototype.buildOut = function() {
                var _ = this;
                _.$slides = _.$slider.children(_.options.slide + ":not(.slick-cloned)").addClass("slick-slide"),
                _.slideCount = _.$slides.length,
                _.$slides.each(function(index, element) {
                    $(element).attr("data-slick-index", index).data("originalStyling", $(element).attr("style") || "")
                }),
                _.$slider.addClass("slick-slider"),
                _.$slideTrack = 0 === _.slideCount ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent(),
                _.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent(),
                _.$slideTrack.css("opacity", 0),
                !0 !== _.options.centerMode && !0 !== _.options.swipeToSlide || (_.options.slidesToScroll = 1),
                $("img[data-lazy]", _.$slider).not("[src]").addClass("slick-loading"),
                _.setupInfinite(),
                _.buildArrows(),
                _.buildDots(),
                _.updateDots(),
                _.setSlideClasses("number" == typeof _.currentSlide ? _.currentSlide : 0),
                !0 === _.options.draggable && _.$list.addClass("draggable")
            }
            ,
            Slick.prototype.buildRows = function() {
                var a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection, _ = this;
                if (newSlides = document.createDocumentFragment(),
                originalSlides = _.$slider.children(),
                _.options.rows > 0) {
                    for (slidesPerSection = _.options.slidesPerRow * _.options.rows,
                    numOfSlides = Math.ceil(originalSlides.length / slidesPerSection),
                    a = 0; a < numOfSlides; a++) {
                        var slide = document.createElement("div");
                        for (b = 0; b < _.options.rows; b++) {
                            var row = document.createElement("div");
                            for (c = 0; c < _.options.slidesPerRow; c++) {
                                var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
                                originalSlides.get(target) && row.appendChild(originalSlides.get(target))
                            }
                            slide.appendChild(row)
                        }
                        newSlides.appendChild(slide)
                    }
                    _.$slider.empty().append(newSlides),
                    _.$slider.children().children().children().css({
                        width: 100 / _.options.slidesPerRow + "%",
                        display: "inline-block"
                    })
                }
            }
            ,
            Slick.prototype.checkResponsive = function(initial, forceUpdate) {
                var breakpoint, targetBreakpoint, respondToWidth, _ = this, triggerBreakpoint = !1, sliderWidth = _.$slider.width(), windowWidth = window.innerWidth || $(window).width();
                if ("window" === _.respondTo ? respondToWidth = windowWidth : "slider" === _.respondTo ? respondToWidth = sliderWidth : "min" === _.respondTo && (respondToWidth = Math.min(windowWidth, sliderWidth)),
                _.options.responsive && _.options.responsive.length && null !== _.options.responsive) {
                    targetBreakpoint = null;
                    for (breakpoint in _.breakpoints)
                        _.breakpoints.hasOwnProperty(breakpoint) && (!1 === _.originalSettings.mobileFirst ? respondToWidth < _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]) : respondToWidth > _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]));
                    null !== targetBreakpoint ? null !== _.activeBreakpoint ? (targetBreakpoint !== _.activeBreakpoint || forceUpdate) && (_.activeBreakpoint = targetBreakpoint,
                    "unslick" === _.breakpointSettings[targetBreakpoint] ? _.unslick(targetBreakpoint) : (_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]),
                    !0 === initial && (_.currentSlide = _.options.initialSlide),
                    _.refresh(initial)),
                    triggerBreakpoint = targetBreakpoint) : (_.activeBreakpoint = targetBreakpoint,
                    "unslick" === _.breakpointSettings[targetBreakpoint] ? _.unslick(targetBreakpoint) : (_.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]),
                    !0 === initial && (_.currentSlide = _.options.initialSlide),
                    _.refresh(initial)),
                    triggerBreakpoint = targetBreakpoint) : null !== _.activeBreakpoint && (_.activeBreakpoint = null,
                    _.options = _.originalSettings,
                    !0 === initial && (_.currentSlide = _.options.initialSlide),
                    _.refresh(initial),
                    triggerBreakpoint = targetBreakpoint),
                    initial || !1 === triggerBreakpoint || _.$slider.trigger("breakpoint", [_, triggerBreakpoint])
                }
            }
            ,
            Slick.prototype.changeSlide = function(event, dontAnimate) {
                var indexOffset, slideOffset, unevenOffset, _ = this, $target = $(event.currentTarget);
                switch ($target.is("a") && event.preventDefault(),
                $target.is("li") || ($target = $target.closest("li")),
                unevenOffset = _.slideCount % _.options.slidesToScroll != 0,
                indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll,
                event.data.message) {
                case "previous":
                    slideOffset = 0 === indexOffset ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset,
                    _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide - slideOffset, !1, dontAnimate);
                    break;
                case "next":
                    slideOffset = 0 === indexOffset ? _.options.slidesToScroll : indexOffset,
                    _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide + slideOffset, !1, dontAnimate);
                    break;
                case "index":
                    var index = 0 === event.data.index ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;
                    _.slideHandler(_.checkNavigable(index), !1, dontAnimate),
                    $target.children().trigger("focus");
                    break;
                default:
                    return
                }
            }
            ,
            Slick.prototype.checkNavigable = function(index) {
                var navigables, prevNavigable;
                if (navigables = this.getNavigableIndexes(),
                prevNavigable = 0,
                index > navigables[navigables.length - 1])
                    index = navigables[navigables.length - 1];
                else
                    for (var n in navigables) {
                        if (index < navigables[n]) {
                            index = prevNavigable;
                            break
                        }
                        prevNavigable = navigables[n]
                    }
                return index
            }
            ,
            Slick.prototype.cleanUpEvents = function() {
                var _ = this;
                _.options.dots && null !== _.$dots && ($("li", _.$dots).off("click.slick", _.changeSlide).off("mouseenter.slick", $.proxy(_.interrupt, _, !0)).off("mouseleave.slick", $.proxy(_.interrupt, _, !1)),
                !0 === _.options.accessibility && _.$dots.off("keydown.slick", _.keyHandler)),
                _.$slider.off("focus.slick blur.slick"),
                !0 === _.options.arrows && _.slideCount > _.options.slidesToShow && (_.$prevArrow && _.$prevArrow.off("click.slick", _.changeSlide),
                _.$nextArrow && _.$nextArrow.off("click.slick", _.changeSlide),
                !0 === _.options.accessibility && (_.$prevArrow && _.$prevArrow.off("keydown.slick", _.keyHandler),
                _.$nextArrow && _.$nextArrow.off("keydown.slick", _.keyHandler))),
                _.$list.off("touchstart.slick mousedown.slick", _.swipeHandler),
                _.$list.off("touchmove.slick mousemove.slick", _.swipeHandler),
                _.$list.off("touchend.slick mouseup.slick", _.swipeHandler),
                _.$list.off("touchcancel.slick mouseleave.slick", _.swipeHandler),
                _.$list.off("click.slick", _.clickHandler),
                $(document).off(_.visibilityChange, _.visibility),
                _.cleanUpSlideEvents(),
                !0 === _.options.accessibility && _.$list.off("keydown.slick", _.keyHandler),
                !0 === _.options.focusOnSelect && $(_.$slideTrack).children().off("click.slick", _.selectHandler),
                $(window).off("orientationchange.slick.slick-" + _.instanceUid, _.orientationChange),
                $(window).off("resize.slick.slick-" + _.instanceUid, _.resize),
                $("[draggable!=true]", _.$slideTrack).off("dragstart", _.preventDefault),
                $(window).off("load.slick.slick-" + _.instanceUid, _.setPosition)
            }
            ,
            Slick.prototype.cleanUpSlideEvents = function() {
                var _ = this;
                _.$list.off("mouseenter.slick", $.proxy(_.interrupt, _, !0)),
                _.$list.off("mouseleave.slick", $.proxy(_.interrupt, _, !1))
            }
            ,
            Slick.prototype.cleanUpRows = function() {
                var originalSlides, _ = this;
                _.options.rows > 0 && ((originalSlides = _.$slides.children().children()).removeAttr("style"),
                _.$slider.empty().append(originalSlides))
            }
            ,
            Slick.prototype.clickHandler = function(event) {
                !1 === this.shouldClick && (event.stopImmediatePropagation(),
                event.stopPropagation(),
                event.preventDefault())
            }
            ,
            Slick.prototype.destroy = function(refresh) {
                var _ = this;
                _.autoPlayClear(),
                _.touchObject = {},
                _.cleanUpEvents(),
                $(".slick-cloned", _.$slider).detach(),
                _.$dots && _.$dots.remove(),
                _.$prevArrow && _.$prevArrow.length && (_.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""),
                _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.remove()),
                _.$nextArrow && _.$nextArrow.length && (_.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""),
                _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.remove()),
                _.$slides && (_.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function() {
                    $(this).attr("style", $(this).data("originalStyling"))
                }),
                _.$slideTrack.children(this.options.slide).detach(),
                _.$slideTrack.detach(),
                _.$list.detach(),
                _.$slider.append(_.$slides)),
                _.cleanUpRows(),
                _.$slider.removeClass("slick-slider"),
                _.$slider.removeClass("slick-initialized"),
                _.$slider.removeClass("slick-dotted"),
                _.unslicked = !0,
                refresh || _.$slider.trigger("destroy", [_])
            }
            ,
            Slick.prototype.disableTransition = function(slide) {
                var _ = this
                  , transition = {};
                transition[_.transitionType] = "",
                !1 === _.options.fade ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition)
            }
            ,
            Slick.prototype.fadeSlide = function(slideIndex, callback) {
                var _ = this;
                !1 === _.cssTransitions ? (_.$slides.eq(slideIndex).css({
                    zIndex: _.options.zIndex
                }),
                _.$slides.eq(slideIndex).animate({
                    opacity: 1
                }, _.options.speed, _.options.easing, callback)) : (_.applyTransition(slideIndex),
                _.$slides.eq(slideIndex).css({
                    opacity: 1,
                    zIndex: _.options.zIndex
                }),
                callback && setTimeout(function() {
                    _.disableTransition(slideIndex),
                    callback.call()
                }, _.options.speed))
            }
            ,
            Slick.prototype.fadeSlideOut = function(slideIndex) {
                var _ = this;
                !1 === _.cssTransitions ? _.$slides.eq(slideIndex).animate({
                    opacity: 0,
                    zIndex: _.options.zIndex - 2
                }, _.options.speed, _.options.easing) : (_.applyTransition(slideIndex),
                _.$slides.eq(slideIndex).css({
                    opacity: 0,
                    zIndex: _.options.zIndex - 2
                }))
            }
            ,
            Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {
                var _ = this;
                null !== filter && (_.$slidesCache = _.$slides,
                _.unload(),
                _.$slideTrack.children(this.options.slide).detach(),
                _.$slidesCache.filter(filter).appendTo(_.$slideTrack),
                _.reinit())
            }
            ,
            Slick.prototype.focusHandler = function() {
                var _ = this;
                _.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function(event) {
                    event.stopImmediatePropagation();
                    var $sf = $(this);
                    setTimeout(function() {
                        _.options.pauseOnFocus && (_.focussed = $sf.is(":focus"),
                        _.autoPlay())
                    }, 0)
                })
            }
            ,
            Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {
                return this.currentSlide
            }
            ,
            Slick.prototype.getDotCount = function() {
                var _ = this
                  , breakPoint = 0
                  , counter = 0
                  , pagerQty = 0;
                if (!0 === _.options.infinite)
                    if (_.slideCount <= _.options.slidesToShow)
                        ++pagerQty;
                    else
                        for (; breakPoint < _.slideCount; )
                            ++pagerQty,
                            breakPoint = counter + _.options.slidesToScroll,
                            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                else if (!0 === _.options.centerMode)
                    pagerQty = _.slideCount;
                else if (_.options.asNavFor)
                    for (; breakPoint < _.slideCount; )
                        ++pagerQty,
                        breakPoint = counter + _.options.slidesToScroll,
                        counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                else
                    pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
                return pagerQty - 1
            }
            ,
            Slick.prototype.getLeft = function(slideIndex) {
                var targetLeft, verticalHeight, targetSlide, coef, _ = this, verticalOffset = 0;
                return _.slideOffset = 0,
                verticalHeight = _.$slides.first().outerHeight(!0),
                !0 === _.options.infinite ? (_.slideCount > _.options.slidesToShow && (_.slideOffset = _.slideWidth * _.options.slidesToShow * -1,
                coef = -1,
                !0 === _.options.vertical && !0 === _.options.centerMode && (2 === _.options.slidesToShow ? coef = -1.5 : 1 === _.options.slidesToShow && (coef = -2)),
                verticalOffset = verticalHeight * _.options.slidesToShow * coef),
                _.slideCount % _.options.slidesToScroll != 0 && slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow && (slideIndex > _.slideCount ? (_.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1,
                verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1) : (_.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1,
                verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1))) : slideIndex + _.options.slidesToShow > _.slideCount && (_.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth,
                verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight),
                _.slideCount <= _.options.slidesToShow && (_.slideOffset = 0,
                verticalOffset = 0),
                !0 === _.options.centerMode && _.slideCount <= _.options.slidesToShow ? _.slideOffset = _.slideWidth * Math.floor(_.options.slidesToShow) / 2 - _.slideWidth * _.slideCount / 2 : !0 === _.options.centerMode && !0 === _.options.infinite ? _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth : !0 === _.options.centerMode && (_.slideOffset = 0,
                _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2)),
                targetLeft = !1 === _.options.vertical ? slideIndex * _.slideWidth * -1 + _.slideOffset : slideIndex * verticalHeight * -1 + verticalOffset,
                !0 === _.options.variableWidth && (targetSlide = _.slideCount <= _.options.slidesToShow || !1 === _.options.infinite ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow),
                targetLeft = !0 === _.options.rtl ? targetSlide[0] ? -1 * (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) : 0 : targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0,
                !0 === _.options.centerMode && (targetSlide = _.slideCount <= _.options.slidesToShow || !1 === _.options.infinite ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow + 1),
                targetLeft = !0 === _.options.rtl ? targetSlide[0] ? -1 * (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) : 0 : targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0,
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2)),
                targetLeft
            }
            ,
            Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {
                return this.options[option]
            }
            ,
            Slick.prototype.getNavigableIndexes = function() {
                var max, _ = this, breakPoint = 0, counter = 0, indexes = [];
                for (!1 === _.options.infinite ? max = _.slideCount : (breakPoint = -1 * _.options.slidesToScroll,
                counter = -1 * _.options.slidesToScroll,
                max = 2 * _.slideCount); breakPoint < max; )
                    indexes.push(breakPoint),
                    breakPoint = counter + _.options.slidesToScroll,
                    counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
                return indexes
            }
            ,
            Slick.prototype.getSlick = function() {
                return this
            }
            ,
            Slick.prototype.getSlideCount = function() {
                var swipedSlide, centerOffset, _ = this;
                return centerOffset = !0 === _.options.centerMode ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0,
                !0 === _.options.swipeToSlide ? (_.$slideTrack.find(".slick-slide").each(function(index, slide) {
                    if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > -1 * _.swipeLeft)
                        return swipedSlide = slide,
                        !1
                }),
                Math.abs($(swipedSlide).attr("data-slick-index") - _.currentSlide) || 1) : _.options.slidesToScroll
            }
            ,
            Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {
                this.changeSlide({
                    data: {
                        message: "index",
                        index: parseInt(slide)
                    }
                }, dontAnimate)
            }
            ,
            Slick.prototype.init = function(creation) {
                var _ = this;
                $(_.$slider).hasClass("slick-initialized") || ($(_.$slider).addClass("slick-initialized"),
                _.buildRows(),
                _.buildOut(),
                _.setProps(),
                _.startLoad(),
                _.loadSlider(),
                _.initializeEvents(),
                _.updateArrows(),
                _.updateDots(),
                _.checkResponsive(!0),
                _.focusHandler()),
                creation && _.$slider.trigger("init", [_]),
                !0 === _.options.accessibility && _.initADA(),
                _.options.autoplay && (_.paused = !1,
                _.autoPlay())
            }
            ,
            Slick.prototype.initADA = function() {
                var _ = this
                  , numDotGroups = Math.ceil(_.slideCount / _.options.slidesToShow)
                  , tabControlIndexes = _.getNavigableIndexes().filter(function(val) {
                    return val >= 0 && val < _.slideCount
                });
                _.$slides.add(_.$slideTrack.find(".slick-cloned")).attr({
                    "aria-hidden": "true",
                    tabindex: "-1"
                }).find("a, input, button, select").attr({
                    tabindex: "-1"
                }),
                null !== _.$dots && (_.$slides.not(_.$slideTrack.find(".slick-cloned")).each(function(i) {
                    var slideControlIndex = tabControlIndexes.indexOf(i);
                    if ($(this).attr({
                        role: "tabpanel",
                        id: "slick-slide" + _.instanceUid + i,
                        tabindex: -1
                    }),
                    -1 !== slideControlIndex) {
                        var ariaButtonControl = "slick-slide-control" + _.instanceUid + slideControlIndex;
                        $("#" + ariaButtonControl).length && $(this).attr({
                            "aria-describedby": ariaButtonControl
                        })
                    }
                }),
                _.$dots.attr("role", "tablist").find("li").each(function(i) {
                    var mappedSlideIndex = tabControlIndexes[i];
                    $(this).attr({
                        role: "presentation"
                    }),
                    $(this).find("button").first().attr({
                        role: "tab",
                        id: "slick-slide-control" + _.instanceUid + i,
                        "aria-controls": "slick-slide" + _.instanceUid + mappedSlideIndex,
                        "aria-label": i + 1 + " of " + numDotGroups,
                        "aria-selected": null,
                        tabindex: "-1"
                    })
                }).eq(_.currentSlide).find("button").attr({
                    "aria-selected": "true",
                    tabindex: "0"
                }).end());
                for (var i = _.currentSlide, max = i + _.options.slidesToShow; i < max; i++)
                    _.options.focusOnChange ? _.$slides.eq(i).attr({
                        tabindex: "0"
                    }) : _.$slides.eq(i).removeAttr("tabindex");
                _.activateADA()
            }
            ,
            Slick.prototype.initArrowEvents = function() {
                var _ = this;
                !0 === _.options.arrows && _.slideCount > _.options.slidesToShow && (_.$prevArrow.off("click.slick").on("click.slick", {
                    message: "previous"
                }, _.changeSlide),
                _.$nextArrow.off("click.slick").on("click.slick", {
                    message: "next"
                }, _.changeSlide),
                !0 === _.options.accessibility && (_.$prevArrow.on("keydown.slick", _.keyHandler),
                _.$nextArrow.on("keydown.slick", _.keyHandler)))
            }
            ,
            Slick.prototype.initDotEvents = function() {
                var _ = this;
                !0 === _.options.dots && _.slideCount > _.options.slidesToShow && ($("li", _.$dots).on("click.slick", {
                    message: "index"
                }, _.changeSlide),
                !0 === _.options.accessibility && _.$dots.on("keydown.slick", _.keyHandler)),
                !0 === _.options.dots && !0 === _.options.pauseOnDotsHover && _.slideCount > _.options.slidesToShow && $("li", _.$dots).on("mouseenter.slick", $.proxy(_.interrupt, _, !0)).on("mouseleave.slick", $.proxy(_.interrupt, _, !1))
            }
            ,
            Slick.prototype.initSlideEvents = function() {
                var _ = this;
                _.options.pauseOnHover && (_.$list.on("mouseenter.slick", $.proxy(_.interrupt, _, !0)),
                _.$list.on("mouseleave.slick", $.proxy(_.interrupt, _, !1)))
            }
            ,
            Slick.prototype.initializeEvents = function() {
                var _ = this;
                _.initArrowEvents(),
                _.initDotEvents(),
                _.initSlideEvents(),
                _.$list.on("touchstart.slick mousedown.slick", {
                    action: "start"
                }, _.swipeHandler),
                _.$list.on("touchmove.slick mousemove.slick", {
                    action: "move"
                }, _.swipeHandler),
                _.$list.on("touchend.slick mouseup.slick", {
                    action: "end"
                }, _.swipeHandler),
                _.$list.on("touchcancel.slick mouseleave.slick", {
                    action: "end"
                }, _.swipeHandler),
                _.$list.on("click.slick", _.clickHandler),
                $(document).on(_.visibilityChange, $.proxy(_.visibility, _)),
                !0 === _.options.accessibility && _.$list.on("keydown.slick", _.keyHandler),
                !0 === _.options.focusOnSelect && $(_.$slideTrack).children().on("click.slick", _.selectHandler),
                $(window).on("orientationchange.slick.slick-" + _.instanceUid, $.proxy(_.orientationChange, _)),
                $(window).on("resize.slick.slick-" + _.instanceUid, $.proxy(_.resize, _)),
                $("[draggable!=true]", _.$slideTrack).on("dragstart", _.preventDefault),
                $(window).on("load.slick.slick-" + _.instanceUid, _.setPosition),
                $(_.setPosition)
            }
            ,
            Slick.prototype.initUI = function() {
                var _ = this;
                !0 === _.options.arrows && _.slideCount > _.options.slidesToShow && (_.$prevArrow.show(),
                _.$nextArrow.show()),
                !0 === _.options.dots && _.slideCount > _.options.slidesToShow && _.$dots.show()
            }
            ,
            Slick.prototype.keyHandler = function(event) {
                var _ = this;
                event.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === event.keyCode && !0 === _.options.accessibility ? _.changeSlide({
                    data: {
                        message: !0 === _.options.rtl ? "next" : "previous"
                    }
                }) : 39 === event.keyCode && !0 === _.options.accessibility && _.changeSlide({
                    data: {
                        message: !0 === _.options.rtl ? "previous" : "next"
                    }
                }))
            }
            ,
            Slick.prototype.lazyLoad = function() {
                function loadImages(imagesScope) {
                    $("img[data-lazy]", imagesScope).each(function() {
                        var image = $(this)
                          , imageSource = $(this).attr("data-lazy")
                          , imageSrcSet = $(this).attr("data-srcset")
                          , imageSizes = $(this).attr("data-sizes") || _.$slider.attr("data-sizes")
                          , imageToLoad = document.createElement("img");
                        imageToLoad.onload = function() {
                            image.animate({
                                opacity: 0
                            }, 100, function() {
                                imageSrcSet && (image.attr("srcset", imageSrcSet),
                                imageSizes && image.attr("sizes", imageSizes)),
                                image.attr("src", imageSource).animate({
                                    opacity: 1
                                }, 200, function() {
                                    image.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading")
                                }),
                                _.$slider.trigger("lazyLoaded", [_, image, imageSource])
                            })
                        }
                        ,
                        imageToLoad.onerror = function() {
                            image.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),
                            _.$slider.trigger("lazyLoadError", [_, image, imageSource])
                        }
                        ,
                        imageToLoad.src = imageSource
                    })
                }
                var loadRange, rangeStart, rangeEnd, _ = this;
                if (!0 === _.options.centerMode ? !0 === _.options.infinite ? rangeEnd = (rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1)) + _.options.slidesToShow + 2 : (rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1)),
                rangeEnd = _.options.slidesToShow / 2 + 1 + 2 + _.currentSlide) : (rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide,
                rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow),
                !0 === _.options.fade && (rangeStart > 0 && rangeStart--,
                rangeEnd <= _.slideCount && rangeEnd++)),
                loadRange = _.$slider.find(".slick-slide").slice(rangeStart, rangeEnd),
                "anticipated" === _.options.lazyLoad)
                    for (var prevSlide = rangeStart - 1, nextSlide = rangeEnd, $slides = _.$slider.find(".slick-slide"), i = 0; i < _.options.slidesToScroll; i++)
                        prevSlide < 0 && (prevSlide = _.slideCount - 1),
                        loadRange = (loadRange = loadRange.add($slides.eq(prevSlide))).add($slides.eq(nextSlide)),
                        prevSlide--,
                        nextSlide++;
                loadImages(loadRange),
                _.slideCount <= _.options.slidesToShow ? loadImages(_.$slider.find(".slick-slide")) : _.currentSlide >= _.slideCount - _.options.slidesToShow ? loadImages(_.$slider.find(".slick-cloned").slice(0, _.options.slidesToShow)) : 0 === _.currentSlide && loadImages(_.$slider.find(".slick-cloned").slice(-1 * _.options.slidesToShow))
            }
            ,
            Slick.prototype.loadSlider = function() {
                var _ = this;
                _.setPosition(),
                _.$slideTrack.css({
                    opacity: 1
                }),
                _.$slider.removeClass("slick-loading"),
                _.initUI(),
                "progressive" === _.options.lazyLoad && _.progressiveLazyLoad()
            }
            ,
            Slick.prototype.next = Slick.prototype.slickNext = function() {
                this.changeSlide({
                    data: {
                        message: "next"
                    }
                })
            }
            ,
            Slick.prototype.orientationChange = function() {
                var _ = this;
                _.checkResponsive(),
                _.setPosition()
            }
            ,
            Slick.prototype.pause = Slick.prototype.slickPause = function() {
                var _ = this;
                _.autoPlayClear(),
                _.paused = !0
            }
            ,
            Slick.prototype.play = Slick.prototype.slickPlay = function() {
                var _ = this;
                _.autoPlay(),
                _.options.autoplay = !0,
                _.paused = !1,
                _.focussed = !1,
                _.interrupted = !1
            }
            ,
            Slick.prototype.postSlide = function(index) {
                var _ = this;
                _.unslicked || (_.$slider.trigger("afterChange", [_, index]),
                _.animating = !1,
                _.slideCount > _.options.slidesToShow && _.setPosition(),
                _.swipeLeft = null,
                _.options.autoplay && _.autoPlay(),
                !0 === _.options.accessibility && (_.initADA(),
                _.options.focusOnChange && $(_.$slides.get(_.currentSlide)).attr("tabindex", 0).focus()))
            }
            ,
            Slick.prototype.prev = Slick.prototype.slickPrev = function() {
                this.changeSlide({
                    data: {
                        message: "previous"
                    }
                })
            }
            ,
            Slick.prototype.preventDefault = function(event) {
                event.preventDefault()
            }
            ,
            Slick.prototype.progressiveLazyLoad = function(tryCount) {
                tryCount = tryCount || 1;
                var image, imageSource, imageSrcSet, imageSizes, imageToLoad, _ = this, $imgsToLoad = $("img[data-lazy]", _.$slider);
                $imgsToLoad.length ? (image = $imgsToLoad.first(),
                imageSource = image.attr("data-lazy"),
                imageSrcSet = image.attr("data-srcset"),
                imageSizes = image.attr("data-sizes") || _.$slider.attr("data-sizes"),
                (imageToLoad = document.createElement("img")).onload = function() {
                    imageSrcSet && (image.attr("srcset", imageSrcSet),
                    imageSizes && image.attr("sizes", imageSizes)),
                    image.attr("src", imageSource).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"),
                    !0 === _.options.adaptiveHeight && _.setPosition(),
                    _.$slider.trigger("lazyLoaded", [_, image, imageSource]),
                    _.progressiveLazyLoad()
                }
                ,
                imageToLoad.onerror = function() {
                    tryCount < 3 ? setTimeout(function() {
                        _.progressiveLazyLoad(tryCount + 1)
                    }, 500) : (image.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"),
                    _.$slider.trigger("lazyLoadError", [_, image, imageSource]),
                    _.progressiveLazyLoad())
                }
                ,
                imageToLoad.src = imageSource) : _.$slider.trigger("allImagesLoaded", [_])
            }
            ,
            Slick.prototype.refresh = function(initializing) {
                var currentSlide, lastVisibleIndex, _ = this;
                lastVisibleIndex = _.slideCount - _.options.slidesToShow,
                !_.options.infinite && _.currentSlide > lastVisibleIndex && (_.currentSlide = lastVisibleIndex),
                _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0),
                currentSlide = _.currentSlide,
                _.destroy(!0),
                $.extend(_, _.initials, {
                    currentSlide: currentSlide
                }),
                _.init(),
                initializing || _.changeSlide({
                    data: {
                        message: "index",
                        index: currentSlide
                    }
                }, !1)
            }
            ,
            Slick.prototype.registerBreakpoints = function() {
                var breakpoint, currentBreakpoint, l, _ = this, responsiveSettings = _.options.responsive || null;
                if ("array" === $.type(responsiveSettings) && responsiveSettings.length) {
                    _.respondTo = _.options.respondTo || "window";
                    for (breakpoint in responsiveSettings)
                        if (l = _.breakpoints.length - 1,
                        responsiveSettings.hasOwnProperty(breakpoint)) {
                            for (currentBreakpoint = responsiveSettings[breakpoint].breakpoint; l >= 0; )
                                _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint && _.breakpoints.splice(l, 1),
                                l--;
                            _.breakpoints.push(currentBreakpoint),
                            _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings
                        }
                    _.breakpoints.sort(function(a, b) {
                        return _.options.mobileFirst ? a - b : b - a
                    })
                }
            }
            ,
            Slick.prototype.reinit = function() {
                var _ = this;
                _.$slides = _.$slideTrack.children(_.options.slide).addClass("slick-slide"),
                _.slideCount = _.$slides.length,
                _.currentSlide >= _.slideCount && 0 !== _.currentSlide && (_.currentSlide = _.currentSlide - _.options.slidesToScroll),
                _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0),
                _.registerBreakpoints(),
                _.setProps(),
                _.setupInfinite(),
                _.buildArrows(),
                _.updateArrows(),
                _.initArrowEvents(),
                _.buildDots(),
                _.updateDots(),
                _.initDotEvents(),
                _.cleanUpSlideEvents(),
                _.initSlideEvents(),
                _.checkResponsive(!1, !0),
                !0 === _.options.focusOnSelect && $(_.$slideTrack).children().on("click.slick", _.selectHandler),
                _.setSlideClasses("number" == typeof _.currentSlide ? _.currentSlide : 0),
                _.setPosition(),
                _.focusHandler(),
                _.paused = !_.options.autoplay,
                _.autoPlay(),
                _.$slider.trigger("reInit", [_])
            }
            ,
            Slick.prototype.resize = function() {
                var _ = this;
                $(window).width() !== _.windowWidth && (clearTimeout(_.windowDelay),
                _.windowDelay = window.setTimeout(function() {
                    _.windowWidth = $(window).width(),
                    _.checkResponsive(),
                    _.unslicked || _.setPosition()
                }, 50))
            }
            ,
            Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {
                var _ = this;
                if (index = "boolean" == typeof index ? !0 === (removeBefore = index) ? 0 : _.slideCount - 1 : !0 === removeBefore ? --index : index,
                _.slideCount < 1 || index < 0 || index > _.slideCount - 1)
                    return !1;
                _.unload(),
                !0 === removeAll ? _.$slideTrack.children().remove() : _.$slideTrack.children(this.options.slide).eq(index).remove(),
                _.$slides = _.$slideTrack.children(this.options.slide),
                _.$slideTrack.children(this.options.slide).detach(),
                _.$slideTrack.append(_.$slides),
                _.$slidesCache = _.$slides,
                _.reinit()
            }
            ,
            Slick.prototype.setCSS = function(position) {
                var x, y, _ = this, positionProps = {};
                !0 === _.options.rtl && (position = -position),
                x = "left" == _.positionProp ? Math.ceil(position) + "px" : "0px",
                y = "top" == _.positionProp ? Math.ceil(position) + "px" : "0px",
                positionProps[_.positionProp] = position,
                !1 === _.transformsEnabled ? _.$slideTrack.css(positionProps) : (positionProps = {},
                !1 === _.cssTransitions ? (positionProps[_.animType] = "translate(" + x + ", " + y + ")",
                _.$slideTrack.css(positionProps)) : (positionProps[_.animType] = "translate3d(" + x + ", " + y + ", 0px)",
                _.$slideTrack.css(positionProps)))
            }
            ,
            Slick.prototype.setDimensions = function() {
                var _ = this;
                !1 === _.options.vertical ? !0 === _.options.centerMode && _.$list.css({
                    padding: "0px " + _.options.centerPadding
                }) : (_.$list.height(_.$slides.first().outerHeight(!0) * _.options.slidesToShow),
                !0 === _.options.centerMode && _.$list.css({
                    padding: _.options.centerPadding + " 0px"
                })),
                _.listWidth = _.$list.width(),
                _.listHeight = _.$list.height(),
                !1 === _.options.vertical && !1 === _.options.variableWidth ? (_.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow),
                _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children(".slick-slide").length))) : !0 === _.options.variableWidth ? _.$slideTrack.width(5e3 * _.slideCount) : (_.slideWidth = Math.ceil(_.listWidth),
                _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(!0) * _.$slideTrack.children(".slick-slide").length)));
                var offset = _.$slides.first().outerWidth(!0) - _.$slides.first().width();
                !1 === _.options.variableWidth && _.$slideTrack.children(".slick-slide").width(_.slideWidth - offset)
            }
            ,
            Slick.prototype.setFade = function() {
                var targetLeft, _ = this;
                _.$slides.each(function(index, element) {
                    targetLeft = _.slideWidth * index * -1,
                    !0 === _.options.rtl ? $(element).css({
                        position: "relative",
                        right: targetLeft,
                        top: 0,
                        zIndex: _.options.zIndex - 2,
                        opacity: 0
                    }) : $(element).css({
                        position: "relative",
                        left: targetLeft,
                        top: 0,
                        zIndex: _.options.zIndex - 2,
                        opacity: 0
                    })
                }),
                _.$slides.eq(_.currentSlide).css({
                    zIndex: _.options.zIndex - 1,
                    opacity: 1
                })
            }
            ,
            Slick.prototype.setHeight = function() {
                var _ = this;
                if (1 === _.options.slidesToShow && !0 === _.options.adaptiveHeight && !1 === _.options.vertical) {
                    var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
                    _.$list.css("height", targetHeight)
                }
            }
            ,
            Slick.prototype.setOption = Slick.prototype.slickSetOption = function() {
                var l, item, option, value, type, _ = this, refresh = !1;
                if ("object" === $.type(arguments[0]) ? (option = arguments[0],
                refresh = arguments[1],
                type = "multiple") : "string" === $.type(arguments[0]) && (option = arguments[0],
                value = arguments[1],
                refresh = arguments[2],
                "responsive" === arguments[0] && "array" === $.type(arguments[1]) ? type = "responsive" : void 0 !== arguments[1] && (type = "single")),
                "single" === type)
                    _.options[option] = value;
                else if ("multiple" === type)
                    $.each(option, function(opt, val) {
                        _.options[opt] = val
                    });
                else if ("responsive" === type)
                    for (item in value)
                        if ("array" !== $.type(_.options.responsive))
                            _.options.responsive = [value[item]];
                        else {
                            for (l = _.options.responsive.length - 1; l >= 0; )
                                _.options.responsive[l].breakpoint === value[item].breakpoint && _.options.responsive.splice(l, 1),
                                l--;
                            _.options.responsive.push(value[item])
                        }
                refresh && (_.unload(),
                _.reinit())
            }
            ,
            Slick.prototype.setPosition = function() {
                var _ = this;
                _.setDimensions(),
                _.setHeight(),
                !1 === _.options.fade ? _.setCSS(_.getLeft(_.currentSlide)) : _.setFade(),
                _.$slider.trigger("setPosition", [_])
            }
            ,
            Slick.prototype.setProps = function() {
                var _ = this
                  , bodyStyle = document.body.style;
                _.positionProp = !0 === _.options.vertical ? "top" : "left",
                "top" === _.positionProp ? _.$slider.addClass("slick-vertical") : _.$slider.removeClass("slick-vertical"),
                void 0 === bodyStyle.WebkitTransition && void 0 === bodyStyle.MozTransition && void 0 === bodyStyle.msTransition || !0 === _.options.useCSS && (_.cssTransitions = !0),
                _.options.fade && ("number" == typeof _.options.zIndex ? _.options.zIndex < 3 && (_.options.zIndex = 3) : _.options.zIndex = _.defaults.zIndex),
                void 0 !== bodyStyle.OTransform && (_.animType = "OTransform",
                _.transformType = "-o-transform",
                _.transitionType = "OTransition",
                void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1)),
                void 0 !== bodyStyle.MozTransform && (_.animType = "MozTransform",
                _.transformType = "-moz-transform",
                _.transitionType = "MozTransition",
                void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.MozPerspective && (_.animType = !1)),
                void 0 !== bodyStyle.webkitTransform && (_.animType = "webkitTransform",
                _.transformType = "-webkit-transform",
                _.transitionType = "webkitTransition",
                void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1)),
                void 0 !== bodyStyle.msTransform && (_.animType = "msTransform",
                _.transformType = "-ms-transform",
                _.transitionType = "msTransition",
                void 0 === bodyStyle.msTransform && (_.animType = !1)),
                void 0 !== bodyStyle.transform && !1 !== _.animType && (_.animType = "transform",
                _.transformType = "transform",
                _.transitionType = "transition"),
                _.transformsEnabled = _.options.useTransform && null !== _.animType && !1 !== _.animType
            }
            ,
            Slick.prototype.setSlideClasses = function(index) {
                var centerOffset, allSlides, indexOffset, remainder, _ = this;
                if (allSlides = _.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"),
                _.$slides.eq(index).addClass("slick-current"),
                !0 === _.options.centerMode) {
                    var evenCoef = _.options.slidesToShow % 2 == 0 ? 1 : 0;
                    centerOffset = Math.floor(_.options.slidesToShow / 2),
                    !0 === _.options.infinite && (index >= centerOffset && index <= _.slideCount - 1 - centerOffset ? _.$slides.slice(index - centerOffset + evenCoef, index + centerOffset + 1).addClass("slick-active").attr("aria-hidden", "false") : (indexOffset = _.options.slidesToShow + index,
                    allSlides.slice(indexOffset - centerOffset + 1 + evenCoef, indexOffset + centerOffset + 2).addClass("slick-active").attr("aria-hidden", "false")),
                    0 === index ? allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass("slick-center") : index === _.slideCount - 1 && allSlides.eq(_.options.slidesToShow).addClass("slick-center")),
                    _.$slides.eq(index).addClass("slick-center")
                } else
                    index >= 0 && index <= _.slideCount - _.options.slidesToShow ? _.$slides.slice(index, index + _.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : allSlides.length <= _.options.slidesToShow ? allSlides.addClass("slick-active").attr("aria-hidden", "false") : (remainder = _.slideCount % _.options.slidesToShow,
                    indexOffset = !0 === _.options.infinite ? _.options.slidesToShow + index : index,
                    _.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow ? allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass("slick-active").attr("aria-hidden", "false") : allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));
                "ondemand" !== _.options.lazyLoad && "anticipated" !== _.options.lazyLoad || _.lazyLoad()
            }
            ,
            Slick.prototype.setupInfinite = function() {
                var i, slideIndex, infiniteCount, _ = this;
                if (!0 === _.options.fade && (_.options.centerMode = !1),
                !0 === _.options.infinite && !1 === _.options.fade && (slideIndex = null,
                _.slideCount > _.options.slidesToShow)) {
                    for (infiniteCount = !0 === _.options.centerMode ? _.options.slidesToShow + 1 : _.options.slidesToShow,
                    i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1)
                        slideIndex = i - 1,
                        $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("data-slick-index", slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass("slick-cloned");
                    for (i = 0; i < infiniteCount + _.slideCount; i += 1)
                        slideIndex = i,
                        $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("data-slick-index", slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass("slick-cloned");
                    _.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                        $(this).attr("id", "")
                    })
                }
            }
            ,
            Slick.prototype.interrupt = function(toggle) {
                var _ = this;
                toggle || _.autoPlay(),
                _.interrupted = toggle
            }
            ,
            Slick.prototype.selectHandler = function(event) {
                var _ = this
                  , targetElement = $(event.target).is(".slick-slide") ? $(event.target) : $(event.target).parents(".slick-slide")
                  , index = parseInt(targetElement.attr("data-slick-index"));
                index || (index = 0),
                _.slideCount <= _.options.slidesToShow ? _.slideHandler(index, !1, !0) : _.slideHandler(index)
            }
            ,
            Slick.prototype.slideHandler = function(index, sync, dontAnimate) {
                var targetSlide, animSlide, oldSlide, slideLeft, navTarget, targetLeft = null, _ = this;
                if (sync = sync || !1,
                !(!0 === _.animating && !0 === _.options.waitForAnimate || !0 === _.options.fade && _.currentSlide === index))
                    if (!1 === sync && _.asNavFor(index),
                    targetSlide = index,
                    targetLeft = _.getLeft(targetSlide),
                    slideLeft = _.getLeft(_.currentSlide),
                    _.currentLeft = null === _.swipeLeft ? slideLeft : _.swipeLeft,
                    !1 === _.options.infinite && !1 === _.options.centerMode && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll))
                        !1 === _.options.fade && (targetSlide = _.currentSlide,
                        !0 !== dontAnimate && _.slideCount > _.options.slidesToShow ? _.animateSlide(slideLeft, function() {
                            _.postSlide(targetSlide)
                        }) : _.postSlide(targetSlide));
                    else if (!1 === _.options.infinite && !0 === _.options.centerMode && (index < 0 || index > _.slideCount - _.options.slidesToScroll))
                        !1 === _.options.fade && (targetSlide = _.currentSlide,
                        !0 !== dontAnimate && _.slideCount > _.options.slidesToShow ? _.animateSlide(slideLeft, function() {
                            _.postSlide(targetSlide)
                        }) : _.postSlide(targetSlide));
                    else {
                        if (_.options.autoplay && clearInterval(_.autoPlayTimer),
                        animSlide = targetSlide < 0 ? _.slideCount % _.options.slidesToScroll != 0 ? _.slideCount - _.slideCount % _.options.slidesToScroll : _.slideCount + targetSlide : targetSlide >= _.slideCount ? _.slideCount % _.options.slidesToScroll != 0 ? 0 : targetSlide - _.slideCount : targetSlide,
                        _.animating = !0,
                        _.$slider.trigger("beforeChange", [_, _.currentSlide, animSlide]),
                        oldSlide = _.currentSlide,
                        _.currentSlide = animSlide,
                        _.setSlideClasses(_.currentSlide),
                        _.options.asNavFor && (navTarget = (navTarget = _.getNavTarget()).slick("getSlick")).slideCount <= navTarget.options.slidesToShow && navTarget.setSlideClasses(_.currentSlide),
                        _.updateDots(),
                        _.updateArrows(),
                        !0 === _.options.fade)
                            return !0 !== dontAnimate ? (_.fadeSlideOut(oldSlide),
                            _.fadeSlide(animSlide, function() {
                                _.postSlide(animSlide)
                            })) : _.postSlide(animSlide),
                            void _.animateHeight();
                        !0 !== dontAnimate && _.slideCount > _.options.slidesToShow ? _.animateSlide(targetLeft, function() {
                            _.postSlide(animSlide)
                        }) : _.postSlide(animSlide)
                    }
            }
            ,
            Slick.prototype.startLoad = function() {
                var _ = this;
                !0 === _.options.arrows && _.slideCount > _.options.slidesToShow && (_.$prevArrow.hide(),
                _.$nextArrow.hide()),
                !0 === _.options.dots && _.slideCount > _.options.slidesToShow && _.$dots.hide(),
                _.$slider.addClass("slick-loading")
            }
            ,
            Slick.prototype.swipeDirection = function() {
                var xDist, yDist, r, swipeAngle, _ = this;
                return xDist = _.touchObject.startX - _.touchObject.curX,
                yDist = _.touchObject.startY - _.touchObject.curY,
                r = Math.atan2(yDist, xDist),
                (swipeAngle = Math.round(180 * r / Math.PI)) < 0 && (swipeAngle = 360 - Math.abs(swipeAngle)),
                swipeAngle <= 45 && swipeAngle >= 0 ? !1 === _.options.rtl ? "left" : "right" : swipeAngle <= 360 && swipeAngle >= 315 ? !1 === _.options.rtl ? "left" : "right" : swipeAngle >= 135 && swipeAngle <= 225 ? !1 === _.options.rtl ? "right" : "left" : !0 === _.options.verticalSwiping ? swipeAngle >= 35 && swipeAngle <= 135 ? "down" : "up" : "vertical"
            }
            ,
            Slick.prototype.swipeEnd = function(event) {
                var slideCount, direction, _ = this;
                if (_.dragging = !1,
                _.swiping = !1,
                _.scrolling)
                    return _.scrolling = !1,
                    !1;
                if (_.interrupted = !1,
                _.shouldClick = !(_.touchObject.swipeLength > 10),
                void 0 === _.touchObject.curX)
                    return !1;
                if (!0 === _.touchObject.edgeHit && _.$slider.trigger("edge", [_, _.swipeDirection()]),
                _.touchObject.swipeLength >= _.touchObject.minSwipe) {
                    switch (direction = _.swipeDirection()) {
                    case "left":
                    case "down":
                        slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount(),
                        _.currentDirection = 0;
                        break;
                    case "right":
                    case "up":
                        slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount(),
                        _.currentDirection = 1
                    }
                    "vertical" != direction && (_.slideHandler(slideCount),
                    _.touchObject = {},
                    _.$slider.trigger("swipe", [_, direction]))
                } else
                    _.touchObject.startX !== _.touchObject.curX && (_.slideHandler(_.currentSlide),
                    _.touchObject = {})
            }
            ,
            Slick.prototype.swipeHandler = function(event) {
                var _ = this;
                if (!(!1 === _.options.swipe || "ontouchend"in document && !1 === _.options.swipe || !1 === _.options.draggable && -1 !== event.type.indexOf("mouse")))
                    switch (_.touchObject.fingerCount = event.originalEvent && void 0 !== event.originalEvent.touches ? event.originalEvent.touches.length : 1,
                    _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold,
                    !0 === _.options.verticalSwiping && (_.touchObject.minSwipe = _.listHeight / _.options.touchThreshold),
                    event.data.action) {
                    case "start":
                        _.swipeStart(event);
                        break;
                    case "move":
                        _.swipeMove(event);
                        break;
                    case "end":
                        _.swipeEnd(event)
                    }
            }
            ,
            Slick.prototype.swipeMove = function(event) {
                var curLeft, swipeDirection, swipeLength, positionOffset, touches, verticalSwipeLength, _ = this;
                return touches = void 0 !== event.originalEvent ? event.originalEvent.touches : null,
                !(!_.dragging || _.scrolling || touches && 1 !== touches.length) && (curLeft = _.getLeft(_.currentSlide),
                _.touchObject.curX = void 0 !== touches ? touches[0].pageX : event.clientX,
                _.touchObject.curY = void 0 !== touches ? touches[0].pageY : event.clientY,
                _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2))),
                verticalSwipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2))),
                !_.options.verticalSwiping && !_.swiping && verticalSwipeLength > 4 ? (_.scrolling = !0,
                !1) : (!0 === _.options.verticalSwiping && (_.touchObject.swipeLength = verticalSwipeLength),
                swipeDirection = _.swipeDirection(),
                void 0 !== event.originalEvent && _.touchObject.swipeLength > 4 && (_.swiping = !0,
                event.preventDefault()),
                positionOffset = (!1 === _.options.rtl ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1),
                !0 === _.options.verticalSwiping && (positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1),
                swipeLength = _.touchObject.swipeLength,
                _.touchObject.edgeHit = !1,
                !1 === _.options.infinite && (0 === _.currentSlide && "right" === swipeDirection || _.currentSlide >= _.getDotCount() && "left" === swipeDirection) && (swipeLength = _.touchObject.swipeLength * _.options.edgeFriction,
                _.touchObject.edgeHit = !0),
                !1 === _.options.vertical ? _.swipeLeft = curLeft + swipeLength * positionOffset : _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset,
                !0 === _.options.verticalSwiping && (_.swipeLeft = curLeft + swipeLength * positionOffset),
                !0 !== _.options.fade && !1 !== _.options.touchMove && (!0 === _.animating ? (_.swipeLeft = null,
                !1) : void _.setCSS(_.swipeLeft))))
            }
            ,
            Slick.prototype.swipeStart = function(event) {
                var touches, _ = this;
                if (_.interrupted = !0,
                1 !== _.touchObject.fingerCount || _.slideCount <= _.options.slidesToShow)
                    return _.touchObject = {},
                    !1;
                void 0 !== event.originalEvent && void 0 !== event.originalEvent.touches && (touches = event.originalEvent.touches[0]),
                _.touchObject.startX = _.touchObject.curX = void 0 !== touches ? touches.pageX : event.clientX,
                _.touchObject.startY = _.touchObject.curY = void 0 !== touches ? touches.pageY : event.clientY,
                _.dragging = !0
            }
            ,
            Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {
                var _ = this;
                null !== _.$slidesCache && (_.unload(),
                _.$slideTrack.children(this.options.slide).detach(),
                _.$slidesCache.appendTo(_.$slideTrack),
                _.reinit())
            }
            ,
            Slick.prototype.unload = function() {
                var _ = this;
                $(".slick-cloned", _.$slider).remove(),
                _.$dots && _.$dots.remove(),
                _.$prevArrow && _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.remove(),
                _.$nextArrow && _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.remove(),
                _.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "")
            }
            ,
            Slick.prototype.unslick = function(fromBreakpoint) {
                var _ = this;
                _.$slider.trigger("unslick", [_, fromBreakpoint]),
                _.destroy()
            }
            ,
            Slick.prototype.updateArrows = function() {
                var _ = this;
                Math.floor(_.options.slidesToShow / 2),
                !0 === _.options.arrows && _.slideCount > _.options.slidesToShow && !_.options.infinite && (_.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"),
                _.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"),
                0 === _.currentSlide ? (_.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                _.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : _.currentSlide >= _.slideCount - _.options.slidesToShow && !1 === _.options.centerMode ? (_.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : _.currentSlide >= _.slideCount - 1 && !0 === _.options.centerMode && (_.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"),
                _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")))
            }
            ,
            Slick.prototype.updateDots = function() {
                var _ = this;
                null !== _.$dots && (_.$dots.find("li").removeClass("slick-active").end(),
                _.$dots.find("li").eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass("slick-active"))
            }
            ,
            Slick.prototype.visibility = function() {
                var _ = this;
                _.options.autoplay && (document[_.hidden] ? _.interrupted = !0 : _.interrupted = !1)
            }
            ,
            $.fn.slick = function() {
                var i, ret, _ = this, opt = arguments[0], args = Array.prototype.slice.call(arguments, 1), l = _.length;
                for (i = 0; i < l; i++)
                    if ("object" == typeof opt || void 0 === opt ? _[i].slick = new Slick(_[i],opt) : ret = _[i].slick[opt].apply(_[i].slick, args),
                    void 0 !== ret)
                        return ret;
                return _
            }
        })
    }
    , {
        jquery: 10
    }],
    21: [function(require, module, exports) {
        (function() {
            var $, win;
            $ = this.jQuery || window.jQuery,
            win = $(window),
            $.fn.stick_in_parent = function(opts) {
                var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
                for (null == opts && (opts = {}),
                sticky_class = opts.sticky_class,
                inner_scrolling = opts.inner_scrolling,
                recalc_every = opts.recalc_every,
                parent_selector = opts.parent,
                offset_top = opts.offset_top,
                manual_spacer = opts.spacer,
                enable_bottoming = opts.bottoming,
                null == offset_top && (offset_top = 0),
                null == parent_selector && (parent_selector = void 0),
                null == inner_scrolling && (inner_scrolling = !0),
                null == sticky_class && (sticky_class = "is_stuck"),
                doc = $(document),
                null == enable_bottoming && (enable_bottoming = !0),
                fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
                    var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
                    if (!elm.data("sticky_kit")) {
                        if (elm.data("sticky_kit", !0),
                        last_scroll_height = doc.height(),
                        parent = elm.parent(),
                        null != parent_selector && (parent = parent.closest(parent_selector)),
                        !parent.length)
                            throw "failed to find stick parent";
                        if (fixed = !1,
                        bottomed = !1,
                        (spacer = null != manual_spacer ? manual_spacer && elm.closest(manual_spacer) : $("<div />")) && spacer.css("position", elm.css("position")),
                        (recalc = function() {
                            var border_top, padding_top, restore;
                            if (!detached)
                                return last_scroll_height = doc.height(),
                                border_top = parseInt(parent.css("border-top-width"), 10),
                                padding_top = parseInt(parent.css("padding-top"), 10),
                                padding_bottom = parseInt(parent.css("padding-bottom"), 10),
                                parent_top = parent.offset().top + border_top + padding_top,
                                parent_height = parent.height(),
                                fixed && (fixed = !1,
                                bottomed = !1,
                                null == manual_spacer && (elm.insertAfter(spacer),
                                spacer.detach()),
                                elm.css({
                                    position: "",
                                    top: "",
                                    width: "",
                                    bottom: ""
                                }).removeClass(sticky_class),
                                restore = !0),
                                top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top,
                                height = elm.outerHeight(!0),
                                el_float = elm.css("float"),
                                spacer && spacer.css({
                                    width: elm.outerWidth(!0),
                                    height: height,
                                    display: elm.css("display"),
                                    "vertical-align": elm.css("vertical-align"),
                                    float: el_float
                                }),
                                restore ? tick() : void 0
                        }
                        )(),
                        height !== parent_height)
                            return last_pos = void 0,
                            offset = offset_top,
                            recalc_counter = recalc_every,
                            tick = function() {
                                var css, delta, recalced, scroll, will_bottom, win_height;
                                if (!detached)
                                    return recalced = !1,
                                    null != recalc_counter && (recalc_counter -= 1) <= 0 && (recalc_counter = recalc_every,
                                    recalc(),
                                    recalced = !0),
                                    recalced || doc.height() === last_scroll_height || (recalc(),
                                    recalced = !0),
                                    scroll = win.scrollTop(),
                                    null != last_pos && (delta = scroll - last_pos),
                                    last_pos = scroll,
                                    fixed ? (enable_bottoming && (will_bottom = scroll + height + offset > parent_height + parent_top,
                                    bottomed && !will_bottom && (bottomed = !1,
                                    elm.css({
                                        position: "fixed",
                                        bottom: "",
                                        top: offset
                                    }).trigger("sticky_kit:unbottom"))),
                                    scroll < top && (fixed = !1,
                                    offset = offset_top,
                                    null == manual_spacer && ("left" !== el_float && "right" !== el_float || elm.insertAfter(spacer),
                                    spacer.detach()),
                                    css = {
                                        position: "",
                                        width: "",
                                        top: ""
                                    },
                                    elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick")),
                                    inner_scrolling && (win_height = win.height(),
                                    height + offset_top > win_height && (bottomed || (offset -= delta,
                                    offset = Math.max(win_height - height, offset),
                                    offset = Math.min(offset_top, offset),
                                    fixed && elm.css({
                                        top: offset + "px"
                                    }))))) : scroll > top && (fixed = !0,
                                    (css = {
                                        position: "fixed",
                                        top: offset
                                    }).width = "border-box" === elm.css("box-sizing") ? elm.outerWidth() + "px" : elm.width() + "px",
                                    elm.css(css).addClass(sticky_class),
                                    null == manual_spacer && (elm.after(spacer),
                                    "left" !== el_float && "right" !== el_float || spacer.append(elm)),
                                    elm.trigger("sticky_kit:stick")),
                                    fixed && enable_bottoming && (null == will_bottom && (will_bottom = scroll + height + offset > parent_height + parent_top),
                                    !bottomed && will_bottom) ? (bottomed = !0,
                                    "static" === parent.css("position") && parent.css({
                                        position: "relative"
                                    }),
                                    elm.css({
                                        position: "absolute",
                                        bottom: padding_bottom,
                                        top: "auto"
                                    }).trigger("sticky_kit:bottom")) : void 0
                            }
                            ,
                            recalc_and_tick = function() {
                                return recalc(),
                                tick()
                            }
                            ,
                            detach = function() {
                                if (detached = !0,
                                win.off("touchmove", tick),
                                win.off("scroll", tick),
                                win.off("resize", recalc_and_tick),
                                $(document.body).off("sticky_kit:recalc", recalc_and_tick),
                                elm.off("sticky_kit:detach", detach),
                                elm.removeData("sticky_kit"),
                                elm.css({
                                    position: "",
                                    bottom: "",
                                    top: "",
                                    width: ""
                                }),
                                parent.position("position", ""),
                                fixed)
                                    return null == manual_spacer && ("left" !== el_float && "right" !== el_float || elm.insertAfter(spacer),
                                    spacer.remove()),
                                    elm.removeClass(sticky_class)
                            }
                            ,
                            win.on("touchmove", tick),
                            win.on("scroll", tick),
                            win.on("resize", recalc_and_tick),
                            $(document.body).on("sticky_kit:recalc", recalc_and_tick),
                            elm.on("sticky_kit:detach", detach),
                            setTimeout(tick, 0)
                    }
                }
                ,
                i = 0,
                len = this.length; i < len; i++)
                    elm = this[i],
                    fn($(elm));
                return this
            }
        }
        ).call(this)
    }
    , {}],
    22: [function(require, module, exports) {
        !function(root, factory) {
            "use strict";
            "object" == typeof module && module.exports ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : root.IPv6 = factory(root)
        }(this, function(root) {
            "use strict";
            var _IPv6 = root && root.IPv6;
            return {
                best: function(address) {
                    var segments = address.toLowerCase().split(":")
                      , length = segments.length
                      , total = 8;
                    "" === segments[0] && "" === segments[1] && "" === segments[2] ? (segments.shift(),
                    segments.shift()) : "" === segments[0] && "" === segments[1] ? segments.shift() : "" === segments[length - 1] && "" === segments[length - 2] && segments.pop(),
                    -1 !== segments[(length = segments.length) - 1].indexOf(".") && (total = 7);
                    var pos;
                    for (pos = 0; pos < length && "" !== segments[pos]; pos++)
                        ;
                    if (pos < total)
                        for (segments.splice(pos, 1, "0000"); segments.length < total; )
                            segments.splice(pos, 0, "0000");
                    for (var _segments, i = 0; i < total; i++) {
                        _segments = segments[i].split("");
                        for (var j = 0; j < 3 && "0" === _segments[0] && _segments.length > 1; j++)
                            _segments.splice(0, 1);
                        segments[i] = _segments.join("")
                    }
                    var best = -1
                      , _best = 0
                      , _current = 0
                      , current = -1
                      , inzeroes = !1;
                    for (i = 0; i < total; i++)
                        inzeroes ? "0" === segments[i] ? _current += 1 : (inzeroes = !1,
                        _current > _best && (best = current,
                        _best = _current)) : "0" === segments[i] && (inzeroes = !0,
                        current = i,
                        _current = 1);
                    _current > _best && (best = current,
                    _best = _current),
                    _best > 1 && segments.splice(best, _best, ""),
                    length = segments.length;
                    var result = "";
                    for ("" === segments[0] && (result = ":"),
                    i = 0; i < length && (result += segments[i],
                    i !== length - 1); i++)
                        result += ":";
                    return "" === segments[length - 1] && (result += ":"),
                    result
                },
                noConflict: function() {
                    return root.IPv6 === this && (root.IPv6 = _IPv6),
                    this
                }
            }
        })
    }
    , {}],
    23: [function(require, module, exports) {
        !function(root, factory) {
            "use strict";
            "object" == typeof module && module.exports ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : root.SecondLevelDomains = factory(root)
        }(this, function(root) {
            "use strict";
            var _SecondLevelDomains = root && root.SecondLevelDomains
              , SLD = {
                list: {
                    ac: " com gov mil net org ",
                    ae: " ac co gov mil name net org pro sch ",
                    af: " com edu gov net org ",
                    al: " com edu gov mil net org ",
                    ao: " co ed gv it og pb ",
                    ar: " com edu gob gov int mil net org tur ",
                    at: " ac co gv or ",
                    au: " asn com csiro edu gov id net org ",
                    ba: " co com edu gov mil net org rs unbi unmo unsa untz unze ",
                    bb: " biz co com edu gov info net org store tv ",
                    bh: " biz cc com edu gov info net org ",
                    bn: " com edu gov net org ",
                    bo: " com edu gob gov int mil net org tv ",
                    br: " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
                    bs: " com edu gov net org ",
                    bz: " du et om ov rg ",
                    ca: " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
                    ck: " biz co edu gen gov info net org ",
                    cn: " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
                    co: " com edu gov mil net nom org ",
                    cr: " ac c co ed fi go or sa ",
                    cy: " ac biz com ekloges gov ltd name net org parliament press pro tm ",
                    do: " art com edu gob gov mil net org sld web ",
                    dz: " art asso com edu gov net org pol ",
                    ec: " com edu fin gov info med mil net org pro ",
                    eg: " com edu eun gov mil name net org sci ",
                    er: " com edu gov ind mil net org rochest w ",
                    es: " com edu gob nom org ",
                    et: " biz com edu gov info name net org ",
                    fj: " ac biz com info mil name net org pro ",
                    fk: " ac co gov net nom org ",
                    fr: " asso com f gouv nom prd presse tm ",
                    gg: " co net org ",
                    gh: " com edu gov mil org ",
                    gn: " ac com gov net org ",
                    gr: " com edu gov mil net org ",
                    gt: " com edu gob ind mil net org ",
                    gu: " com edu gov net org ",
                    hk: " com edu gov idv net org ",
                    hu: " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
                    id: " ac co go mil net or sch web ",
                    il: " ac co gov idf k12 muni net org ",
                    in: " ac co edu ernet firm gen gov i ind mil net nic org res ",
                    iq: " com edu gov i mil net org ",
                    ir: " ac co dnssec gov i id net org sch ",
                    it: " edu gov ",
                    je: " co net org ",
                    jo: " com edu gov mil name net org sch ",
                    jp: " ac ad co ed go gr lg ne or ",
                    ke: " ac co go info me mobi ne or sc ",
                    kh: " com edu gov mil net org per ",
                    ki: " biz com de edu gov info mob net org tel ",
                    km: " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
                    kn: " edu gov net org ",
                    kr: " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
                    kw: " com edu gov net org ",
                    ky: " com edu gov net org ",
                    kz: " com edu gov mil net org ",
                    lb: " com edu gov net org ",
                    lk: " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
                    lr: " com edu gov net org ",
                    lv: " asn com conf edu gov id mil net org ",
                    ly: " com edu gov id med net org plc sch ",
                    ma: " ac co gov m net org press ",
                    mc: " asso tm ",
                    me: " ac co edu gov its net org priv ",
                    mg: " com edu gov mil nom org prd tm ",
                    mk: " com edu gov inf name net org pro ",
                    ml: " com edu gov net org presse ",
                    mn: " edu gov org ",
                    mo: " com edu gov net org ",
                    mt: " com edu gov net org ",
                    mv: " aero biz com coop edu gov info int mil museum name net org pro ",
                    mw: " ac co com coop edu gov int museum net org ",
                    mx: " com edu gob net org ",
                    my: " com edu gov mil name net org sch ",
                    nf: " arts com firm info net other per rec store web ",
                    ng: " biz com edu gov mil mobi name net org sch ",
                    ni: " ac co com edu gob mil net nom org ",
                    np: " com edu gov mil net org ",
                    nr: " biz com edu gov info net org ",
                    om: " ac biz co com edu gov med mil museum net org pro sch ",
                    pe: " com edu gob mil net nom org sld ",
                    ph: " com edu gov i mil net ngo org ",
                    pk: " biz com edu fam gob gok gon gop gos gov net org web ",
                    pl: " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
                    pr: " ac biz com edu est gov info isla name net org pro prof ",
                    ps: " com edu gov net org plo sec ",
                    pw: " belau co ed go ne or ",
                    ro: " arts com firm info nom nt org rec store tm www ",
                    rs: " ac co edu gov in org ",
                    sb: " com edu gov net org ",
                    sc: " com edu gov net org ",
                    sh: " co com edu gov net nom org ",
                    sl: " com edu gov net org ",
                    st: " co com consulado edu embaixada gov mil net org principe saotome store ",
                    sv: " com edu gob org red ",
                    sz: " ac co org ",
                    tr: " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
                    tt: " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
                    tw: " club com ebiz edu game gov idv mil net org ",
                    mu: " ac co com gov net or org ",
                    mz: " ac co edu gov org ",
                    na: " co com ",
                    nz: " ac co cri geek gen govt health iwi maori mil net org parliament school ",
                    pa: " abo ac com edu gob ing med net nom org sld ",
                    pt: " com edu gov int net nome org publ ",
                    py: " com edu gov mil net org ",
                    qa: " com edu gov mil net org ",
                    re: " asso com nom ",
                    ru: " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
                    rw: " ac co com edu gouv gov int mil net ",
                    sa: " com edu gov med net org pub sch ",
                    sd: " com edu gov info med net org tv ",
                    se: " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
                    sg: " com edu gov idn net org per ",
                    sn: " art com edu gouv org perso univ ",
                    sy: " com edu gov mil net news org ",
                    th: " ac co go in mi net or ",
                    tj: " ac biz co com edu go gov info int mil name net nic org test web ",
                    tn: " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
                    tz: " ac co go ne or ",
                    ua: " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
                    ug: " ac co go ne or org sc ",
                    uk: " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
                    us: " dni fed isa kids nsn ",
                    uy: " com edu gub mil net org ",
                    ve: " co com edu gob info mil net org web ",
                    vi: " co com k12 net org ",
                    vn: " ac biz com edu gov health info int name net org pro ",
                    ye: " co com gov ltd me net org plc ",
                    yu: " ac co edu gov org ",
                    za: " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
                    zm: " ac co com edu gov net org sch ",
                    com: "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
                    net: "gb jp se uk ",
                    org: "ae",
                    de: "com "
                },
                has: function(domain) {
                    var tldOffset = domain.lastIndexOf(".");
                    if (tldOffset <= 0 || tldOffset >= domain.length - 1)
                        return !1;
                    var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
                    if (sldOffset <= 0 || sldOffset >= tldOffset - 1)
                        return !1;
                    var sldList = SLD.list[domain.slice(tldOffset + 1)];
                    return !!sldList && sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0
                },
                is: function(domain) {
                    var tldOffset = domain.lastIndexOf(".");
                    if (tldOffset <= 0 || tldOffset >= domain.length - 1)
                        return !1;
                    if (domain.lastIndexOf(".", tldOffset - 1) >= 0)
                        return !1;
                    var sldList = SLD.list[domain.slice(tldOffset + 1)];
                    return !!sldList && sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0
                },
                get: function(domain) {
                    var tldOffset = domain.lastIndexOf(".");
                    if (tldOffset <= 0 || tldOffset >= domain.length - 1)
                        return null;
                    var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
                    if (sldOffset <= 0 || sldOffset >= tldOffset - 1)
                        return null;
                    var sldList = SLD.list[domain.slice(tldOffset + 1)];
                    return sldList ? sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0 ? null : domain.slice(sldOffset + 1) : null
                },
                noConflict: function() {
                    return root.SecondLevelDomains === this && (root.SecondLevelDomains = _SecondLevelDomains),
                    this
                }
            };
            return SLD
        })
    }
    , {}],
    24: [function(require, module, exports) {
        !function(root, factory) {
            "use strict";
            "object" == typeof module && module.exports ? module.exports = factory(require("./punycode"), require("./IPv6"), require("./SecondLevelDomains")) : "function" == typeof define && define.amd ? define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory) : root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root)
        }(this, function(punycode, IPv6, SLD, root) {
            "use strict";
            function URI(url, base) {
                var _urlSupplied = arguments.length >= 1
                  , _baseSupplied = arguments.length >= 2;
                if (!(this instanceof URI))
                    return _urlSupplied ? _baseSupplied ? new URI(url,base) : new URI(url) : new URI;
                if (void 0 === url) {
                    if (_urlSupplied)
                        throw new TypeError("undefined is not a valid argument for URI");
                    url = "undefined" != typeof location ? location.href + "" : ""
                }
                if (null === url && _urlSupplied)
                    throw new TypeError("null is not a valid argument for URI");
                return this.href(url),
                void 0 !== base ? this.absoluteTo(base) : this
            }
            function isInteger(value) {
                return /^[0-9]+$/.test(value)
            }
            function escapeRegEx(string) {
                return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
            }
            function getType(value) {
                return void 0 === value ? "Undefined" : String(Object.prototype.toString.call(value)).slice(8, -1)
            }
            function isArray(obj) {
                return "Array" === getType(obj)
            }
            function filterArrayValues(data, value) {
                var i, length, lookup = {};
                if ("RegExp" === getType(value))
                    lookup = null;
                else if (isArray(value))
                    for (i = 0,
                    length = value.length; i < length; i++)
                        lookup[value[i]] = !0;
                else
                    lookup[value] = !0;
                for (i = 0,
                length = data.length; i < length; i++)
                    (lookup && void 0 !== lookup[data[i]] || !lookup && value.test(data[i])) && (data.splice(i, 1),
                    length--,
                    i--);
                return data
            }
            function arrayContains(list, value) {
                var i, length;
                if (isArray(value)) {
                    for (i = 0,
                    length = value.length; i < length; i++)
                        if (!arrayContains(list, value[i]))
                            return !1;
                    return !0
                }
                var _type = getType(value);
                for (i = 0,
                length = list.length; i < length; i++)
                    if ("RegExp" === _type) {
                        if ("string" == typeof list[i] && list[i].match(value))
                            return !0
                    } else if (list[i] === value)
                        return !0;
                return !1
            }
            function arraysEqual(one, two) {
                if (!isArray(one) || !isArray(two))
                    return !1;
                if (one.length !== two.length)
                    return !1;
                one.sort(),
                two.sort();
                for (var i = 0, l = one.length; i < l; i++)
                    if (one[i] !== two[i])
                        return !1;
                return !0
            }
            function trimSlashes(text) {
                var trim_expression = /^\/+|\/+$/g;
                return text.replace(trim_expression, "")
            }
            function escapeForDumbFirefox36(value) {
                return escape(value)
            }
            function strictEncodeURIComponent(string) {
                return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A")
            }
            function generateSimpleAccessor(_part) {
                return function(v, build) {
                    return void 0 === v ? this._parts[_part] || "" : (this._parts[_part] = v || null,
                    this.build(!build),
                    this)
                }
            }
            function generatePrefixAccessor(_part, _key) {
                return function(v, build) {
                    return void 0 === v ? this._parts[_part] || "" : (null !== v && (v += "").charAt(0) === _key && (v = v.substring(1)),
                    this._parts[_part] = v,
                    this.build(!build),
                    this)
                }
            }
            var _URI = root && root.URI;
            URI.version = "1.19.1";
            var p = URI.prototype
              , hasOwn = Object.prototype.hasOwnProperty;
            URI._parts = function() {
                return {
                    protocol: null,
                    username: null,
                    password: null,
                    hostname: null,
                    urn: null,
                    port: null,
                    path: null,
                    query: null,
                    fragment: null,
                    preventInvalidHostname: URI.preventInvalidHostname,
                    duplicateQueryParameters: URI.duplicateQueryParameters,
                    escapeQuerySpace: URI.escapeQuerySpace
                }
            }
            ,
            URI.preventInvalidHostname = !1,
            URI.duplicateQueryParameters = !1,
            URI.escapeQuerySpace = !0,
            URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i,
            URI.idn_expression = /[^a-z0-9\._-]/i,
            URI.punycode_expression = /(xn--)/i,
            URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
            URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/,
            URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/gi,
            URI.findUri = {
                start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
                end: /[\s\r\n]|$/,
                trim: /[`!()\[\]{};:'".,<>?]+$/,
                parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
            },
            URI.defaultPorts = {
                http: "80",
                https: "443",
                ftp: "21",
                gopher: "70",
                ws: "80",
                wss: "443"
            },
            URI.hostProtocols = ["http", "https"],
            URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/,
            URI.domAttributes = {
                a: "href",
                blockquote: "cite",
                link: "href",
                base: "href",
                script: "src",
                form: "action",
                img: "src",
                area: "href",
                iframe: "src",
                embed: "src",
                source: "src",
                track: "src",
                input: "src",
                audio: "src",
                video: "src"
            },
            URI.getDomAttribute = function(node) {
                if (node && node.nodeName) {
                    var nodeName = node.nodeName.toLowerCase();
                    if ("input" !== nodeName || "image" === node.type)
                        return URI.domAttributes[nodeName]
                }
            }
            ,
            URI.encode = strictEncodeURIComponent,
            URI.decode = decodeURIComponent,
            URI.iso8859 = function() {
                URI.encode = escape,
                URI.decode = unescape
            }
            ,
            URI.unicode = function() {
                URI.encode = strictEncodeURIComponent,
                URI.decode = decodeURIComponent
            }
            ,
            URI.characters = {
                pathname: {
                    encode: {
                        expression: /%(24|26|2B|2C|3B|3D|3A|40)/gi,
                        map: {
                            "%24": "$",
                            "%26": "&",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "=",
                            "%3A": ":",
                            "%40": "@"
                        }
                    },
                    decode: {
                        expression: /[\/\?#]/g,
                        map: {
                            "/": "%2F",
                            "?": "%3F",
                            "#": "%23"
                        }
                    }
                },
                reserved: {
                    encode: {
                        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi,
                        map: {
                            "%3A": ":",
                            "%2F": "/",
                            "%3F": "?",
                            "%23": "#",
                            "%5B": "[",
                            "%5D": "]",
                            "%40": "@",
                            "%21": "!",
                            "%24": "$",
                            "%26": "&",
                            "%27": "'",
                            "%28": "(",
                            "%29": ")",
                            "%2A": "*",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "="
                        }
                    }
                },
                urnpath: {
                    encode: {
                        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi,
                        map: {
                            "%21": "!",
                            "%24": "$",
                            "%27": "'",
                            "%28": "(",
                            "%29": ")",
                            "%2A": "*",
                            "%2B": "+",
                            "%2C": ",",
                            "%3B": ";",
                            "%3D": "=",
                            "%40": "@"
                        }
                    },
                    decode: {
                        expression: /[\/\?#:]/g,
                        map: {
                            "/": "%2F",
                            "?": "%3F",
                            "#": "%23",
                            ":": "%3A"
                        }
                    }
                }
            },
            URI.encodeQuery = function(string, escapeQuerySpace) {
                var escaped = URI.encode(string + "");
                return void 0 === escapeQuerySpace && (escapeQuerySpace = URI.escapeQuerySpace),
                escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped
            }
            ,
            URI.decodeQuery = function(string, escapeQuerySpace) {
                string += "",
                void 0 === escapeQuerySpace && (escapeQuerySpace = URI.escapeQuerySpace);
                try {
                    return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string)
                } catch (e) {
                    return string
                }
            }
            ;
            var _part, _parts = {
                encode: "encode",
                decode: "decode"
            }, generateAccessor = function(_group, _part) {
                return function(string) {
                    try {
                        return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function(c) {
                            return URI.characters[_group][_part].map[c]
                        })
                    } catch (e) {
                        return string
                    }
                }
            };
            for (_part in _parts)
                URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]),
                URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
            var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
                return function(string) {
                    var actualCodingFunc;
                    actualCodingFunc = _innerCodingFuncName ? function(string) {
                        return URI[_codingFuncName](URI[_innerCodingFuncName](string))
                    }
                    : URI[_codingFuncName];
                    for (var segments = (string + "").split(_sep), i = 0, length = segments.length; i < length; i++)
                        segments[i] = actualCodingFunc(segments[i]);
                    return segments.join(_sep)
                }
            };
            URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment"),
            URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment"),
            URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode"),
            URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode"),
            URI.encodeReserved = generateAccessor("reserved", "encode"),
            URI.parse = function(string, parts) {
                var pos;
                return parts || (parts = {
                    preventInvalidHostname: URI.preventInvalidHostname
                }),
                (pos = string.indexOf("#")) > -1 && (parts.fragment = string.substring(pos + 1) || null,
                string = string.substring(0, pos)),
                (pos = string.indexOf("?")) > -1 && (parts.query = string.substring(pos + 1) || null,
                string = string.substring(0, pos)),
                "//" === string.substring(0, 2) ? (parts.protocol = null,
                string = string.substring(2),
                string = URI.parseAuthority(string, parts)) : (pos = string.indexOf(":")) > -1 && (parts.protocol = string.substring(0, pos) || null,
                parts.protocol && !parts.protocol.match(URI.protocol_expression) ? parts.protocol = void 0 : "//" === string.substring(pos + 1, pos + 3) ? (string = string.substring(pos + 3),
                string = URI.parseAuthority(string, parts)) : (string = string.substring(pos + 1),
                parts.urn = !0)),
                parts.path = string,
                parts
            }
            ,
            URI.parseHost = function(string, parts) {
                string || (string = "");
                var bracketPos, t, pos = (string = string.replace(/\\/g, "/")).indexOf("/");
                if (-1 === pos && (pos = string.length),
                "[" === string.charAt(0))
                    bracketPos = string.indexOf("]"),
                    parts.hostname = string.substring(1, bracketPos) || null,
                    parts.port = string.substring(bracketPos + 2, pos) || null,
                    "/" === parts.port && (parts.port = null);
                else {
                    var firstColon = string.indexOf(":")
                      , firstSlash = string.indexOf("/")
                      , nextColon = string.indexOf(":", firstColon + 1);
                    -1 !== nextColon && (-1 === firstSlash || nextColon < firstSlash) ? (parts.hostname = string.substring(0, pos) || null,
                    parts.port = null) : (t = string.substring(0, pos).split(":"),
                    parts.hostname = t[0] || null,
                    parts.port = t[1] || null)
                }
                return parts.hostname && "/" !== string.substring(pos).charAt(0) && (pos++,
                string = "/" + string),
                parts.preventInvalidHostname && URI.ensureValidHostname(parts.hostname, parts.protocol),
                parts.port && URI.ensureValidPort(parts.port),
                string.substring(pos) || "/"
            }
            ,
            URI.parseAuthority = function(string, parts) {
                return string = URI.parseUserinfo(string, parts),
                URI.parseHost(string, parts)
            }
            ,
            URI.parseUserinfo = function(string, parts) {
                var t, firstSlash = string.indexOf("/"), pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
                return pos > -1 && (-1 === firstSlash || pos < firstSlash) ? (t = string.substring(0, pos).split(":"),
                parts.username = t[0] ? URI.decode(t[0]) : null,
                t.shift(),
                parts.password = t[0] ? URI.decode(t.join(":")) : null,
                string = string.substring(pos + 1)) : (parts.username = null,
                parts.password = null),
                string
            }
            ,
            URI.parseQuery = function(string, escapeQuerySpace) {
                if (!string)
                    return {};
                if (!(string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "")))
                    return {};
                for (var v, name, value, items = {}, splits = string.split("&"), length = splits.length, i = 0; i < length; i++)
                    v = splits[i].split("="),
                    name = URI.decodeQuery(v.shift(), escapeQuerySpace),
                    value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null,
                    hasOwn.call(items, name) ? ("string" != typeof items[name] && null !== items[name] || (items[name] = [items[name]]),
                    items[name].push(value)) : items[name] = value;
                return items
            }
            ,
            URI.build = function(parts) {
                var t = "";
                return parts.protocol && (t += parts.protocol + ":"),
                parts.urn || !t && !parts.hostname || (t += "//"),
                t += URI.buildAuthority(parts) || "",
                "string" == typeof parts.path && ("/" !== parts.path.charAt(0) && "string" == typeof parts.hostname && (t += "/"),
                t += parts.path),
                "string" == typeof parts.query && parts.query && (t += "?" + parts.query),
                "string" == typeof parts.fragment && parts.fragment && (t += "#" + parts.fragment),
                t
            }
            ,
            URI.buildHost = function(parts) {
                var t = "";
                return parts.hostname ? (URI.ip6_expression.test(parts.hostname) ? t += "[" + parts.hostname + "]" : t += parts.hostname,
                parts.port && (t += ":" + parts.port),
                t) : ""
            }
            ,
            URI.buildAuthority = function(parts) {
                return URI.buildUserinfo(parts) + URI.buildHost(parts)
            }
            ,
            URI.buildUserinfo = function(parts) {
                var t = "";
                return parts.username && (t += URI.encode(parts.username)),
                parts.password && (t += ":" + URI.encode(parts.password)),
                t && (t += "@"),
                t
            }
            ,
            URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
                var unique, key, i, length, t = "";
                for (key in data)
                    if (hasOwn.call(data, key) && key)
                        if (isArray(data[key]))
                            for (unique = {},
                            i = 0,
                            length = data[key].length; i < length; i++)
                                void 0 !== data[key][i] && void 0 === unique[data[key][i] + ""] && (t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace),
                                !0 !== duplicateQueryParameters && (unique[data[key][i] + ""] = !0));
                        else
                            void 0 !== data[key] && (t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace));
                return t.substring(1)
            }
            ,
            URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
                return URI.encodeQuery(name, escapeQuerySpace) + (null !== value ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "")
            }
            ,
            URI.addQuery = function(data, name, value) {
                if ("object" == typeof name)
                    for (var key in name)
                        hasOwn.call(name, key) && URI.addQuery(data, key, name[key]);
                else {
                    if ("string" != typeof name)
                        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
                    if (void 0 === data[name])
                        return void (data[name] = value);
                    "string" == typeof data[name] && (data[name] = [data[name]]),
                    isArray(value) || (value = [value]),
                    data[name] = (data[name] || []).concat(value)
                }
            }
            ,
            URI.setQuery = function(data, name, value) {
                if ("object" == typeof name)
                    for (var key in name)
                        hasOwn.call(name, key) && URI.setQuery(data, key, name[key]);
                else {
                    if ("string" != typeof name)
                        throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
                    data[name] = void 0 === value ? null : value
                }
            }
            ,
            URI.removeQuery = function(data, name, value) {
                var i, length, key;
                if (isArray(name))
                    for (i = 0,
                    length = name.length; i < length; i++)
                        data[name[i]] = void 0;
                else if ("RegExp" === getType(name))
                    for (key in data)
                        name.test(key) && (data[key] = void 0);
                else if ("object" == typeof name)
                    for (key in name)
                        hasOwn.call(name, key) && URI.removeQuery(data, key, name[key]);
                else {
                    if ("string" != typeof name)
                        throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
                    void 0 !== value ? "RegExp" === getType(value) ? !isArray(data[name]) && value.test(data[name]) ? data[name] = void 0 : data[name] = filterArrayValues(data[name], value) : data[name] !== String(value) || isArray(value) && 1 !== value.length ? isArray(data[name]) && (data[name] = filterArrayValues(data[name], value)) : data[name] = void 0 : data[name] = void 0
                }
            }
            ,
            URI.hasQuery = function(data, name, value, withinArray) {
                switch (getType(name)) {
                case "String":
                    break;
                case "RegExp":
                    for (var key in data)
                        if (hasOwn.call(data, key) && name.test(key) && (void 0 === value || URI.hasQuery(data, key, value)))
                            return !0;
                    return !1;
                case "Object":
                    for (var _key in name)
                        if (hasOwn.call(name, _key) && !URI.hasQuery(data, _key, name[_key]))
                            return !1;
                    return !0;
                default:
                    throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter")
                }
                switch (getType(value)) {
                case "Undefined":
                    return name in data;
                case "Boolean":
                    return value === Boolean(isArray(data[name]) ? data[name].length : data[name]);
                case "Function":
                    return !!value(data[name], name, data);
                case "Array":
                    return !!isArray(data[name]) && (withinArray ? arrayContains : arraysEqual)(data[name], value);
                case "RegExp":
                    return isArray(data[name]) ? !!withinArray && arrayContains(data[name], value) : Boolean(data[name] && data[name].match(value));
                case "Number":
                    value = String(value);
                case "String":
                    return isArray(data[name]) ? !!withinArray && arrayContains(data[name], value) : data[name] === value;
                default:
                    throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter")
                }
            }
            ,
            URI.joinPaths = function() {
                for (var input = [], segments = [], nonEmptySegments = 0, i = 0; i < arguments.length; i++) {
                    var url = new URI(arguments[i]);
                    input.push(url);
                    for (var _segments = url.segment(), s = 0; s < _segments.length; s++)
                        "string" == typeof _segments[s] && segments.push(_segments[s]),
                        _segments[s] && nonEmptySegments++
                }
                if (!segments.length || !nonEmptySegments)
                    return new URI("");
                var uri = new URI("").segment(segments);
                return "" !== input[0].path() && "/" !== input[0].path().slice(0, 1) || uri.path("/" + uri.path()),
                uri.normalize()
            }
            ,
            URI.commonPath = function(one, two) {
                var pos, length = Math.min(one.length, two.length);
                for (pos = 0; pos < length; pos++)
                    if (one.charAt(pos) !== two.charAt(pos)) {
                        pos--;
                        break
                    }
                return pos < 1 ? one.charAt(0) === two.charAt(0) && "/" === one.charAt(0) ? "/" : "" : ("/" === one.charAt(pos) && "/" === two.charAt(pos) || (pos = one.substring(0, pos).lastIndexOf("/")),
                one.substring(0, pos + 1))
            }
            ,
            URI.withinString = function(string, callback, options) {
                options || (options = {});
                var _start = options.start || URI.findUri.start
                  , _end = options.end || URI.findUri.end
                  , _trim = options.trim || URI.findUri.trim
                  , _parens = options.parens || URI.findUri.parens
                  , _attributeOpen = /[a-z0-9-]=["']?$/i;
                for (_start.lastIndex = 0; ; ) {
                    var match = _start.exec(string);
                    if (!match)
                        break;
                    var start = match.index;
                    if (options.ignoreHtml) {
                        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                        if (attributeOpen && _attributeOpen.test(attributeOpen))
                            continue
                    }
                    for (var end = start + string.slice(start).search(_end), slice = string.slice(start, end), parensEnd = -1; ; ) {
                        var parensMatch = _parens.exec(slice);
                        if (!parensMatch)
                            break;
                        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
                        parensEnd = Math.max(parensEnd, parensMatchEnd)
                    }
                    if (!((slice = parensEnd > -1 ? slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "") : slice.replace(_trim, "")).length <= match[0].length || options.ignore && options.ignore.test(slice))) {
                        var result = callback(slice, start, end = start + slice.length, string);
                        void 0 !== result ? (result = String(result),
                        string = string.slice(0, start) + result + string.slice(end),
                        _start.lastIndex = start + result.length) : _start.lastIndex = end
                    }
                }
                return _start.lastIndex = 0,
                string
            }
            ,
            URI.ensureValidHostname = function(v, protocol) {
                var hasHostname = !!v
                  , rejectEmptyHostname = !1;
                if (!!protocol && (rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol)),
                rejectEmptyHostname && !hasHostname)
                    throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
                if (v && v.match(URI.invalid_hostname_characters)) {
                    if (!punycode)
                        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
                    if (punycode.toASCII(v).match(URI.invalid_hostname_characters))
                        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]')
                }
            }
            ,
            URI.ensureValidPort = function(v) {
                if (v) {
                    var port = Number(v);
                    if (!(isInteger(port) && port > 0 && port < 65536))
                        throw new TypeError('Port "' + v + '" is not a valid port')
                }
            }
            ,
            URI.noConflict = function(removeAll) {
                if (removeAll) {
                    var unconflicted = {
                        URI: this.noConflict()
                    };
                    return root.URITemplate && "function" == typeof root.URITemplate.noConflict && (unconflicted.URITemplate = root.URITemplate.noConflict()),
                    root.IPv6 && "function" == typeof root.IPv6.noConflict && (unconflicted.IPv6 = root.IPv6.noConflict()),
                    root.SecondLevelDomains && "function" == typeof root.SecondLevelDomains.noConflict && (unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict()),
                    unconflicted
                }
                return root.URI === this && (root.URI = _URI),
                this
            }
            ,
            p.build = function(deferBuild) {
                return !0 === deferBuild ? this._deferred_build = !0 : (void 0 === deferBuild || this._deferred_build) && (this._string = URI.build(this._parts),
                this._deferred_build = !1),
                this
            }
            ,
            p.clone = function() {
                return new URI(this)
            }
            ,
            p.valueOf = p.toString = function() {
                return this.build(!1)._string
            }
            ,
            p.protocol = generateSimpleAccessor("protocol"),
            p.username = generateSimpleAccessor("username"),
            p.password = generateSimpleAccessor("password"),
            p.hostname = generateSimpleAccessor("hostname"),
            p.port = generateSimpleAccessor("port"),
            p.query = generatePrefixAccessor("query", "?"),
            p.fragment = generatePrefixAccessor("fragment", "#"),
            p.search = function(v, build) {
                var t = this.query(v, build);
                return "string" == typeof t && t.length ? "?" + t : t
            }
            ,
            p.hash = function(v, build) {
                var t = this.fragment(v, build);
                return "string" == typeof t && t.length ? "#" + t : t
            }
            ,
            p.pathname = function(v, build) {
                if (void 0 === v || !0 === v) {
                    var res = this._parts.path || (this._parts.hostname ? "/" : "");
                    return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res
                }
                return this._parts.urn ? this._parts.path = v ? URI.recodeUrnPath(v) : "" : this._parts.path = v ? URI.recodePath(v) : "/",
                this.build(!build),
                this
            }
            ,
            p.path = p.pathname,
            p.href = function(href, build) {
                var key;
                if (void 0 === href)
                    return this.toString();
                this._string = "",
                this._parts = URI._parts();
                var _URI = href instanceof URI
                  , _object = "object" == typeof href && (href.hostname || href.path || href.pathname);
                if (href.nodeName && (href = href[URI.getDomAttribute(href)] || "",
                _object = !1),
                !_URI && _object && void 0 !== href.pathname && (href = href.toString()),
                "string" == typeof href || href instanceof String)
                    this._parts = URI.parse(String(href), this._parts);
                else {
                    if (!_URI && !_object)
                        throw new TypeError("invalid input");
                    var src = _URI ? href._parts : href;
                    for (key in src)
                        "query" !== key && hasOwn.call(this._parts, key) && (this._parts[key] = src[key]);
                    src.query && this.query(src.query, !1)
                }
                return this.build(!build),
                this
            }
            ,
            p.is = function(what) {
                var ip = !1
                  , ip4 = !1
                  , ip6 = !1
                  , name = !1
                  , sld = !1
                  , idn = !1
                  , punycode = !1
                  , relative = !this._parts.urn;
                switch (this._parts.hostname && (relative = !1,
                ip4 = URI.ip4_expression.test(this._parts.hostname),
                ip6 = URI.ip6_expression.test(this._parts.hostname),
                sld = (name = !(ip = ip4 || ip6)) && SLD && SLD.has(this._parts.hostname),
                idn = name && URI.idn_expression.test(this._parts.hostname),
                punycode = name && URI.punycode_expression.test(this._parts.hostname)),
                what.toLowerCase()) {
                case "relative":
                    return relative;
                case "absolute":
                    return !relative;
                case "domain":
                case "name":
                    return name;
                case "sld":
                    return sld;
                case "ip":
                    return ip;
                case "ip4":
                case "ipv4":
                case "inet4":
                    return ip4;
                case "ip6":
                case "ipv6":
                case "inet6":
                    return ip6;
                case "idn":
                    return idn;
                case "url":
                    return !this._parts.urn;
                case "urn":
                    return !!this._parts.urn;
                case "punycode":
                    return punycode
                }
                return null
            }
            ;
            var _protocol = p.protocol
              , _port = p.port
              , _hostname = p.hostname;
            p.protocol = function(v, build) {
                if (v && !(v = v.replace(/:(\/\/)?$/, "")).match(URI.protocol_expression))
                    throw new TypeError('Protocol "' + v + "\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");
                return _protocol.call(this, v, build)
            }
            ,
            p.scheme = p.protocol,
            p.port = function(v, build) {
                return this._parts.urn ? void 0 === v ? "" : this : (void 0 !== v && (0 === v && (v = null),
                v && (":" === (v += "").charAt(0) && (v = v.substring(1)),
                URI.ensureValidPort(v))),
                _port.call(this, v, build))
            }
            ,
            p.hostname = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 !== v) {
                    var x = {
                        preventInvalidHostname: this._parts.preventInvalidHostname
                    };
                    if ("/" !== URI.parseHost(v, x))
                        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                    v = x.hostname,
                    this._parts.preventInvalidHostname && URI.ensureValidHostname(v, this._parts.protocol)
                }
                return _hostname.call(this, v, build)
            }
            ,
            p.origin = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v) {
                    var protocol = this.protocol();
                    return this.authority() ? (protocol ? protocol + "://" : "") + this.authority() : ""
                }
                var origin = URI(v);
                return this.protocol(origin.protocol()).authority(origin.authority()).build(!build),
                this
            }
            ,
            p.host = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v)
                    return this._parts.hostname ? URI.buildHost(this._parts) : "";
                if ("/" !== URI.parseHost(v, this._parts))
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                return this.build(!build),
                this
            }
            ,
            p.authority = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v)
                    return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
                if ("/" !== URI.parseAuthority(v, this._parts))
                    throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
                return this.build(!build),
                this
            }
            ,
            p.userinfo = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v) {
                    var t = URI.buildUserinfo(this._parts);
                    return t ? t.substring(0, t.length - 1) : t
                }
                return "@" !== v[v.length - 1] && (v += "@"),
                URI.parseUserinfo(v, this._parts),
                this.build(!build),
                this
            }
            ,
            p.resource = function(v, build) {
                var parts;
                return void 0 === v ? this.path() + this.search() + this.hash() : (parts = URI.parse(v),
                this._parts.path = parts.path,
                this._parts.query = parts.query,
                this._parts.fragment = parts.fragment,
                this.build(!build),
                this)
            }
            ,
            p.subdomain = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var end = this._parts.hostname.length - this.domain().length - 1;
                    return this._parts.hostname.substring(0, end) || ""
                }
                var e = this._parts.hostname.length - this.domain().length
                  , sub = this._parts.hostname.substring(0, e)
                  , replace = new RegExp("^" + escapeRegEx(sub));
                if (v && "." !== v.charAt(v.length - 1) && (v += "."),
                -1 !== v.indexOf(":"))
                    throw new TypeError("Domains cannot contain colons");
                return v && URI.ensureValidHostname(v, this._parts.protocol),
                this._parts.hostname = this._parts.hostname.replace(replace, v),
                this.build(!build),
                this
            }
            ,
            p.domain = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if ("boolean" == typeof v && (build = v,
                v = void 0),
                void 0 === v) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var t = this._parts.hostname.match(/\./g);
                    if (t && t.length < 2)
                        return this._parts.hostname;
                    var end = this._parts.hostname.length - this.tld(build).length - 1;
                    return end = this._parts.hostname.lastIndexOf(".", end - 1) + 1,
                    this._parts.hostname.substring(end) || ""
                }
                if (!v)
                    throw new TypeError("cannot set domain empty");
                if (-1 !== v.indexOf(":"))
                    throw new TypeError("Domains cannot contain colons");
                if (URI.ensureValidHostname(v, this._parts.protocol),
                !this._parts.hostname || this.is("IP"))
                    this._parts.hostname = v;
                else {
                    var replace = new RegExp(escapeRegEx(this.domain()) + "$");
                    this._parts.hostname = this._parts.hostname.replace(replace, v)
                }
                return this.build(!build),
                this
            }
            ,
            p.tld = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if ("boolean" == typeof v && (build = v,
                v = void 0),
                void 0 === v) {
                    if (!this._parts.hostname || this.is("IP"))
                        return "";
                    var pos = this._parts.hostname.lastIndexOf(".")
                      , tld = this._parts.hostname.substring(pos + 1);
                    return !0 !== build && SLD && SLD.list[tld.toLowerCase()] ? SLD.get(this._parts.hostname) || tld : tld
                }
                var replace;
                if (!v)
                    throw new TypeError("cannot set TLD empty");
                if (v.match(/[^a-zA-Z0-9-]/)) {
                    if (!SLD || !SLD.is(v))
                        throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
                    replace = new RegExp(escapeRegEx(this.tld()) + "$"),
                    this._parts.hostname = this._parts.hostname.replace(replace, v)
                } else {
                    if (!this._parts.hostname || this.is("IP"))
                        throw new ReferenceError("cannot set TLD on non-domain host");
                    replace = new RegExp(escapeRegEx(this.tld()) + "$"),
                    this._parts.hostname = this._parts.hostname.replace(replace, v)
                }
                return this.build(!build),
                this
            }
            ,
            p.directory = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v || !0 === v) {
                    if (!this._parts.path && !this._parts.hostname)
                        return "";
                    if ("/" === this._parts.path)
                        return "/";
                    var end = this._parts.path.length - this.filename().length - 1
                      , res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
                    return v ? URI.decodePath(res) : res
                }
                var e = this._parts.path.length - this.filename().length
                  , directory = this._parts.path.substring(0, e)
                  , replace = new RegExp("^" + escapeRegEx(directory));
                return this.is("relative") || (v || (v = "/"),
                "/" !== v.charAt(0) && (v = "/" + v)),
                v && "/" !== v.charAt(v.length - 1) && (v += "/"),
                v = URI.recodePath(v),
                this._parts.path = this._parts.path.replace(replace, v),
                this.build(!build),
                this
            }
            ,
            p.filename = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if ("string" != typeof v) {
                    if (!this._parts.path || "/" === this._parts.path)
                        return "";
                    var pos = this._parts.path.lastIndexOf("/")
                      , res = this._parts.path.substring(pos + 1);
                    return v ? URI.decodePathSegment(res) : res
                }
                var mutatedDirectory = !1;
                "/" === v.charAt(0) && (v = v.substring(1)),
                v.match(/\.?\//) && (mutatedDirectory = !0);
                var replace = new RegExp(escapeRegEx(this.filename()) + "$");
                return v = URI.recodePath(v),
                this._parts.path = this._parts.path.replace(replace, v),
                mutatedDirectory ? this.normalizePath(build) : this.build(!build),
                this
            }
            ,
            p.suffix = function(v, build) {
                if (this._parts.urn)
                    return void 0 === v ? "" : this;
                if (void 0 === v || !0 === v) {
                    if (!this._parts.path || "/" === this._parts.path)
                        return "";
                    var s, res, filename = this.filename(), pos = filename.lastIndexOf(".");
                    return -1 === pos ? "" : (s = filename.substring(pos + 1),
                    res = /^[a-z0-9%]+$/i.test(s) ? s : "",
                    v ? URI.decodePathSegment(res) : res)
                }
                "." === v.charAt(0) && (v = v.substring(1));
                var replace, suffix = this.suffix();
                if (suffix)
                    replace = v ? new RegExp(escapeRegEx(suffix) + "$") : new RegExp(escapeRegEx("." + suffix) + "$");
                else {
                    if (!v)
                        return this;
                    this._parts.path += "." + URI.recodePath(v)
                }
                return replace && (v = URI.recodePath(v),
                this._parts.path = this._parts.path.replace(replace, v)),
                this.build(!build),
                this
            }
            ,
            p.segment = function(segment, v, build) {
                var separator = this._parts.urn ? ":" : "/"
                  , path = this.path()
                  , absolute = "/" === path.substring(0, 1)
                  , segments = path.split(separator);
                if (void 0 !== segment && "number" != typeof segment && (build = v,
                v = segment,
                segment = void 0),
                void 0 !== segment && "number" != typeof segment)
                    throw new Error('Bad segment "' + segment + '", must be 0-based integer');
                if (absolute && segments.shift(),
                segment < 0 && (segment = Math.max(segments.length + segment, 0)),
                void 0 === v)
                    return void 0 === segment ? segments : segments[segment];
                if (null === segment || void 0 === segments[segment])
                    if (isArray(v)) {
                        segments = [];
                        for (var i = 0, l = v.length; i < l; i++)
                            (v[i].length || segments.length && segments[segments.length - 1].length) && (segments.length && !segments[segments.length - 1].length && segments.pop(),
                            segments.push(trimSlashes(v[i])))
                    } else
                        (v || "string" == typeof v) && (v = trimSlashes(v),
                        "" === segments[segments.length - 1] ? segments[segments.length - 1] = v : segments.push(v));
                else
                    v ? segments[segment] = trimSlashes(v) : segments.splice(segment, 1);
                return absolute && segments.unshift(""),
                this.path(segments.join(separator), build)
            }
            ,
            p.segmentCoded = function(segment, v, build) {
                var segments, i, l;
                if ("number" != typeof segment && (build = v,
                v = segment,
                segment = void 0),
                void 0 === v) {
                    if (segments = this.segment(segment, v, build),
                    isArray(segments))
                        for (i = 0,
                        l = segments.length; i < l; i++)
                            segments[i] = URI.decode(segments[i]);
                    else
                        segments = void 0 !== segments ? URI.decode(segments) : void 0;
                    return segments
                }
                if (isArray(v))
                    for (i = 0,
                    l = v.length; i < l; i++)
                        v[i] = URI.encode(v[i]);
                else
                    v = "string" == typeof v || v instanceof String ? URI.encode(v) : v;
                return this.segment(segment, v, build)
            }
            ;
            var q = p.query;
            return p.query = function(v, build) {
                if (!0 === v)
                    return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                if ("function" == typeof v) {
                    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace)
                      , result = v.call(this, data);
                    return this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                    this.build(!build),
                    this
                }
                return void 0 !== v && "string" != typeof v ? (this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                this.build(!build),
                this) : q.call(this, v, build)
            }
            ,
            p.setQuery = function(name, value, build) {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                if ("string" == typeof name || name instanceof String)
                    data[name] = void 0 !== value ? value : null;
                else {
                    if ("object" != typeof name)
                        throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
                    for (var key in name)
                        hasOwn.call(name, key) && (data[key] = name[key])
                }
                return this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                "string" != typeof name && (build = value),
                this.build(!build),
                this
            }
            ,
            p.addQuery = function(name, value, build) {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return URI.addQuery(data, name, void 0 === value ? null : value),
                this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                "string" != typeof name && (build = value),
                this.build(!build),
                this
            }
            ,
            p.removeQuery = function(name, value, build) {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return URI.removeQuery(data, name, value),
                this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace),
                "string" != typeof name && (build = value),
                this.build(!build),
                this
            }
            ,
            p.hasQuery = function(name, value, withinArray) {
                var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
                return URI.hasQuery(data, name, value, withinArray)
            }
            ,
            p.setSearch = p.setQuery,
            p.addSearch = p.addQuery,
            p.removeSearch = p.removeQuery,
            p.hasSearch = p.hasQuery,
            p.normalize = function() {
                return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build()
            }
            ,
            p.normalizeProtocol = function(build) {
                return "string" == typeof this._parts.protocol && (this._parts.protocol = this._parts.protocol.toLowerCase(),
                this.build(!build)),
                this
            }
            ,
            p.normalizeHostname = function(build) {
                return this._parts.hostname && (this.is("IDN") && punycode ? this._parts.hostname = punycode.toASCII(this._parts.hostname) : this.is("IPv6") && IPv6 && (this._parts.hostname = IPv6.best(this._parts.hostname)),
                this._parts.hostname = this._parts.hostname.toLowerCase(),
                this.build(!build)),
                this
            }
            ,
            p.normalizePort = function(build) {
                return "string" == typeof this._parts.protocol && this._parts.port === URI.defaultPorts[this._parts.protocol] && (this._parts.port = null,
                this.build(!build)),
                this
            }
            ,
            p.normalizePath = function(build) {
                var _path = this._parts.path;
                if (!_path)
                    return this;
                if (this._parts.urn)
                    return this._parts.path = URI.recodeUrnPath(this._parts.path),
                    this.build(!build),
                    this;
                if ("/" === this._parts.path)
                    return this;
                var _was_relative, _parent, _pos, _leadingParents = "";
                for ("/" !== (_path = URI.recodePath(_path)).charAt(0) && (_was_relative = !0,
                _path = "/" + _path),
                "/.." !== _path.slice(-3) && "/." !== _path.slice(-2) || (_path += "/"),
                _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"),
                _was_relative && (_leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "") && (_leadingParents = _leadingParents[0]); ; ) {
                    if (-1 === (_parent = _path.search(/\/\.\.(\/|$)/)))
                        break;
                    0 !== _parent ? (-1 === (_pos = _path.substring(0, _parent).lastIndexOf("/")) && (_pos = _parent),
                    _path = _path.substring(0, _pos) + _path.substring(_parent + 3)) : _path = _path.substring(3)
                }
                return _was_relative && this.is("relative") && (_path = _leadingParents + _path.substring(1)),
                this._parts.path = _path,
                this.build(!build),
                this
            }
            ,
            p.normalizePathname = p.normalizePath,
            p.normalizeQuery = function(build) {
                return "string" == typeof this._parts.query && (this._parts.query.length ? this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null,
                this.build(!build)),
                this
            }
            ,
            p.normalizeFragment = function(build) {
                return this._parts.fragment || (this._parts.fragment = null,
                this.build(!build)),
                this
            }
            ,
            p.normalizeSearch = p.normalizeQuery,
            p.normalizeHash = p.normalizeFragment,
            p.iso8859 = function() {
                var e = URI.encode
                  , d = URI.decode;
                URI.encode = escape,
                URI.decode = decodeURIComponent;
                try {
                    this.normalize()
                } finally {
                    URI.encode = e,
                    URI.decode = d
                }
                return this
            }
            ,
            p.unicode = function() {
                var e = URI.encode
                  , d = URI.decode;
                URI.encode = strictEncodeURIComponent,
                URI.decode = unescape;
                try {
                    this.normalize()
                } finally {
                    URI.encode = e,
                    URI.decode = d
                }
                return this
            }
            ,
            p.readable = function() {
                var uri = this.clone();
                uri.username("").password("").normalize();
                var t = "";
                if (uri._parts.protocol && (t += uri._parts.protocol + "://"),
                uri._parts.hostname && (uri.is("punycode") && punycode ? (t += punycode.toUnicode(uri._parts.hostname),
                uri._parts.port && (t += ":" + uri._parts.port)) : t += uri.host()),
                uri._parts.hostname && uri._parts.path && "/" !== uri._parts.path.charAt(0) && (t += "/"),
                t += uri.path(!0),
                uri._parts.query) {
                    for (var q = "", i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
                        var kv = (qp[i] || "").split("=");
                        q += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"),
                        void 0 !== kv[1] && (q += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"))
                    }
                    t += "?" + q.substring(1)
                }
                return t += URI.decodeQuery(uri.hash(), !0)
            }
            ,
            p.absoluteTo = function(base) {
                var basedir, i, p, resolved = this.clone(), properties = ["protocol", "username", "password", "hostname", "port"];
                if (this._parts.urn)
                    throw new Error("URNs do not have any generally defined hierarchical components");
                if (base instanceof URI || (base = new URI(base)),
                resolved._parts.protocol)
                    return resolved;
                if (resolved._parts.protocol = base._parts.protocol,
                this._parts.hostname)
                    return resolved;
                for (i = 0; p = properties[i]; i++)
                    resolved._parts[p] = base._parts[p];
                return resolved._parts.path ? (".." === resolved._parts.path.substring(-2) && (resolved._parts.path += "/"),
                "/" !== resolved.path().charAt(0) && (basedir = (basedir = base.directory()) || (0 === base.path().indexOf("/") ? "/" : ""),
                resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path,
                resolved.normalizePath())) : (resolved._parts.path = base._parts.path,
                resolved._parts.query || (resolved._parts.query = base._parts.query)),
                resolved.build(),
                resolved
            }
            ,
            p.relativeTo = function(base) {
                var relativeParts, baseParts, common, relativePath, basePath, relative = this.clone().normalize();
                if (relative._parts.urn)
                    throw new Error("URNs do not have any generally defined hierarchical components");
                if (base = new URI(base).normalize(),
                relativeParts = relative._parts,
                baseParts = base._parts,
                relativePath = relative.path(),
                basePath = base.path(),
                "/" !== relativePath.charAt(0))
                    throw new Error("URI is already relative");
                if ("/" !== basePath.charAt(0))
                    throw new Error("Cannot calculate a URI relative to another relative URI");
                if (relativeParts.protocol === baseParts.protocol && (relativeParts.protocol = null),
                relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password)
                    return relative.build();
                if (null !== relativeParts.protocol || null !== relativeParts.username || null !== relativeParts.password)
                    return relative.build();
                if (relativeParts.hostname !== baseParts.hostname || relativeParts.port !== baseParts.port)
                    return relative.build();
                if (relativeParts.hostname = null,
                relativeParts.port = null,
                relativePath === basePath)
                    return relativeParts.path = "",
                    relative.build();
                if (!(common = URI.commonPath(relativePath, basePath)))
                    return relative.build();
                var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
                return relativeParts.path = parents + relativeParts.path.substring(common.length) || "./",
                relative.build()
            }
            ,
            p.equals = function(uri) {
                var one_query, two_query, key, one = this.clone(), two = new URI(uri), one_map = {}, two_map = {}, checked = {};
                if (one.normalize(),
                two.normalize(),
                one.toString() === two.toString())
                    return !0;
                if (one_query = one.query(),
                two_query = two.query(),
                one.query(""),
                two.query(""),
                one.toString() !== two.toString())
                    return !1;
                if (one_query.length !== two_query.length)
                    return !1;
                one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace),
                two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
                for (key in one_map)
                    if (hasOwn.call(one_map, key)) {
                        if (isArray(one_map[key])) {
                            if (!arraysEqual(one_map[key], two_map[key]))
                                return !1
                        } else if (one_map[key] !== two_map[key])
                            return !1;
                        checked[key] = !0
                    }
                for (key in two_map)
                    if (hasOwn.call(two_map, key) && !checked[key])
                        return !1;
                return !0
            }
            ,
            p.preventInvalidHostname = function(v) {
                return this._parts.preventInvalidHostname = !!v,
                this
            }
            ,
            p.duplicateQueryParameters = function(v) {
                return this._parts.duplicateQueryParameters = !!v,
                this
            }
            ,
            p.escapeQuerySpace = function(v) {
                return this._parts.escapeQuerySpace = !!v,
                this
            }
            ,
            URI
        })
    }
    , {
        "./IPv6": 22,
        "./SecondLevelDomains": 23,
        "./punycode": 26
    }],
    25: [function(require, module, exports) {
        !function(root, factory) {
            "use strict";
            "object" == typeof module && module.exports ? module.exports = factory(require("jquery"), require("./URI")) : "function" == typeof define && define.amd ? define(["jquery", "./URI"], factory) : factory(root.jQuery, root.URI)
        }(this, function($, URI) {
            "use strict";
            function escapeRegEx(string) {
                return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1")
            }
            function getUriProperty(elem) {
                var nodeName = elem.nodeName.toLowerCase()
                  , property = URI.domAttributes[nodeName];
                if ("input" !== nodeName || "image" === elem.type)
                    return property
            }
            function generateAccessor(property) {
                return {
                    get: function(elem) {
                        return $(elem).uri()[property]()
                    },
                    set: function(elem, value) {
                        return $(elem).uri()[property](value),
                        value
                    }
                }
            }
            function uriPseudo(elem, text) {
                var match, property, uri;
                return !(!getUriProperty(elem) || !text) && (!(!(match = text.match(pseudoArgs)) || !match[5] && ":" !== match[2] && !compare[match[2]]) && (uri = $(elem).uri(),
                match[5] ? uri.is(match[5]) : ":" === match[2] ? (property = match[1].toLowerCase() + ":",
                !!compare[property] && compare[property](uri, match[4])) : (property = match[1].toLowerCase(),
                !!comparable[property] && compare[match[2]](uri[property](), match[4], property))))
            }
            var comparable = {}
              , compare = {
                "=": function(value, target) {
                    return value === target
                },
                "^=": function(value, target) {
                    return !!(value + "").match(new RegExp("^" + escapeRegEx(target),"i"))
                },
                "$=": function(value, target) {
                    return !!(value + "").match(new RegExp(escapeRegEx(target) + "$","i"))
                },
                "*=": function(value, target, property) {
                    return "directory" === property && (value += "/"),
                    !!(value + "").match(new RegExp(escapeRegEx(target),"i"))
                },
                "equals:": function(uri, target) {
                    return uri.equals(target)
                },
                "is:": function(uri, target) {
                    return uri.is(target)
                }
            };
            $.each("origin authority directory domain filename fragment hash host hostname href password path pathname port protocol query resource scheme search subdomain suffix tld username".split(" "), function(k, v) {
                comparable[v] = !0,
                $.attrHooks["uri:" + v] = generateAccessor(v)
            });
            var _attrHooks = {
                get: function(elem) {
                    return $(elem).uri()
                },
                set: function(elem, value) {
                    return $(elem).uri().href(value).toString()
                }
            };
            $.each(["src", "href", "action", "uri", "cite"], function(k, v) {
                $.attrHooks[v] = {
                    set: _attrHooks.set
                }
            }),
            $.attrHooks.uri.get = _attrHooks.get,
            $.fn.uri = function(uri) {
                var $this = this.first()
                  , elem = $this.get(0)
                  , property = getUriProperty(elem);
                if (!property)
                    throw new Error('Element "' + elem.nodeName + '" does not have either property: href, src, action, cite');
                if (void 0 !== uri) {
                    var old = $this.data("uri");
                    if (old)
                        return old.href(uri);
                    uri instanceof URI || (uri = URI(uri || ""))
                } else {
                    if (uri = $this.data("uri"))
                        return uri;
                    uri = URI($this.attr(property) || "")
                }
                return uri._dom_element = elem,
                uri._dom_attribute = property,
                uri.normalize(),
                $this.data("uri", uri),
                uri
            }
            ,
            URI.prototype.build = function(deferBuild) {
                return this._dom_element ? (this._string = URI.build(this._parts),
                this._deferred_build = !1,
                this._dom_element.setAttribute(this._dom_attribute, this._string),
                this._dom_element[this._dom_attribute] = this._string) : !0 === deferBuild ? this._deferred_build = !0 : (void 0 === deferBuild || this._deferred_build) && (this._string = URI.build(this._parts),
                this._deferred_build = !1),
                this
            }
            ;
            var uriSizzle, pseudoArgs = /^([a-zA-Z]+)\s*([\^\$*]?=|:)\s*(['"]?)(.+)\3|^\s*([a-zA-Z0-9]+)\s*$/;
            return uriSizzle = $.expr.createPseudo ? $.expr.createPseudo(function(text) {
                return function(elem) {
                    return uriPseudo(elem, text)
                }
            }) : function(elem, i, match) {
                return uriPseudo(elem, match[3])
            }
            ,
            $.expr[":"].uri = uriSizzle,
            $
        })
    }
    , {
        "./URI": 24,
        jquery: 10
    }],
    26: [function(require, module, exports) {
        (function(global) {
            !function(root) {
                function error(type) {
                    throw new RangeError(errors[type])
                }
                function map(array, fn) {
                    for (var length = array.length, result = []; length--; )
                        result[length] = fn(array[length]);
                    return result
                }
                function mapDomain(string, fn) {
                    var parts = string.split("@")
                      , result = "";
                    return parts.length > 1 && (result = parts[0] + "@",
                    string = parts[1]),
                    result + map((string = string.replace(regexSeparators, ".")).split("."), fn).join(".")
                }
                function ucs2decode(string) {
                    for (var value, extra, output = [], counter = 0, length = string.length; counter < length; )
                        (value = string.charCodeAt(counter++)) >= 55296 && value <= 56319 && counter < length ? 56320 == (64512 & (extra = string.charCodeAt(counter++))) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value),
                        counter--) : output.push(value);
                    return output
                }
                function ucs2encode(array) {
                    return map(array, function(value) {
                        var output = "";
                        return value > 65535 && (output += stringFromCharCode((value -= 65536) >>> 10 & 1023 | 55296),
                        value = 56320 | 1023 & value),
                        output += stringFromCharCode(value)
                    }).join("")
                }
                function basicToDigit(codePoint) {
                    return codePoint - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : base
                }
                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5)
                }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    for (delta = firstTime ? floor(delta / damp) : delta >> 1,
                    delta += floor(delta / numPoints); delta > baseMinusTMin * tMax >> 1; k += base)
                        delta = floor(delta / baseMinusTMin);
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew))
                }
                function decode(input) {
                    var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, output = [], inputLength = input.length, i = 0, n = initialN, bias = initialBias;
                    for ((basic = input.lastIndexOf(delimiter)) < 0 && (basic = 0),
                    j = 0; j < basic; ++j)
                        input.charCodeAt(j) >= 128 && error("not-basic"),
                        output.push(input.charCodeAt(j));
                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                        for (oldi = i,
                        w = 1,
                        k = base; index >= inputLength && error("invalid-input"),
                        ((digit = basicToDigit(input.charCodeAt(index++))) >= base || digit > floor((maxInt - i) / w)) && error("overflow"),
                        i += digit * w,
                        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias,
                        !(digit < t); k += base)
                            w > floor(maxInt / (baseMinusT = base - t)) && error("overflow"),
                            w *= baseMinusT;
                        bias = adapt(i - oldi, out = output.length + 1, 0 == oldi),
                        floor(i / out) > maxInt - n && error("overflow"),
                        n += floor(i / out),
                        i %= out,
                        output.splice(i++, 0, n)
                    }
                    return ucs2encode(output)
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                    for (inputLength = (input = ucs2decode(input)).length,
                    n = initialN,
                    delta = 0,
                    bias = initialBias,
                    j = 0; j < inputLength; ++j)
                        (currentValue = input[j]) < 128 && output.push(stringFromCharCode(currentValue));
                    for (handledCPCount = basicLength = output.length,
                    basicLength && output.push(delimiter); handledCPCount < inputLength; ) {
                        for (m = maxInt,
                        j = 0; j < inputLength; ++j)
                            (currentValue = input[j]) >= n && currentValue < m && (m = currentValue);
                        for (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1)) && error("overflow"),
                        delta += (m - n) * handledCPCountPlusOne,
                        n = m,
                        j = 0; j < inputLength; ++j)
                            if ((currentValue = input[j]) < n && ++delta > maxInt && error("overflow"),
                            currentValue == n) {
                                for (q = delta,
                                k = base; t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias,
                                !(q < t); k += base)
                                    qMinusT = q - t,
                                    baseMinusT = base - t,
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))),
                                    q = floor(qMinusT / baseMinusT);
                                output.push(stringFromCharCode(digitToBasic(q, 0))),
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength),
                                delta = 0,
                                ++handledCPCount
                            }
                        ++delta,
                        ++n
                    }
                    return output.join("")
                }
                var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports
                  , freeModule = "object" == typeof module && module && !module.nodeType && module
                  , freeGlobal = "object" == typeof global && global;
                freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal);
                var punycode, key, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
                if (punycode = {
                    version: "1.3.2",
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: function(input) {
                        return mapDomain(input, function(string) {
                            return regexNonASCII.test(string) ? "xn--" + encode(string) : string
                        })
                    },
                    toUnicode: function(input) {
                        return mapDomain(input, function(string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string
                        })
                    }
                },
                "function" == typeof define && "object" == typeof define.amd && define.amd)
                    define("punycode", function() {
                        return punycode
                    });
                else if (freeExports && freeModule)
                    if (module.exports == freeExports)
                        freeModule.exports = punycode;
                    else
                        for (key in punycode)
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                else
                    root.punycode = punycode
            }(this)
        }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    , {}],
    27: [function(require, module, exports) {
        (function(global) {
            !function(f) {
                if ("object" == typeof exports && void 0 !== module)
                    module.exports = f();
                else if ("function" == typeof define && define.amd)
                    define([], f);
                else {
                    ("undefined" != typeof window ? window : void 0 !== global ? global : "undefined" != typeof self ? self : this).vex = f()
                }
            }(function() {
                return function() {
                    function e(t, n, r) {
                        function s(o, u) {
                            if (!n[o]) {
                                if (!t[o]) {
                                    var a = "function" == typeof require && require;
                                    if (!u && a)
                                        return a(o, !0);
                                    if (i)
                                        return i(o, !0);
                                    var f = new Error("Cannot find module '" + o + "'");
                                    throw f.code = "MODULE_NOT_FOUND",
                                    f
                                }
                                var l = n[o] = {
                                    exports: {}
                                };
                                t[o][0].call(l.exports, function(e) {
                                    var n = t[o][1][e];
                                    return s(n || e)
                                }, l, l.exports, e, t, n, r)
                            }
                            return n[o].exports
                        }
                        for (var i = "function" == typeof require && require, o = 0; o < r.length; o++)
                            s(r[o]);
                        return s
                    }
                    return e
                }()({
                    1: [function(require, module, exports) {
                        "document"in window.self && ("classList"in document.createElement("_") && (!document.createElementNS || "classList"in document.createElementNS("http://www.w3.org/2000/svg", "g")) || function(view) {
                            "use strict";
                            if ("Element"in view) {
                                var elemCtrProto = view.Element.prototype
                                  , objCtr = Object
                                  , strTrim = String.prototype.trim || function() {
                                    return this.replace(/^\s+|\s+$/g, "")
                                }
                                  , arrIndexOf = Array.prototype.indexOf || function(item) {
                                    for (var i = 0, len = this.length; i < len; i++)
                                        if (i in this && this[i] === item)
                                            return i;
                                    return -1
                                }
                                  , DOMEx = function(type, message) {
                                    this.name = type,
                                    this.code = DOMException[type],
                                    this.message = message
                                }
                                  , checkTokenAndGetIndex = function(classList, token) {
                                    if ("" === token)
                                        throw new DOMEx("SYNTAX_ERR","An invalid or illegal string was specified");
                                    if (/\s/.test(token))
                                        throw new DOMEx("INVALID_CHARACTER_ERR","String contains an invalid character");
                                    return arrIndexOf.call(classList, token)
                                }
                                  , ClassList = function(elem) {
                                    for (var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""), classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [], i = 0, len = classes.length; i < len; i++)
                                        this.push(classes[i]);
                                    this._updateClassName = function() {
                                        elem.setAttribute("class", this.toString())
                                    }
                                }
                                  , classListProto = ClassList.prototype = []
                                  , classListGetter = function() {
                                    return new ClassList(this)
                                };
                                if (DOMEx.prototype = Error.prototype,
                                classListProto.item = function(i) {
                                    return this[i] || null
                                }
                                ,
                                classListProto.contains = function(token) {
                                    return token += "",
                                    -1 !== checkTokenAndGetIndex(this, token)
                                }
                                ,
                                classListProto.add = function() {
                                    var token, tokens = arguments, i = 0, l = tokens.length, updated = !1;
                                    do {
                                        token = tokens[i] + "",
                                        -1 === checkTokenAndGetIndex(this, token) && (this.push(token),
                                        updated = !0)
                                    } while (++i < l);updated && this._updateClassName()
                                }
                                ,
                                classListProto.remove = function() {
                                    var token, index, tokens = arguments, i = 0, l = tokens.length, updated = !1;
                                    do {
                                        for (token = tokens[i] + "",
                                        index = checkTokenAndGetIndex(this, token); -1 !== index; )
                                            this.splice(index, 1),
                                            updated = !0,
                                            index = checkTokenAndGetIndex(this, token)
                                    } while (++i < l);updated && this._updateClassName()
                                }
                                ,
                                classListProto.toggle = function(token, force) {
                                    token += "";
                                    var result = this.contains(token)
                                      , method = result ? !0 !== force && "remove" : !1 !== force && "add";
                                    return method && this[method](token),
                                    !0 === force || !1 === force ? force : !result
                                }
                                ,
                                classListProto.toString = function() {
                                    return this.join(" ")
                                }
                                ,
                                objCtr.defineProperty) {
                                    var classListPropDesc = {
                                        get: classListGetter,
                                        enumerable: !0,
                                        configurable: !0
                                    };
                                    try {
                                        objCtr.defineProperty(elemCtrProto, "classList", classListPropDesc)
                                    } catch (ex) {
                                        void 0 !== ex.number && -2146823252 !== ex.number || (classListPropDesc.enumerable = !1,
                                        objCtr.defineProperty(elemCtrProto, "classList", classListPropDesc))
                                    }
                                } else
                                    objCtr.prototype.__defineGetter__ && elemCtrProto.__defineGetter__("classList", classListGetter)
                            }
                        }(window.self),
                        function() {
                            "use strict";
                            var testElement = document.createElement("_");
                            if (testElement.classList.add("c1", "c2"),
                            !testElement.classList.contains("c2")) {
                                var createMethod = function(method) {
                                    var original = DOMTokenList.prototype[method];
                                    DOMTokenList.prototype[method] = function(token) {
                                        var i, len = arguments.length;
                                        for (i = 0; i < len; i++)
                                            token = arguments[i],
                                            original.call(this, token)
                                    }
                                };
                                createMethod("add"),
                                createMethod("remove")
                            }
                            if (testElement.classList.toggle("c3", !1),
                            testElement.classList.contains("c3")) {
                                var _toggle = DOMTokenList.prototype.toggle;
                                DOMTokenList.prototype.toggle = function(token, force) {
                                    return 1 in arguments && !this.contains(token) == !force ? force : _toggle.call(this, token)
                                }
                            }
                            testElement = null
                        }())
                    }
                    , {}],
                    2: [function(require, module, exports) {
                        module.exports = function(html, doc) {
                            if ("string" != typeof html)
                                throw new TypeError("String expected");
                            doc || (doc = document);
                            var m = /<([\w:]+)/.exec(html);
                            if (!m)
                                return doc.createTextNode(html);
                            html = html.replace(/^\s+|\s+$/g, "");
                            var tag = m[1];
                            if ("body" == tag)
                                return (el = doc.createElement("html")).innerHTML = html,
                                el.removeChild(el.lastChild);
                            var wrap = map[tag] || map._default
                              , depth = wrap[0]
                              , prefix = wrap[1]
                              , suffix = wrap[2]
                              , el = doc.createElement("div");
                            for (el.innerHTML = prefix + html + suffix; depth--; )
                                el = el.lastChild;
                            if (el.firstChild == el.lastChild)
                                return el.removeChild(el.firstChild);
                            for (var fragment = doc.createDocumentFragment(); el.firstChild; )
                                fragment.appendChild(el.removeChild(el.firstChild));
                            return fragment
                        }
                        ;
                        var bugTestDiv, innerHTMLBug = !1;
                        "undefined" != typeof document && ((bugTestDiv = document.createElement("div")).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
                        innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length,
                        bugTestDiv = void 0);
                        var map = {
                            legend: [1, "<fieldset>", "</fieldset>"],
                            tr: [2, "<table><tbody>", "</tbody></table>"],
                            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
                            _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
                        };
                        map.td = map.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                        map.option = map.optgroup = [1, '<select multiple="multiple">', "</select>"],
                        map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, "<table>", "</table>"],
                        map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"]
                    }
                    , {}],
                    3: [function(require, module, exports) {
                        "use strict";
                        function assign(target, firstSource) {
                            if (void 0 === target || null === target)
                                throw new TypeError("Cannot convert first argument to object");
                            for (var to = Object(target), i = 1; i < arguments.length; i++) {
                                var nextSource = arguments[i];
                                if (void 0 !== nextSource && null !== nextSource)
                                    for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                                        var nextKey = keysArray[nextIndex]
                                          , desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                                        void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey])
                                    }
                            }
                            return to
                        }
                        module.exports = {
                            assign: assign,
                            polyfill: function() {
                                Object.assign || Object.defineProperty(Object, "assign", {
                                    enumerable: !1,
                                    configurable: !0,
                                    writable: !0,
                                    value: assign
                                })
                            }
                        }
                    }
                    , {}],
                    4: [function(require, module, exports) {
                        require("classlist-polyfill"),
                        require("es6-object-assign").polyfill();
                        var domify = require("domify")
                          , escapeHtml = function(str) {
                            if (void 0 !== str) {
                                var div = document.createElement("div");
                                return div.appendChild(document.createTextNode(str)),
                                div.innerHTML
                            }
                            return ""
                        }
                          , addClasses = function(el, classStr) {
                            if ("string" == typeof classStr && 0 !== classStr.length)
                                for (var classes = classStr.split(" "), i = 0; i < classes.length; i++) {
                                    var className = classes[i];
                                    className.length && el.classList.add(className)
                                }
                        }
                          , animationEndEvent = function() {
                            var el = document.createElement("div")
                              , eventNames = {
                                animation: "animationend",
                                WebkitAnimation: "webkitAnimationEnd",
                                MozAnimation: "animationend",
                                OAnimation: "oanimationend",
                                msAnimation: "MSAnimationEnd"
                            };
                            for (var i in eventNames)
                                if (void 0 !== el.style[i])
                                    return eventNames[i];
                            return !1
                        }()
                          , baseClassNames = {
                            vex: "vex",
                            content: "vex-content",
                            overlay: "vex-overlay",
                            close: "vex-close",
                            closing: "vex-closing",
                            open: "vex-open"
                        }
                          , vexes = {}
                          , globalId = 1
                          , isEscapeActive = !1
                          , vex = {
                            open: function(opts) {
                                var warnDeprecated = function(prop) {
                                    console.warn('The "' + prop + '" property is deprecated in vex 3. Use CSS classes and the appropriate "ClassName" options, instead.'),
                                    console.warn("See http://github.hubspot.com/vex/api/advanced/#options")
                                };
                                opts.css && warnDeprecated("css"),
                                opts.overlayCSS && warnDeprecated("overlayCSS"),
                                opts.contentCSS && warnDeprecated("contentCSS"),
                                opts.closeCSS && warnDeprecated("closeCSS");
                                var vexInstance = {};
                                vexInstance.id = globalId++,
                                vexes[vexInstance.id] = vexInstance,
                                vexInstance.isOpen = !0,
                                vexInstance.close = function() {
                                    function hasAnimationPre(prefix) {
                                        return "none" !== style.getPropertyValue(prefix + "animation-name") && "0s" !== style.getPropertyValue(prefix + "animation-duration")
                                    }
                                    if (!this.isOpen)
                                        return !0;
                                    var options = this.options;
                                    if (isEscapeActive && !options.escapeButtonCloses)
                                        return !1;
                                    if (!1 === function() {
                                        return !options.beforeClose || options.beforeClose.call(this)
                                    }
                                    .bind(this)())
                                        return !1;
                                    this.isOpen = !1;
                                    var style = window.getComputedStyle(this.contentEl)
                                      , hasAnimation = hasAnimationPre("") || hasAnimationPre("-webkit-") || hasAnimationPre("-moz-") || hasAnimationPre("-o-")
                                      , close = function close() {
                                        this.rootEl.parentNode && (this.rootEl.removeEventListener(animationEndEvent, close),
                                        this.overlayEl.removeEventListener(animationEndEvent, close),
                                        delete vexes[this.id],
                                        this.rootEl.parentNode.removeChild(this.rootEl),
                                        this.bodyEl.removeChild(this.overlayEl),
                                        options.afterClose && options.afterClose.call(this),
                                        0 === Object.keys(vexes).length && document.body.classList.remove(baseClassNames.open))
                                    }
                                    .bind(this);
                                    return animationEndEvent && hasAnimation ? (this.rootEl.addEventListener(animationEndEvent, close),
                                    this.overlayEl.addEventListener(animationEndEvent, close),
                                    this.rootEl.classList.add(baseClassNames.closing),
                                    this.overlayEl.classList.add(baseClassNames.closing)) : close(),
                                    !0
                                }
                                ,
                                "string" == typeof opts && (opts = {
                                    content: opts
                                }),
                                opts.unsafeContent && !opts.content ? opts.content = opts.unsafeContent : opts.content && (opts.content = escapeHtml(opts.content));
                                var options = vexInstance.options = Object.assign({}, vex.defaultOptions, opts)
                                  , bodyEl = vexInstance.bodyEl = document.getElementsByTagName("body")[0]
                                  , rootEl = vexInstance.rootEl = document.createElement("div");
                                rootEl.classList.add(baseClassNames.vex),
                                addClasses(rootEl, options.className);
                                var overlayEl = vexInstance.overlayEl = document.createElement("div");
                                overlayEl.classList.add(baseClassNames.overlay),
                                addClasses(overlayEl, options.overlayClassName),
                                options.overlayClosesOnClick && rootEl.addEventListener("click", function(e) {
                                    e.target === rootEl && vexInstance.close()
                                }),
                                bodyEl.appendChild(overlayEl);
                                var contentEl = vexInstance.contentEl = document.createElement("div");
                                if (contentEl.classList.add(baseClassNames.content),
                                addClasses(contentEl, options.contentClassName),
                                contentEl.appendChild(options.content instanceof window.Node ? options.content : domify(options.content)),
                                rootEl.appendChild(contentEl),
                                options.showCloseButton) {
                                    var closeEl = vexInstance.closeEl = document.createElement("div");
                                    closeEl.classList.add(baseClassNames.close),
                                    addClasses(closeEl, options.closeClassName),
                                    closeEl.addEventListener("click", vexInstance.close.bind(vexInstance)),
                                    contentEl.appendChild(closeEl)
                                }
                                return document.querySelector(options.appendLocation).appendChild(rootEl),
                                options.afterOpen && options.afterOpen.call(vexInstance),
                                document.body.classList.add(baseClassNames.open),
                                vexInstance
                            },
                            close: function(vexOrId) {
                                var id;
                                if (vexOrId.id)
                                    id = vexOrId.id;
                                else {
                                    if ("string" != typeof vexOrId)
                                        throw new TypeError("close requires a vex object or id string");
                                    id = vexOrId
                                }
                                return !!vexes[id] && vexes[id].close()
                            },
                            closeTop: function() {
                                var ids = Object.keys(vexes);
                                return !!ids.length && vexes[ids[ids.length - 1]].close()
                            },
                            closeAll: function() {
                                for (var id in vexes)
                                    this.close(id);
                                return !0
                            },
                            getAll: function() {
                                return vexes
                            },
                            getById: function(id) {
                                return vexes[id]
                            }
                        };
                        window.addEventListener("keyup", function(e) {
                            27 === e.keyCode && (isEscapeActive = !0,
                            vex.closeTop(),
                            isEscapeActive = !1)
                        }),
                        window.addEventListener("popstate", function() {
                            vex.defaultOptions.closeAllOnPopState && vex.closeAll()
                        }),
                        vex.defaultOptions = {
                            content: "",
                            showCloseButton: !0,
                            escapeButtonCloses: !0,
                            overlayClosesOnClick: !0,
                            appendLocation: "body",
                            className: "",
                            overlayClassName: "",
                            contentClassName: "",
                            closeClassName: "",
                            closeAllOnPopState: !0
                        },
                        Object.defineProperty(vex, "_escapeHtml", {
                            configurable: !1,
                            enumerable: !1,
                            writable: !1,
                            value: escapeHtml
                        }),
                        vex.registerPlugin = function(pluginFn, name) {
                            var plugin = pluginFn(vex)
                              , pluginName = name || plugin.name;
                            if (vex[pluginName])
                                throw new Error("Plugin " + name + " is already registered.");
                            vex[pluginName] = plugin
                        }
                        ,
                        module.exports = vex
                    }
                    , {
                        "classlist-polyfill": 1,
                        domify: 2,
                        "es6-object-assign": 3
                    }]
                }, {}, [4])(4)
            })
        }
        ).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }
    , {
        "classlist-polyfill": 29,
        domify: 30,
        "es6-object-assign": 31
    }],
    28: [function(require, module, exports) {
        !function(root, factory) {
            "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("whatInput", [], factory) : "object" == typeof exports ? exports.whatInput = factory() : root.whatInput = factory()
        }(this, function() {
            return function(modules) {
                function __webpack_require__(moduleId) {
                    if (installedModules[moduleId])
                        return installedModules[moduleId].exports;
                    var module = installedModules[moduleId] = {
                        exports: {},
                        id: moduleId,
                        loaded: !1
                    };
                    return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__),
                    module.loaded = !0,
                    module.exports
                }
                var installedModules = {};
                return __webpack_require__.m = modules,
                __webpack_require__.c = installedModules,
                __webpack_require__.p = "",
                __webpack_require__(0)
            }([function(module, exports) {
                "use strict";
                module.exports = function() {
                    if ("undefined" == typeof document || "undefined" == typeof window)
                        return {
                            ask: function() {
                                return "initial"
                            },
                            element: function() {
                                return null
                            },
                            ignoreKeys: function() {},
                            specificKeys: function() {},
                            registerOnChange: function() {},
                            unRegisterOnChange: function() {}
                        };
                    var docElem = document.documentElement
                      , currentElement = null
                      , currentInput = "initial"
                      , currentIntent = currentInput
                      , currentTimestamp = Date.now();
                    try {
                        window.sessionStorage.getItem("what-input") && (currentInput = window.sessionStorage.getItem("what-input")),
                        window.sessionStorage.getItem("what-intent") && (currentIntent = window.sessionStorage.getItem("what-intent"))
                    } catch (e) {}
                    var formInputs = ["input", "select", "textarea"]
                      , functionList = []
                      , ignoreMap = [16, 17, 18, 91, 93]
                      , specificMap = []
                      , inputMap = {
                        keydown: "keyboard",
                        keyup: "keyboard",
                        mousedown: "mouse",
                        mousemove: "mouse",
                        MSPointerDown: "pointer",
                        MSPointerMove: "pointer",
                        pointerdown: "pointer",
                        pointermove: "pointer",
                        touchstart: "touch",
                        touchend: "touch"
                    }
                      , isScrolling = !1
                      , mousePos = {
                        x: null,
                        y: null
                    }
                      , pointerMap = {
                        2: "touch",
                        3: "touch",
                        4: "mouse"
                    }
                      , supportsPassive = !1;
                    try {
                        var opts = Object.defineProperty({}, "passive", {
                            get: function() {
                                supportsPassive = !0
                            }
                        });
                        window.addEventListener("test", null, opts)
                    } catch (e) {}
                    var addListeners = function() {
                        var options = !!supportsPassive && {
                            passive: !0
                        };
                        window.PointerEvent ? (window.addEventListener("pointerdown", setInput),
                        window.addEventListener("pointermove", setIntent)) : window.MSPointerEvent ? (window.addEventListener("MSPointerDown", setInput),
                        window.addEventListener("MSPointerMove", setIntent)) : (window.addEventListener("mousedown", setInput),
                        window.addEventListener("mousemove", setIntent),
                        "ontouchstart"in window && (window.addEventListener("touchstart", setInput, options),
                        window.addEventListener("touchend", setInput))),
                        window.addEventListener(detectWheel(), setIntent, options),
                        window.addEventListener("keydown", setInput),
                        window.addEventListener("keyup", setInput),
                        window.addEventListener("focusin", setElement),
                        window.addEventListener("focusout", clearElement)
                    }
                      , setInput = function(event) {
                        var eventKey = event.which
                          , value = inputMap[event.type];
                        "pointer" === value && (value = pointerType(event));
                        var ignoreMatch = !specificMap.length && -1 === ignoreMap.indexOf(eventKey)
                          , specificMatch = specificMap.length && -1 !== specificMap.indexOf(eventKey)
                          , shouldUpdate = "keyboard" === value && eventKey && (ignoreMatch || specificMatch) || "mouse" === value || "touch" === value;
                        if (validateTouch(value) && (shouldUpdate = !1),
                        shouldUpdate && currentInput !== value) {
                            currentInput = value;
                            try {
                                window.sessionStorage.setItem("what-input", currentInput)
                            } catch (e) {}
                            doUpdate("input")
                        }
                        if (shouldUpdate && currentIntent !== value) {
                            var activeElem = document.activeElement;
                            if (activeElem && activeElem.nodeName && -1 === formInputs.indexOf(activeElem.nodeName.toLowerCase())) {
                                currentIntent = value;
                                try {
                                    window.sessionStorage.setItem("what-intent", currentIntent)
                                } catch (e) {}
                                doUpdate("intent")
                            }
                        }
                    }
                      , doUpdate = function(which) {
                        docElem.setAttribute("data-what" + which, "input" === which ? currentInput : currentIntent),
                        fireFunctions(which)
                    }
                      , setIntent = function(event) {
                        var value = inputMap[event.type];
                        if ("pointer" === value && (value = pointerType(event)),
                        detectScrolling(event),
                        !isScrolling && !validateTouch(value) && currentIntent !== value) {
                            currentIntent = value;
                            try {
                                window.sessionStorage.setItem("what-intent", currentIntent)
                            } catch (e) {}
                            doUpdate("intent")
                        }
                    }
                      , setElement = function(event) {
                        event.target.nodeName ? (currentElement = event.target.nodeName.toLowerCase(),
                        docElem.setAttribute("data-whatelement", currentElement),
                        event.target.classList && event.target.classList.length && docElem.setAttribute("data-whatclasses", event.target.classList.toString().replace(" ", ","))) : clearElement()
                    }
                      , clearElement = function() {
                        currentElement = null,
                        docElem.removeAttribute("data-whatelement"),
                        docElem.removeAttribute("data-whatclasses")
                    }
                      , pointerType = function(event) {
                        return "number" == typeof event.pointerType ? pointerMap[event.pointerType] : "pen" === event.pointerType ? "touch" : event.pointerType
                    }
                      , validateTouch = function(value) {
                        var timestamp = Date.now()
                          , touchIsValid = "mouse" === value && "touch" === currentInput && timestamp - currentTimestamp < 200;
                        return currentTimestamp = timestamp,
                        touchIsValid
                    }
                      , detectWheel = function() {
                        return "onwheel"in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll"
                    }
                      , fireFunctions = function(type) {
                        for (var i = 0, len = functionList.length; i < len; i++)
                            functionList[i].type === type && functionList[i].fn.call(void 0, "input" === type ? currentInput : currentIntent)
                    }
                      , objPos = function(match) {
                        for (var i = 0, len = functionList.length; i < len; i++)
                            if (functionList[i].fn === match)
                                return i
                    }
                      , detectScrolling = function(event) {
                        mousePos.x !== event.screenX || mousePos.y !== event.screenY ? (isScrolling = !1,
                        mousePos.x = event.screenX,
                        mousePos.y = event.screenY) : isScrolling = !0
                    };
                    return "addEventListener"in window && Array.prototype.indexOf && (inputMap[detectWheel()] = "mouse",
                    addListeners(),
                    doUpdate("input"),
                    doUpdate("intent")),
                    {
                        ask: function(opt) {
                            return "intent" === opt ? currentIntent : currentInput
                        },
                        element: function() {
                            return currentElement
                        },
                        ignoreKeys: function(arr) {
                            ignoreMap = arr
                        },
                        specificKeys: function(arr) {
                            specificMap = arr
                        },
                        registerOnChange: function(fn, eventType) {
                            functionList.push({
                                fn: fn,
                                type: eventType || "input"
                            })
                        },
                        unRegisterOnChange: function(fn) {
                            var position = objPos(fn);
                            (position || 0 === position) && functionList.splice(position, 1)
                        }
                    }
                }()
            }
            ])
        })
    }
    , {}],
    29: [function(require, module, exports) {
        "document"in window.self && ("classList"in document.createElement("_") && (!document.createElementNS || "classList"in document.createElementNS("http://www.w3.org/2000/svg", "g")) || function(view) {
            "use strict";
            if ("Element"in view) {
                var elemCtrProto = view.Element.prototype
                  , objCtr = Object
                  , strTrim = String.prototype.trim || function() {
                    return this.replace(/^\s+|\s+$/g, "")
                }
                  , arrIndexOf = Array.prototype.indexOf || function(item) {
                    for (var i = 0, len = this.length; i < len; i++)
                        if (i in this && this[i] === item)
                            return i;
                    return -1
                }
                  , DOMEx = function(type, message) {
                    this.name = type,
                    this.code = DOMException[type],
                    this.message = message
                }
                  , checkTokenAndGetIndex = function(classList, token) {
                    if ("" === token)
                        throw new DOMEx("SYNTAX_ERR","An invalid or illegal string was specified");
                    if (/\s/.test(token))
                        throw new DOMEx("INVALID_CHARACTER_ERR","String contains an invalid character");
                    return arrIndexOf.call(classList, token)
                }
                  , ClassList = function(elem) {
                    for (var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""), classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [], i = 0, len = classes.length; i < len; i++)
                        this.push(classes[i]);
                    this._updateClassName = function() {
                        elem.setAttribute("class", this.toString())
                    }
                }
                  , classListProto = ClassList.prototype = []
                  , classListGetter = function() {
                    return new ClassList(this)
                };
                if (DOMEx.prototype = Error.prototype,
                classListProto.item = function(i) {
                    return this[i] || null
                }
                ,
                classListProto.contains = function(token) {
                    return token += "",
                    -1 !== checkTokenAndGetIndex(this, token)
                }
                ,
                classListProto.add = function() {
                    var token, tokens = arguments, i = 0, l = tokens.length, updated = !1;
                    do {
                        token = tokens[i] + "",
                        -1 === checkTokenAndGetIndex(this, token) && (this.push(token),
                        updated = !0)
                    } while (++i < l);updated && this._updateClassName()
                }
                ,
                classListProto.remove = function() {
                    var token, index, tokens = arguments, i = 0, l = tokens.length, updated = !1;
                    do {
                        for (token = tokens[i] + "",
                        index = checkTokenAndGetIndex(this, token); -1 !== index; )
                            this.splice(index, 1),
                            updated = !0,
                            index = checkTokenAndGetIndex(this, token)
                    } while (++i < l);updated && this._updateClassName()
                }
                ,
                classListProto.toggle = function(token, force) {
                    token += "";
                    var result = this.contains(token)
                      , method = result ? !0 !== force && "remove" : !1 !== force && "add";
                    return method && this[method](token),
                    !0 === force || !1 === force ? force : !result
                }
                ,
                classListProto.toString = function() {
                    return this.join(" ")
                }
                ,
                objCtr.defineProperty) {
                    var classListPropDesc = {
                        get: classListGetter,
                        enumerable: !0,
                        configurable: !0
                    };
                    try {
                        objCtr.defineProperty(elemCtrProto, "classList", classListPropDesc)
                    } catch (ex) {
                        void 0 !== ex.number && -2146823252 !== ex.number || (classListPropDesc.enumerable = !1,
                        objCtr.defineProperty(elemCtrProto, "classList", classListPropDesc))
                    }
                } else
                    objCtr.prototype.__defineGetter__ && elemCtrProto.__defineGetter__("classList", classListGetter)
            }
        }(window.self),
        function() {
            "use strict";
            var testElement = document.createElement("_");
            if (testElement.classList.add("c1", "c2"),
            !testElement.classList.contains("c2")) {
                var createMethod = function(method) {
                    var original = DOMTokenList.prototype[method];
                    DOMTokenList.prototype[method] = function(token) {
                        var i, len = arguments.length;
                        for (i = 0; i < len; i++)
                            token = arguments[i],
                            original.call(this, token)
                    }
                };
                createMethod("add"),
                createMethod("remove")
            }
            if (testElement.classList.toggle("c3", !1),
            testElement.classList.contains("c3")) {
                var _toggle = DOMTokenList.prototype.toggle;
                DOMTokenList.prototype.toggle = function(token, force) {
                    return 1 in arguments && !this.contains(token) == !force ? force : _toggle.call(this, token)
                }
            }
            testElement = null
        }())
    }
    , {}],
    30: [function(require, module, exports) {
        module.exports = function(html, doc) {
            if ("string" != typeof html)
                throw new TypeError("String expected");
            doc || (doc = document);
            var m = /<([\w:]+)/.exec(html);
            if (!m)
                return doc.createTextNode(html);
            html = html.replace(/^\s+|\s+$/g, "");
            var tag = m[1];
            if ("body" == tag)
                return (el = doc.createElement("html")).innerHTML = html,
                el.removeChild(el.lastChild);
            var wrap = map[tag] || map._default
              , depth = wrap[0]
              , prefix = wrap[1]
              , suffix = wrap[2]
              , el = doc.createElement("div");
            for (el.innerHTML = prefix + html + suffix; depth--; )
                el = el.lastChild;
            if (el.firstChild == el.lastChild)
                return el.removeChild(el.firstChild);
            for (var fragment = doc.createDocumentFragment(); el.firstChild; )
                fragment.appendChild(el.removeChild(el.firstChild));
            return fragment
        }
        ;
        var bugTestDiv, innerHTMLBug = !1;
        "undefined" != typeof document && ((bugTestDiv = document.createElement("div")).innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>',
        innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length,
        bugTestDiv = void 0);
        var map = {
            legend: [1, "<fieldset>", "</fieldset>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
        };
        map.td = map.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        map.option = map.optgroup = [1, '<select multiple="multiple">', "</select>"],
        map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, "<table>", "</table>"],
        map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"]
    }
    , {}],
    31: [function(require, module, exports) {
        "use strict";
        function assign(target, firstSource) {
            if (void 0 === target || null === target)
                throw new TypeError("Cannot convert first argument to object");
            for (var to = Object(target), i = 1; i < arguments.length; i++) {
                var nextSource = arguments[i];
                if (void 0 !== nextSource && null !== nextSource)
                    for (var keysArray = Object.keys(Object(nextSource)), nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
                        var nextKey = keysArray[nextIndex]
                          , desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        void 0 !== desc && desc.enumerable && (to[nextKey] = nextSource[nextKey])
                    }
            }
            return to
        }
        module.exports = {
            assign: assign,
            polyfill: function() {
                Object.assign || Object.defineProperty(Object, "assign", {
                    enumerable: !1,
                    configurable: !0,
                    writable: !0,
                    value: assign
                })
            }
        }
    }
    , {}]
}, {}, [1]);
//# sourceMappingURL=libs.js.map
